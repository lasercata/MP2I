\documentclass[a4paper, 12pt, twoside]{article}


%------------------------------------------------------------------------
%
% Author                :   Lasercata
% Last modification     :   2022.03.14
%
%------------------------------------------------------------------------


%------ini
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[french]{babel}
%\usepackage[english]{babel}


%------geometry
\usepackage[textheight=700pt, textwidth=500pt]{geometry}


%------color
\usepackage{xcolor}
\definecolor{ff4500}{HTML}{ff4500}
\definecolor{00f}{HTML}{0000ff}
\definecolor{0ff}{HTML}{00ffff}
\definecolor{656565}{HTML}{656565}

\renewcommand{\emph}{\textcolor{ff4500}}
\renewcommand{\em}{\color{ff4500}}

\newcommand{\strong}[1]{\textcolor{ff4500}{\bf #1}}
\newcommand{\st}{\color{ff4500}\bf}


%------Code highlighting
\usepackage{listings}

\definecolor{cbg}{HTML}{272822}
\definecolor{cfg}{HTML}{ececec}
\definecolor{ccomment}{HTML}{686c58}
\definecolor{ckw}{HTML}{f92672}
\definecolor{cstring}{HTML}{e6db72}
\definecolor{cstringlight}{HTML}{98980f}
\definecolor{lightwhite}{HTML}{fafafa}

\lstdefinestyle{DarkCodeStyle}{
    backgroundcolor=\color{cbg},
    commentstyle=\itshape\color{ccomment},
    keywordstyle=\color{ckw},
    numberstyle=\tiny\color{cbg},
    stringstyle=\color{cstring},
    basicstyle=\ttfamily\footnotesize\color{cfg},
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    keepspaces=true,
    numbers=left,
    numbersep=5pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=4,
    xleftmargin=\leftskip
}

\lstdefinestyle{LightCodeStyle}{
    backgroundcolor=\color{lightwhite},
    commentstyle=\itshape\color{ccomment},
    keywordstyle=\color{ckw},
    numberstyle=\tiny\color{cbg},
    stringstyle=\color{cstringlight},
    basicstyle=\ttfamily\footnotesize\color{cbg},
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    keepspaces=true,
    numbers=left,
    numbersep=10pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=4,
    frame=L,
    xleftmargin=\leftskip
}

%\lstset{style=DarkCodeStyle}
\lstset{style=LightCodeStyle}

%Usage : \begin{lstlisting}[language=Caml] ... \end{lstlisting}


%-------make the table of content clickable
\usepackage{hyperref}
\hypersetup{
    colorlinks,
    citecolor=black,
    filecolor=black,
    linkcolor=black,
    urlcolor=black
}


%------pictures
\usepackage{graphicx}
%\usepackage{wrapfig}

\usepackage{tikz}
\usetikzlibrary{shapes.geometric}


%------tabular
%\usepackage{color}
%\usepackage{colortbl}
\usepackage{multirow}


%------Physics
%---Packages
%\usepackage[version=4]{mhchem} %$\ce{NO4^2-}$

%---Commands
\newcommand{\link}[2]{\mathrm{#1} \! - \! \mathrm{#2}}
\newcommand{\pt}[1]{\cdot 10^{#1}} % Power of ten
\newcommand{\dt}[2][t]{\dfrac{d#2}{d#1}} % Derivative


%------math
%---Packages
%\usepackage{textcomp}
%\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{mathtools} % For abs
\usepackage{stmaryrd} %for \llbracket and \rrbracket
\usepackage{mathrsfs} %for \mathscr{x} (different from \mathcal{x})

%---Commands
%-Sets
\newcommand{\N}{\mathbb{N}} %set N
\newcommand{\Z}{\mathbb{Z}} %set Z
\newcommand{\Q}{\mathbb{Q}} %set Q
\newcommand{\R}{\mathbb{R}} %set R
\newcommand{\C}{\mathbb{C}} %set C
\newcommand{\U}{\mathbb{U}} %set U
\newcommand{\seg}[2]{\left[ #1\ ;\ #2 \right]}
\newcommand{\nset}[2]{\left\llbracket #1\ ;\ #2 \right\rrbracket}

\newcommand{\lr}[1]{\left( #1 \right)}
\newcommand{\lrb}[1]{\left[ #1 \right]}
\newcommand{\set}[1]{\left\{ #1 \right\}}

%-Exponantial / complexs
\newcommand{\e}{\mathrm{e}}
\newcommand{\cj}[1]{\overline{#1}} %overline for the conjugate.

%-Vectors
\newcommand{\vect}{\overrightarrow}
\newcommand{\veco}[3]{\displaystyle \vect{#1}\binom{#2}{#3}} %vector + coord

%-Limits
\newcommand{\lm}[2][{}]{\lim\limits_{\substack{#2 \\ #1}}} %$\lm{x \to a} f$ or $\lm[x < a]{x \to a} f$
\newcommand{\Lm}[3][{}]{\lm[#1]{#2} \left( #3 \right)} %$\Lm{x \to a}{f}$ or $\Lm[x < a]{x \to a}{f}$
\newcommand{\tendsto}[1]{\xrightarrow[#1]{}}

%-Integral
\newcommand{\dint}[4][x]{\displaystyle \int_{#2}^{#3} #4 \mathrm{d} #1} %$\dint{a}{b}{f(x)}$ or $\dint[t]{a}{b}{f(t)}$

%-Others
\newcommand{\para}{\ /\!/\ } %//
\newcommand{\ssi}{\ \Leftrightarrow \ }
\newcommand{\abs}[1]{\left\lvert #1 \right\rvert} % abs{x} -> |x|
\newcommand{\eqsys}[2]{\begin{cases} #1 \\ #2 \end{cases}}

\newcommand{\med}[2]{\mathrm{med} \left[ #1\ ;\ #2 \right]}  %$\med{A}{B} -> med[A ; B]$
\newcommand{\Circ}[2]{\mathscr{C}_{#1, #2}}

\newcommand{\lrangle}[1]{\left\langle #1 \right\rangle}

\newcommand{\floor}[1]{\left\lfloor #1 \right\rfloor}
\newcommand{\ceil}[1]{\left\lceil #1 \right\rceil}

\renewcommand{\le}{\leqslant}
\renewcommand{\ge}{\geqslant}


%------commands
%---to quote french text
\newcommand{\simplecit}[1]{\guillemotleft$\;$#1$\;$\guillemotright}
\newcommand{\cit}[1]{\simplecit{\textcolor{656565}{#1}}}
\newcommand{\quo}[1]{\cit{\it #1}}

%---to indent
\newcommand{\ind}[1][20pt]{\advance\leftskip + #1}
\newcommand{\deind}[1][20pt]{\advance\leftskip - #1}

%---to indent a text
\newcommand{\indented}[2][20pt]{\par \ind[#1] #2 \par \deind[#1]}
\newenvironment{indt}[2][20pt]{#2 \par \ind[#1]}{\par \deind} %Titled indented env

%---title
\newcommand{\thetitle}[2]{\begin{center}\textbf{{\LARGE \underline{\emph{#1} :}} {\Large #2}}\end{center}}

%---parts
%-I
\newcommand{\mainpart}[2][$\!\!$]{\underline{\large \textbf{\emph{\textit{#1} #2}}}}
\newcommand{\bmainpart}[2][$\!\!$]{\underline{\large \textbf{\textit{#1} #2}}}
%-A
\newcommand{\subpart}[2][$\!\!$]{\underline{\bf \textit{#1} #2}}
%-1
\newcommand{\subsubpart}[2][$\!\!$]{\underline{\textsl{#1} #2}}
%-a
\newcommand{\subsubsubpart}[2][$\!\!$]{\underline{\it #1 #2}}


%------page style
\usepackage{fancyhdr}
\usepackage{lastpage}

\setlength{\headheight}{18pt}
\setlength{\footskip}{50pt}

\pagestyle{fancy}
\fancyhf{}
\fancyhead[LE, RO]{\textit{\today}}
\fancyhead[RE, LO]{\large{\textsl{\emph{\texttt{\jobname}}}}}

\fancyfoot[RO, LE]{\textit{\texttt{Page \thepage /\pageref{LastPage}}}}
\fancyfoot[LO, RE]{\includegraphics[scale=0.12]{/home/lasercata/Pictures/1.images_profil/logo/mieux/lasercata_logo_fly_fond_blanc.png}}


%------init lengths
\setlength{\parindent}{0pt} %To avoid using \noindent everywhere.
\setlength{\parskip}{3pt}


%---------------------------------Begin Document
\begin{document}
    
    \thetitle{Chapitre 6}{Compléments sur les structures de données}
    
    \tableofcontents
    \newpage
    
    
    \begin{indt}{\section{Arbres}}
        
        \begin{indt}{\subsection{Définition, vocabulaire}}
            \begin{indt}{\subsubsection{Définition (\textit{arbre})}}
                \label{1.1.1}
                \begin{indt}{Un arbre est un ensemble fini $A$ muni d'une relation $<$ telle que, si $A \neq \varnothing$ :}
                    (1) $\exists r_A \in A,\ |\ \forall x \in A,\ r_A \not < x$
                    
                    (2) $\forall x \in A \setminus \set{r_A},\ \exists ! y \in A \ |\ x < y$
                    
                    (3) $\forall x \in A \setminus \set{r_A},\ \exists n \in \N,\ \exists (x_k)_{k \in \nset 0 n} \subset A\ |\ x = x_0 < x_1 < \ldots < x_n < r_A$
                \end{indt}
            \end{indt}
            
            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Proposition}}
                Soit $(A, \ <)$ un arbre non vide.
                
                $r_A$ est unique et $\forall x \in A \setminus \set{r_A}$, on a l'unicité de $n, x_0 \ldots x_n$ dans le point (3)
                
                \vspace{12pt}
                
                $\square$ Démonstration :
                
                $\bullet$ S'il existe $r \neq r_A$ vérifiant les mêmes propriétés, alors par (2), $\exists x \in A\ |\ r < x$.
                
                Ceci contredit (1) pour $r$.
                
                $\bullet$ Soient
                $
                    \left|
                    \begin{array}{l}
                        x \in A \setminus \set{r_A}
                        \\
                        n, m \in \N
                        \\
                        (x_k)_{k \in \nset 0 n}, (y_k)_{k \in \nset 1 m} \subset A
                    \end{array}
                    \right.
                $
                tel que
                $
                    \eqsys
                        {x = x_0 < x_1 < \ldots < x_n < r_A}
                        {x = y_0 < y_1 < \ldots < y_m < r_A}
                $
                
                On suppose sans perte de généralité que $n \le m$.
                
                Supposons $\exists i \in \nset 0 n\ |\ x_i \neq y_i$. On choisit $i$ minimal.
                
                $i \neq 0$ car $x_0 = x = y_0$.
                
                On a donc $\begin{cases} x_{i - 1} < x_i \\ x_{i - 1} = y_{i - 1} < y_i \\ x_i \neq y_i \end{cases}$ qui contredit le point (2), donc $\forall i \in \nset 0 n,\ x_i = y_i$.
                
                Si $n < m$,
                $
                    \begin{cases}
                        x_n < r_A
                        \\
                        x_n = y_n < y_{n + 1}
                        \\
                        r_A \neq y_{n + 1}\ \text{car $n + 1 \le m$ et $\forall j  \in \nset 1 m,\ r_A \neq y_i$ (contredit (1))}
                    \end{cases}
                $
                
                Cela contredit (2)
                
                Donc $n = m$
                $\blacksquare$
            \end{indt}
            
            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Vocabulaire}}
                Soit $(A,\ <)$ un arbre non vide.
                
                $-$ Les éléments de $A$ sont appelés \textit{n\oe uds} ;
                
                $-$ $r_A$ est appelé la \textit{racine} de $A$ ;
                
                $-$ $\forall x, y \in A \ |\ x < y$, $y$ est \underline{le} \textit{père} de $x$ et $x$ est \underline{un} \textit{fils} de $y$ ;
                
                $-$ Une \textit{feuille} est un n\oe ud sans fils. On parle aussi de n\oe ud externe ;
                
                $-$ Un n\oe ud qui n'est pas une feuille est dit \textit{interne} ;
                
                $-$ L'\textit{arité} d'un n\oe ud est le nombre de ses fils ;
                
                \begin{indt}{$-$ Profondeur d'un n\oe ud :}
                    $*$ La profondeur de $r_A$ est 0 ;
                    
                    $*$ La profondeur de $x \neq r_A$ est l'entier $n + 1$ où $n$ est défini au point (3) de la définition \ref{1.1.1}.
                    
                    C'est la longeur du chemin qui mène du n\oe ud à la racine.
                \end{indt}
                
                $-$ Hauteur de $A$ : c'est la profondeur maximale d'un n\oe ud. Par convention, la hauteur de l'arbre vide est $-1$.
                
                \boxed{\rm Exo} Mq c'est aussi la profondeur maximale d'une feuille.
            \end{indt}
            
            \vspace{6pt}
            
            \begin{indt}{\subsubsection{Représentation graphique, exemple}}
                $A = \nset 1 9$ avec $< = \set{(2, 1), (3, 1), (4, 1), (7, 4), (5, 2), (6, 2), (8, 5), (9, 5)}$
                
                \begin{center}
                    \begin{tabular}{cl}
                        \multirow{5}*{
                        \begin{tikzpicture}
                            \node [circle, draw] {1}
                                child {node [circle, draw] {2}
                                    child {node [circle, draw] {5}
                                        child {node [circle, draw] {8}}
                                        child {node [circle, draw] {9}}
                                    }
                                    child {node [circle, draw] {6}}
                                }
                                child {node [circle, draw] {3}}
                                child {node [circle, draw] {4}
                                    child {node [circle, draw] {7}}
                                }
                            ;
                        \end{tikzpicture}
                        }
                        & Racine : 1
                        \\
                        & Feuilles : 8, 9, 6, 3, 7
                        \\
                        & Arité de 1 : 3
                        \\
                        & Profondeur de 5 : 2
                        \\
                        & Hauteur : 3
                    \end{tabular}
                \end{center}
                
            \end{indt}
            
            \vspace{60pt}
            
            \begin{indt}{\subsubsection{Remarque}}
                \label{1.1.5}
                On peut aussi associer des données aux n\oe uds afin d'obtenir une structure de données où l'information est hiérarchisée. On appelle étiquette d'un n\oe ud l'information qui lui est associee.
                
                \vspace{6pt}
                
                Exemple : les tries, ou \textit{arbres préfixes}, qui implémentent la structure de dictionnaire
                
                \begin{center}
                    \begin{tikzpicture}
                        
                        \node [circle, draw] {$\phantom n$}  %[sibling distance = 60pt]
                            child {node [circle, draw, xshift=-30pt] {b}
                                child {node [circle, draw] {ba}
                                    child {node [circle, draw] {bal}}
                                }
                                child {node [circle, draw] {bo}
                                    child {node [circle, draw] {bol}}
                                }
                            }
                            child {node [circle, draw, xshift=30pt] {t}
                                child {node [circle, draw, xshift=-20pt] {ta}
                                    child {node [circle, draw] {tas}}
                                }
                                child {node [circle, draw, xshift=20pt] {ti}
                                    child {node [circle, draw] {tip}
                                        child {node [circle, draw] {tipi}}
                                    }
                                    child {node [circle, draw] {tir}}
                                    child {node [circle, draw] {tic}}
                                }
                            };
                    \end{tikzpicture}
                \end{center}
                
                Autre exemple : les arbres de syntaxe, par exemple les expressions arithmétiques
                
                \begin{center}
                    \begin{tikzpicture}
                        \node [circle, draw] {$+$}
                            child {node [circle, draw, xshift=-20pt] {$\times$}
                                child {node [circle, draw] {$-$}
                                    child {node [circle, draw] {$2$}}
                                }
                                child {node [circle, draw] {$3$}}
                            }
                            child {node [circle, draw, xshift=20pt] {$+$}
                                child {node [circle, draw] {$2$}}
                                child {node [circle, draw] {$4$}}
                            }
                        ;
                    \end{tikzpicture}
                \end{center}
                
                $((-2) \times 3) + (2 + 4)$ (notation infixe)
                
                
                En préfixe (notation polonaise) : $+ \times - 2\ 3 + 2\ 4$
                
                Quand on observe un n\oe ud et tous ces descendants, on retrouve un arbre valide.
            \end{indt}
            
            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Définition (\textit{sous-arbre})}}
                Soit $(A,\ <)$ un arbre et $x \in A$.
                
                On appelle \textit{sous-arbre} de $A$ enraciné en $x$ l'arbre $(A_x,\ < \cap (A_x \times A_x))$ où $A_x$ est le sous ensemble de $A$ constitué de $x$ et de ses descendants.
            \end{indt}
            
            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Remarque}}
                \label{1.1.7}
                Cela donne l'intuition d'une définition inductive des arbres :
                    \[ \dfrac{}{\text{Vide est un arbre}} \quad \text{et} \quad \dfrac{A_1\ \text{est un arbre}\ \ldots\ A_n \ \text{est un arbre}}{\text{N\oe ud} (A_1, \ldots, A_n)\ \text{est un arbre}} \]
                
                Dans ce contexte, une feuille est un n\oe ud dont les sous-arbres sont vides.
                
                On en déduit une implémentation du type des arbres en OCaml :
                
                \begin{lstlisting}[language=Caml, xleftmargin=80pt]
type arbre =
    | Vide
    | Noeud of arbre list\end{lstlisting}
                
                Ou avec des étiquettes :
                
                \begin{lstlisting}[language=Caml, xleftmargin=80pt]
type 'a arbre = 
    | Vide
    | Noeud of 'a * ('a arbre list)\end{lstlisting}
                
                En C :
                \begin{lstlisting}[language=C, xleftmargin=80pt]
struct sarbre;
struct sliste;

struct sarbre {
    int val; //tag
    struct sliste* fils;
};

struct sliste {
    struct sabre* noeud;
    struct sliste* suivant;
};

typedef struct sliste* listeAbre;
typedef struct sabre* arbre;\end{lstlisting}
                
                \begin{center}
                    \begin{tikzpicture}[node distance = 150pt]
                        \node {};
                        
                        \node (0) [rectangle, draw] {
                            \begin{tabular}{ccc}
                                \boxed{\phantom a} val
                                \\
                                \boxed{\phantom a} $\rightarrow$ \boxed{\phantom a} $\rightarrow$ \boxed{\phantom a}
                            \end{tabular}

                        };
                        
                        \node (1) [rectangle, draw, below left of = 0] {
                            \begin{tabular}{ccc}
                                \boxed{\phantom a} val
                                \\
                                \boxed{\phantom a} $\rightarrow$ \boxed{\phantom a} $\rightarrow$ \boxed{\phantom a}
                            \end{tabular}

                        };
                        
                        \node (2) [rectangle, draw, below of = 0] {
                            \begin{tabular}{ccc}
                                \boxed{\phantom a} val
                                \\
                                \boxed{\phantom a} $\rightarrow$ \boxed{\phantom a} $\rightarrow$ \boxed{\phantom a}
                            \end{tabular}

                        };
                        
                        \node (3) [rectangle, draw, below right of = 0] {
                            \begin{tabular}{ccc}
                                \boxed{\phantom a} val
                                \\
                                \boxed{\phantom a} $\rightarrow$ \boxed{\phantom a} $\rightarrow$ \boxed{\phantom a}
                            \end{tabular}

                        };
                        
                        \node (4) [rectangle, draw, below left of = 2] {...};
                        
                        \node (5) [rectangle, draw, below right of = 2] {...};
                        
                        \draw[->] (0) -- (1);
                        \draw[->] (0) -- (2);
                        \draw[->] (0) -- (3);
                        
                        \draw[->] (2) -- (4);
                        \draw[->] (2) -- (5);
                    \end{tikzpicture}
                \end{center}
            \end{indt}
            
            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Définition (\textit{arbre binaire})}}
                Un \textit{arbre binaire} est un arbre dont tous les n\oe uds sont d'arité au plus 2.
                
                Un arbre binaire est dit strict si tous les n\oe uds internes sont d'arité 2.
            \end{indt}
            
            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Exemple}}
                L'arbre de syntaxe \ref{1.1.5} est binaire mais pas strict. Si on remplace $-2$ par $0 - 2$, il devient strict.
            \end{indt}
            
            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Proposition}}
                \label{1.1.10}
                
                Soit $A$ un arbre binaire dont on note $n$ le nombre de n\oe uds internes.
                
                \begin{indt}{Alors :}
                    (1) $A$ a au plus $n + 1$ feuilles ;
                    
                    (2) Si $A$ est strict, alors $A$ a exactement $n + 1$ feuilles ;
                    
                    (3) Si $A$ est de hauteur $h$, alors $A$ a au plus $2^h$ feuilles ;
                    
                    (4) Si $A$ a $k$ feuilles, alors $A$ est de hauteur au moins $\left\lceil \log_2 (k) \right\rceil$
                \end{indt}
                
                \vspace{12pt}
                
                $\square$ Démonstration :
                
                (1) et (2) : par récurrence sur $n$.
                
                (3) par induction structurelle sur $A$
                
                (4) corollaire de (3)
                
                $\blacksquare$
            \end{indt}
            
            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Implémentation}}
                \label{1.1.11}
                On remplace la liste des fils par un fils gauche et un fils droit.
                
                OCaml :
                \begin{lstlisting}[language=Caml, xleftmargin=80pt]
type 'a bin_tree =
    | Empty
    | Node of 'a * 'a bin_tree * 'a bin_tree\end{lstlisting}
                
                En interdisant l'arbre vide, on obtient un type pour les arbres binaires stricts non vides :
                
                \begin{lstlisting}[language=Caml, xleftmargin=80pt]
type 'a strict_bin_tree =
    | Leaf of 'a
    | Node of 'a * 'a strict_bin_tree * 'a strict_bin_tree
                \end{lstlisting}
                
                \vspace{6pt}
                
                C :
                \begin{lstlisting}[language=C, xleftmargin=80pt]
struct noeud {
    int val;
    struct noeud* gauche;
    struct noeud* droite;
};

typedef struct noeud* arbre_binaire;
                \end{lstlisting}
            \end{indt}
            
            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Conversion en arbre binaire}}
                \begin{indt}{On utilise la représentation ``\textit{fils gauche-frère droit}'', où l'arbre binaire comporte autant de n\oe uds, avec les mêmes étiquettes que l'arbre original et est organisté comme suit :}
                    $-$ Le fils gauche d'un n\oe ud $N$, est le \simplecit{premier} fils de $N$ dans l'arbre initial (vide s'il n'a pas de fils) ;
                    
                    $-$ le fils droit d'un n\oe ud $N$ est le \simplecit{frère suivant} de $N$ dans l'arbre initial, c'est-à-dire un n\oe ud de même père qui n'a pas encore été inséré dans l'arbre binaire (vide s'il n'y a pas d'autre frère).
                \end{indt}
                
                \vspace{12pt}
                
                Exemple :
                
                \begin{center}
                    \begin{tikzpicture}
                        \node [circle, draw] {a}
                            child {node [circle, draw] {b}
                                child {node [circle, draw] {f}
                                    child {node [circle, draw] {k}}
                                    child {node [circle, draw] {l}}
                                    child {node [circle, draw] {m}}
                                }
                                child {node [circle, draw] {g}}
                            }
                            child {node [circle, draw] {c}}
                            child {node [circle, draw] {d}
                                child {node [circle, draw] {h}}
                                child {node [circle, draw] {i}
                                    child {node [circle, draw] {n}}
                                }
                            }
                            child {node [circle, draw, xshift=10pt] {e}
                                child {node [circle, draw] {j}}
                            }
                        ;
                    \end{tikzpicture}
                \end{center}
                
                donne :
                
                \begin{center}
                    \begin{tikzpicture}
                        \node [circle, draw] {a}
                            child {node [circle, draw, xshift=-50pt] {b}
                                child {node [circle, draw, xshift=-40pt] {f}
                                    child {node [circle, draw, xshift=-20pt] {k}
                                        child {node [circle, draw, xshift=20pt] {l}
                                            child {node [circle, draw, xshift=10pt] {m}}
                                        }
                                    }
                                    child {node [circle, draw] {g}}
                                }
                                child {node [circle, draw, xshift=40pt] {c}
                                    child {node [circle, draw, xshift=40pt] {d}
                                        child {node [circle, draw, xshift=-20pt] {h}
                                            child {node [circle, draw, xshift=20pt] {i}
                                                child {node [circle, draw, xshift=-20pt] {n}}
                                            }
                                        }
                                        child {node [circle, draw, xshift=20pt] {e}
                                            child {node [circle, draw, xshift=-20pt] {j}}
                                        }
                                    }
                                }
                            }
                        ;
                    \end{tikzpicture}
                \end{center}
                
                \vspace{12pt}
                
                Nombre de n\oe uds \texttt{\#noeuds} d'un arbre d'arité quelconque :
                \begin{lstlisting}[language=Caml, xleftmargin=80pt]
let rec nb_noeuds (t : arbre) : int =
    match t with
    | Vide -> 0
    | Noeud l -> List.fold_left (fun a t' -> a + nb_noeuds t') 1 l\end{lstlisting}
                
                \texttt{List.fold\_left : ('a -> 'b - > 'a) -> 'a -> 'b list -> 'a}
                
                \texttt{List.fold\_left  f a [$x_1 \ldots x_n$] = f( ... f(f(a, $x_1$), $x_2$), ..., $x_n$)}
            \end{indt}
        \end{indt}
        
        \vspace{12pt}
        
        \begin{indt}{\subsection{Parcours d'arbres}}
            \begin{indt}{\subsubsection{Introduction}}
                \label{1.2.1}
                On est souvent amené à parcourir l'ensemble des n\oe uds d'un arbre, par exemple pour vérifier la présence d'une étiquette ou bien pour appliquer une fonction à chaque étiquette.
                
                Par exemple, lorsqu'on étudie une fonction récursive, l'ensemble des appels récursifs est hiérarchisée selon une structure arborescente, où la racine est l'appel de fonction initial et les fils d'un n\oe ud, \textit{i.e} d'un appel de la fonction, sont les appels récursifs réalisés lors de cet appel.
                
                Exemple : la fonction d'Ackermann :
                
                \begin{lstlisting}[language=C, xleftmargin=80pt]
int ack(int n, int m) {
    if (n == 0)
        return m + 1;
    if (m == 0)
        return ack(n - 1, 1);
    return ack(n - 1, ack(n, m - 1));
}\end{lstlisting}
                
                \texttt{ack(1, 2)} :
                
                \begin{center}
                    \begin{tikzpicture}
                        \node [circle, draw] {1, 2}
                            child {node [circle, draw] {1, 1}
                                child {node [circle, draw] {1, 0}
                                    child {node [circle, draw] {0, 1}}
                                }
                                child {node [circle, draw] {0, 2}}
                            }
                            child {node [circle, draw] {0, 3}}
                        ;
                    \end{tikzpicture}
                \end{center}
                
                L'ordre d'exécution des appels récursifs correspond à l'ordre d'empilement des blocs d'activation de la fonction sur la pile d'exécution.
                Cet ordre d'empilement correspond à un parcours des n\oe uds de l'arbre des appels récursifs dans un arbre bien précis, appelé \textit{parcours en profondeur}.
            \end{indt}
            
            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Parcours en profondeur}}
                Dans un parcours en profondeur, ou DFS (\textit{Deep First Search}), on parcours intégralement le sous-arbre enraciné en un fils d'un n\oe ud avant de passer au fils suivant.
                
                \vspace{6pt}
                
                Rq : cela correspond à l'enchaînement des appels récursifs, puisqu'il faut attendre la fin d'un appel avant de passer au suivant.
                
                \begin{indt}{Le moment où l'on applique une fonction à la racine d'un sous-arbre définit le type de parcours en profondeur qui est réalisé :}
                    $-$ Si on applique la fonction au n\oe ud avant de parcourir ses fils, on parle de parcours \textit{préfixe} ;
                    
                    $-$ Si on applique la fonction au n\oe ud après le parcours de ses fils, on parle de parcours \textit{postfixe}.
                \end{indt}
                
                \vspace{6pt}
                
                \begin{indt}{Exemple avec l'arbre des appels récursif de \texttt{ack(1, 2)} (\ref{1.2.1}):}
                    $-$ Préfixe : (1, 2), (1, 1), (1, 0), (0, 1), (0, 2), (0, 3)
                    
                    $-$ Postfixe : (0, 1), (1, 0), (0, 2), (1, 1), (0, 3), (1, 2)
                \end{indt}
                
                \vspace{12pt}
                
                Code en C pour afficher les étiquettes (entières) d'un arbre dont les fils sont donné dans une liste (\textit{cf} \ref{1.1.7} pour la structure) :
                
                \begin{lstlisting}[language=C, xleftmargin=80pt]
void dfs(arbre t) {
    if (t != NULL) {
        printf("%d\n", t->val); //Parcours prefixe
        listeArbre l = t->fils;
        
        while (l != NULL) {
            dfs(l->noeud);
            l = l->suivant;
        }
        
        //printf ici pour le parcours postfixe.
    }
}\end{lstlisting}
                
                \vspace{6pt}
                
                Rq : les parcours préfixes et postfixe de l'arbre représentant une expression arithmétique donnent respectivement les représentations polonaise et polonaise inverse de l'expression (\textit{cf} TD$_{17}$)
                
                Dans le cas des arbres binaires (stricts), on distingue un troisième type de parcours en profondeur, le parcours \textit{infixe}, où l'on traite l'étiquette d'un n\oe ud entre les parcours de ses fils gauche et droite (le parcours infixe d'un arbre binaire représantant une expression arithmétique donne la représentation infixe).
                
                Code en C (\textit{cf} \ref{1.1.11} pour le type) :
                
                \begin{lstlisting}[language=C, xleftmargin=80pt]
void infix_dfs(arbre_binaire t) {
    if (t != NULL) {
        infix_dfs(t->gauche);
        printf("%d\n", t->val);
        infix_dfs(t->droite);
    }
}\end{lstlisting}
            \end{indt}
            
            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Parcours en largeur}}
                Dans un parcours en largeur, ou BFS (\textit{Breadth First Search}), on traite tous les n\oe uds à une même profondeur avant de passer à la profondeur suivante.
                
                \vspace{6pt}
                
                Exemple :
                
                \begin{center}
                    \begin{tikzpicture}
                        \node [circle, draw] {1}
                            child {node [circle, draw, xshift=-15pt] {2}
                                child {node [circle, draw] {5}}
                                child {node [circle, draw] {6}}
                            }
                            child {node [circle, draw] {3}}
                            child {node [circle, draw, xshift=15pt] {4}
                                child {node [circle, draw] {7}
                                    child {node [circle, draw] {10}}
                                }
                                child {node [circle, draw] {8}}
                                child {node [circle, draw] {9}}
                            }
                        ;
                    \end{tikzpicture}
                \end{center}
                \vspace{6pt}
                
                Comment implémenter un tel parcours efficacement ?
                
                On ne veut pas avoir à remonter jusqu'à la racine pour passer d'un n\oe ud à un autre de même profondeur.
                
                \vspace{6pt}
                
                Idée : on conserve un ensemble de sommets en attente d'être traités. On commence par la racine et quand on traite un n\oe ud, on ajoute ses fils à l'ensemble des sommets en attente. Cela fonctionne si on peut extraire un n\oe ud de profondeur minimale de cet ensemble. On peut utiliser pour cela une structure appelée \textit{file de priorité}, où la priorité d'un n\oe ud est sa profondeur. Dans ce cas particulier, on n'a pas besoin des files de priorité dans leur généralité, mais seulement d'une file.
                
                \vspace{6pt}
                
                Code en OCaml (\textit{cf} \ref{1.1.7} pour le type) :
                
                \begin{lstlisting}[language=Caml, xleftmargin=80pt]
let bfs (t : int arbre) : unit =
    let f = Queue.create() in
    Queue.add t f;
    
    while not (Queue.is_empty f) do
        match Queue.take f with
        | Vide -> ()
        | Noeud(n, l) ->
            print_int n;
            List.iter (fun t -> Queue.add t f) l
    done\end{lstlisting}
                
                \vspace{12pt}
                
                Correction : on doit montrer que les n\oe uds sont traités par ordre croissant de profondeur.
                
                On note $p(n)$ la profondeur du n\oe ud $n$ et on montre l'invariant $I(f) = \text{\guillemotleft}\text{si $f$ s'écrit}\ n_1, \ldots, n_k$ $\text{(où $n_1$ est le premier n\oe ud qui sera extrait) alors}\ p(n_1) \le p(n_2) \le \cdots \le p(n_k) \le p(n_1) + 1\text{\guillemotright}$
                
                \vspace{6pt}
                
                $\bullet$ Avant d'entrer dans la boucle, $f$ ne contient que la racine $t$ et $p(t) \le p(t) + 1$
                
                \begin{indt}{$\bullet$ Si $I(f)$ est vrai au début d'une itération : comme $f$ est non vide, $f$ s'écrit $n_1, \ldots, n_k$ avec $k \ge 1$.}
                    
                    On extrait donc $n_1$
                    
                    $-$ Si $n_1 = \mathtt{Vide}$, à la fin de l'itération (si $k \neq 1$ (cas $k = 1$ trivial)) $f$ s'écrit $n_2, \ldots, n_k$ et $p(n_2) \le p(n_3) \le \cdots \le p(n_k) \le p(n_1) + 1 \le p(n_2) + 1$ car $p(n_1) \le p(n_2)$.
                    
                    %\vspace{6pt}
                    \newpage
                    
                    $-$ Si $n_1$ est un n\oe ud de fils $n_{k + 1}, \ldots, n_{k + l}$, à la fin de l'itération $f$ s'écrit
                    \newline
                    $n_2, \ldots, n_k, n_{k + 1}, \ldots, n_{k + l}$
                    
                    et $p(n_2) \le p(n_3) \le \cdots \le p(n_k) \le p(n_1) + 1 = p(n_{k + 1}) = \cdots = p(n_{k + l}) \le p(n_{k + 1}) + 1$
                    
                    donc les n\oe uds sont traités par ordre croissant de profondeur.
                \end{indt}
                
                \vspace{12pt}
                
                $\bullet$ Et si on avait utilisé une pile ?
                On retrouve un parcours en profondeur.
                
                \vspace{12pt}
                
                \begin{indt}{$\square$ Démonstation :}
                    On démontre par induction structurelle sur $n$ que si le n\oe ud $n$ est extrait de la pile, alors la suite de l'algorithme réalise un parcours en profondeur du sous-arbre enraciné en $n$ et laisse la pile dans le même état que juste après l'extraction de $n$.
                    
                    \vspace{6pt}
                    
                    $-$ Si $n = \mathtt{Vide}$ : pas de problème.
                    
                    $-$ Si $n$ est un n\oe ud de fils $n_1, \ldots, n_k$ et $p$ est la pile après l'extraction de $n$, la pile s'écrit $n_k, n_{k - 1}, \ldots, n_1, p$ après insertion des fils.
                    Ensuite, $n_k$ est extrait par hypothèse d'induction on réalise un parcours en profondeur du sous-arbre enraciné en $n_k$, qui laisse la pile dans l'état $n_{k - 1}, n_{k - 2}, \ldots, n_1, p$
                    
                    De même pour $n_{k - 1}, \ldots, n_1$ (récurrence finie sur $k$) on a bien réalisé un parcours en profondeur du sous-arbre enraciné en $n$ qui laisse la pile dans l'état $\uparrow$. $\blacksquare$
                \end{indt}
                
                \vspace{12pt}
                
                Rq : dans le cas des arbres binaires, on préfère insérer d'abord le fils droit, puis le fils gauche pour les parcourir dans le bon ordre.
                
                \begin{lstlisting}[language=Caml, xleftmargin=80pt]
let dfs (t : 'a bin_tree) : unit =
    let p = Stack.create() in
    Stack.push t p;
    
    while not (Stack.is_empty p) do
        match Stack.pop p with
        | Empty -> ()
        | Node(_, l, r) ->
            Stack.push r p;
            Stack.push l p
    done\end{lstlisting}
            \end{indt}
            
            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Complexité des parcours}}
                Chaque n\oe ud est parcouru une seule fois donc on a une complexité en
                    \[ \mathcal O(n \times \text{complexité du traitement appliqué au n\oe ud}) \]
                Dans le cas où ce traitement est de complexité constante on obtient un parcours en temps linéaire.
            \end{indt}
        \end{indt}
        
    \end{indt}
    
    \vspace{12pt}
    
    \begin{indt}{\section{Arbres binaires de recherche (ABR)}}
        
        \begin{indt}{\subsection{Définition et opérations}}
            \begin{indt}{\subsubsection{Définition ABR}}
                Soit $(E,\ \le)$ un ensemble totalement ordonné.
                
                Un ABR étiqueté par des éléments de $E$ est tel que pour tout n\oe ud, l'étiquette de ce n\oe ud est supérieure à toutes celles de son sous-arbre gauche et inférieure à toutes celles de son sous-arbre droit.
            \end{indt}
            
            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Exemple}}
                \begin{center}
                    \begin{tikzpicture}
                        \node [circle, draw] {9}
                            child {node [circle, draw, xshift=-30pt] {5}
                                child {node [circle, draw, xshift=-15pt] {3}
                                    child {node [circle, draw] {1}}
                                    child {node [circle, draw] {4}}
                                }
                                child {node [circle, draw, xshift=15pt] {8}
                                    child {node [circle, draw, xshift=-20pt] {7}}
                                }
                            }
                            child {node [circle, draw, xshift=30pt] {13}
                                child {node [circle, draw, xshift=-10pt] {10}}
                                child {node [circle, draw, xshift=10pt] {15}
                                    child {node [circle, draw, xshift=20pt] {17}}
                                }
                            }
                        ;
                    \end{tikzpicture}
                \end{center}
            \end{indt}
            
            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Proposition}}
                Soit $(E,\ \le)$ un ensemble totalement ordonné et $A$ un arbre binaire étiqueté par des éléments de $E$.
                
                $A$ est ABR $\ssi$ le parcours en profondeur infixe de $A$ est croissant.
                
                \vspace{12pt}
                
                \begin{indt}{$\square$ Démonstration (par induction structurelle sur $A$) :}
                    $-$ Si $A$ est vide : trivial
                    
                    $-$ Si $A$ est un n\oe ud d'étiquette $x$ et de sous-arbre gauche et droit $g$ et $d$
                    
                    \vspace{6pt}
                    
                    $\Rightarrow$ le parcours infixe de $A$ s'écrit $P_g\ x\ P_d$ où $P_g$ et $P_d$ sont les parcours infixes de $g$ et $d$.
                    
                    $g$ et $d$ sont des ABR (par restriction de la quantification universelle) donc d'après l'hypothèse d'induction $P_g$ et $P_d$ sont croissants.
                    
                    Or $\max P_g \le x \le \min P_d$, donc $P_g\ x\ P_d$ croissant.
                    
                    \vspace{6pt}
                    
                    $\Leftarrow$ Le parcours $P_g\ x\ P_d$ est croissant.
                    
                    Donc $P_g$ et $P_d$ sont croissants et par hypothèse d'induction, $g$ et $d$ sont des ABR.
                    
                    Pour montrer que $A$ est un ABR, il suffit donc de remarquer que $\max P_g \le x \le \min P_d$ (vrai par croissance de $P_g\ x\ P_d$) $\blacksquare$
                \end{indt}
            \end{indt}
            
            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Remarque}}
                $-$ La définition donne l'intuition d'une définition inductive des ABR :
                    \[
                        \dfrac{}{\text{Vide est un ABR}}
                        \qquad
                        \dfrac{}{\text{N\oe ud}(x, \text{Vide}, \text{Vide})\ \text{est un ABR}}
                    \]
                    \[
                        \dfrac{g\ \text{est un ABR} \quad \max g \le x}{\text{N\oe ud}(x, g, \text{Vide})\ \text{est un ABR}}
                        \qquad
                        \dfrac{d\ \text{est un ABR} \quad x \le \min d}{\text{N\oe ud}(x, \text{Vide}, d)\ \text{est un ABR}}
                    \]
                    
                    \[
                        \dfrac{g\ \text{est un ABR} \quad d \ \text{est un ABR} \quad \max g \le x \le \min d}{\text{N\oe ud}(x, g, d)\ \text{est un ABR}}
                    \]
                
                \vspace{12pt}
                
                $-$ On peut trier des données en parcourant un ABR qui les contient.
            \end{indt}
            
            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Calcul du minimum / maximum des étiquettes d'un ABR}}
                Il suffit de descendre dans le n\oe ud le plus à gauche / droite de l'arbre.
                
                \vspace{12pt}
                
                \begin{indt}{$\square$ Par induction structurelle : pour le minimum (cas du maximum symétrique)}
                    $-$ Vide : cas non considéré.
                    
                    \begin{indt}{$-$ N\oe ud$(x, g, d)$ : 2 cas}
                        $\bullet$ $g$ est vide : on est dans le n\oe ud le plus à gauche et $x$ est inférieur à toutes les étiquettes de $d$ donc est le minimum ;
                        
                        $\bullet$ $g$ est non vide : le minimum est dans $g$, dans le n\oe ud le plus à gauche de $g$ par hypothèse d'induction.
                        
                        Ce n\oe ud est bien le n\oe ud le plus à gauche de l'arbre $\blacksquare$
                    \end{indt}
                \end{indt}
                
                \vspace{12pt}
                
                \boxed{\rm Exo} Code.
                
                \vspace{12pt}
                
                Complexité : $\mathcal O(h)$ (à chaque étape, on incrémente la profondeur du n\oe ud considéré)
                
                Donc $\mathcal O(n)$ dans le pire cas
                
                \begin{center}
                    \begin{tikzpicture}
                        \node [circle, draw] {1}
                            child {node [circle, draw, xshift=40pt] {2}
                                child {node [circle, draw, xshift=40pt] {3}
                                    child {node [xshift=40pt] {} edge from parent [dashed]}
                                }
                            }
                        ;
                    \end{tikzpicture}
                \end{center}
            \end{indt}
            
            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Remarque}}
                On peut utiliser les ABR pour implémenter la structure de tableau associatif : on stocke les couples (clé, valeur) ordonnés selon les clés $\rightarrow$ ne fonctionne que si l'ensemble des clés est totalement ordonné.
            \end{indt}
            
            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Recherche d'étiquette}}
                On procède récursivement en comparant l'étiquette recherchée à celle du n\oe ud considéré.
                
                Si elle est inférieure (resp. supérieure) on fait un appel récursif sur le sous-arbre gauche (resp. droit).
                
                Cas de base : arbre vide et cas d'égalité.
                
                Code :
                
                \begin{lstlisting}[language=Caml, xleftmargin=80pt]
let rec mem (x : 'a) (t : 'a bin_tree) : bool =
    match t with
    | Empty -> false
    | Node (y, _, _) when y = x -> true
    | Node (y, g, _) when y > x -> mem x g
    | Node (_, _, d) -> mem x d\end{lstlisting}
                
                Complexité : $\mathcal O(h)$
                
                \boxed{\rm Exo} : preuve de correction.
            \end{indt}
            
            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Ajout d'une étiquette}}
                Idée : on descend dans l'arbre comme pour la recherche et lorsqu'on atteint un n\oe ud \texttt{Vide}, on crée un n\oe ud avec la nouvelle étiquette.
                
                En cas d'égalité avec une étiquette, on peut laisser l'arbre inchangé, lever une exception, insérer à gauche ou à droite de manière déterministe ou aléatoire.
                
                \vspace{6pt}
                
                Code :
                
                \begin{lstlisting}[language=C, xleftmargin=80pt]
arbre_binaire new_node(int x) {
    arbre_binaire t = (arbre_binaire) malloc(sizeof(struct noeud));
    t->val = x;
    t->gauche = NULL;
    t->droite = NULL;
    return t;
}

void add(int x, arbre_binaire* t) {
    if (*t == NULL)
        *t = new_node(x);
    else if (x <= (*t)->val) {
        add(x, &((*t)->gauche));
    }
    else //x > (*t)->val
        add(x, &((*t)->droite));
}\end{lstlisting}
                
                Complexité : $\mathcal O(h)$
                
                \boxed{\rm Exo} : correction.
            \end{indt}
            
            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Tri à l'aide d'un ABR}}
                On construit un ABR contentant les valeurs à trier par insertion successives et on réalise un parcours en profondeur infixe de l'ABR.
                
                Code :
                
                \begin{lstlisting}[language=Caml, xleftmargin=80pt]
let rec abr_of_list (l : 'a list) : 'a bin_tree =
    match l with
    | [] -> Empty
    | t::q -> add t (abr_of_list q)
(*si add : 'a -> a' bin_tree -> 'a bin_tree*)

let abr_sort (l : 'a list) : 'a list = infix_dfs (abr_of_list l)
(*si infix_dfs : 'a bin_tree -> 'a list (Exo)*)\end{lstlisting}
                
                Complexité : $\mathcal O(n^2)$ dans le pire cas à cause du peigne :
                \texttt{l = [1 ; 2 ; 3 ; 4]}
                donne :
                
                \begin{center}
                    \begin{tikzpicture}
                        \node [circle, draw] {4}
                            child {node [circle, draw, xshift=-40pt] {3}
                                child {node [circle, draw, xshift=-40pt] {2}
                                    child {node [circle, draw, xshift=-40pt] {1}}
                                }
                            }
                        ;
                    \end{tikzpicture}
                \end{center}
                
                Remarque : d'après \ref{1.1.10}, le mieux qu'on puisse espérer est une hauteur en $\mathcal O(\log_2(n))$, donc une complexité en $\mathcal O(n\log_2(n))$ pour le tri.
                
                Pour atteindre cette complexité, on peut rééquilibrer l'arbre en cours de construction, par exemple en utilisant une structure adaptée type arbre tricolore (\textit{cf} \ref{2.2})
            \end{indt}
            
            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Supression d'une étiquette}}
                \label{2.1.10}
                
                $\bullet$ Première idée : on remplace l'étiquette du n\oe ud supprimé par le maximum du sous-arbre gauche.
                
                Code :
                
                \begin{lstlisting}[language=Caml, xleftmargin=80pt]
let rec take_max (t : 'a bin_tree) : 'a * 'a bin_tree =
    match t with
    | Empty -> failwith "Empty tree"
    | Node(x, l, Empty) -> (x, l)
    | Node (x, l, r) ->
        let (y, r') = take_max r in
        (y, Noeud(x, l, r'));;
let rec del (x : 'a) (t : 'a bin_tree) : 'a bin_tree =
    match t with
    | Empty -> Empty
    | Node(y, l, r) when x < y -> Node(y, del x l, r)
    | Node(y, l, r) when y < x -> Node(y, l, del x r)
    | Node(_, l, r) ->
        match l with
        | Empty -> r
        | _ -> let (y, l') = take_max l in Node(y, l', r)\end{lstlisting}
                
                Complexité : $\mathcal O(h)$ pour \texttt{take\_max}, et $\mathcal O(h)$ pour \texttt{del}.
                
                \vspace{12pt}
                
                $\bullet$ Seconde idée : on fusionne les sous-arbres du n\oe ud supprimé.
                
                \begin{center}
                    \begin{tikzpicture}
                        \node [circle, draw] {$x$}
                            child {node [circle, draw] {$y$}
                                child {node [isosceles triangle, shape border rotate=90, inner sep=1, draw] {$l_y$}}
                                child {node [isosceles triangle, shape border rotate=90, inner sep=1, draw] {$r_y$}}
                            }
                            child {node [isosceles triangle, shape border rotate=90, inner sep=1, draw] {$r_x$}}
                        ;
                    \end{tikzpicture}
                \end{center}
                
                Donne
                
                \begin{center}
                    \begin{tikzpicture}
                        \node [circle, draw] {$y$}
                            child {node [isosceles triangle, shape border rotate=90, inner sep=1, draw, xshift=-20pt] {$l_y$}}
                            child {node [xshift=20pt] {fusion \fbox{$r_y$} \fbox{$r_x$}}}
                        ;
                    \end{tikzpicture}
                \end{center}
                
                Code :
                
                \begin{lstlisting}[language=Caml, xleftmargin=80pt]
let rec merge (l : 'a bin_tree) (r : 'a bin_tree) : 'a bin_tree =
    (*precondition : etiquettes de l inferieures a celles de r*)
    match l with
    | Empty -> r
    | Node(y, ly, r_y) -> Node(y, ly, merge ry r)

let rec del (x : 'a) (t : 'a bin_tree) : 'a bin_tree =
    match t with
    | Empty -> Empty
    | Node(y, l, r) when x < y -> Node(y, del x l, r)
    | Node(y, l, r) when y < x -> Node(y, l, del x r)
    | Node(_, l, r) -> merge l r
                \end{lstlisting}
                
                Complexité de \texttt{merge} : $\mathcal O(h)$
                
                Complexité de \texttt{del} : $\mathcal O(h)$
                
                %\boxed{\rm Exo} : fonction \texttt{del} à partir de \texttt{merge}
            \end{indt}
        \end{indt}
        
        \begin{indt}{\subsection{Arbres bicolores}}
            \label{2.2}
            
            \begin{indt}{\subsubsection{Introduction}}
                Pour garantir une hauteur logarithmique pour les ABR (afin d'obtenir une complexité optimale pour les opérations sur les ABR), on ajoute des couleurs sur avec des n\oe uds et on impose des contraintes sur le choix des couleurs qui vont garantir l'équilibre de l'arbre. Comme on utilise seulement deux couleurs, le surcoût en espace est faible : un bit d'information supplémentaire par n\oe ud.
            \end{indt}
            
            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Définition (\textit{arbre bicolore})}}
                \label{2.2.2}
                \begin{indt}{Un \textit{arbre bicolore} (ou \textit{arbre rougre-noir}), est un ABR auquel on a ajouté des feuilles vides pour le rendre binaire strict (les feuilles de l'ABR deviennent des n\oe uds internes ayant deux feuilles vides comme filles) et tel que chaque n\oe ud est coloré, soit en rouge, soit en noir, et en respectant les contraintes suivantes :}
                    (1) Toutes les feuilles sont noires ;
                    
                    (2) La racine est noire ;
                    
                    (3) Les fils d'un n\oe ud rouge sont noirs ;
                    
                    (4) Tous les chemins de la racine vers les feuilles ont le même nombre de n\oe uds noirs.
                \end{indt}
            \end{indt}
            
            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Exemple}}
                \begin{center}
                    \begin{tikzpicture}
                        \node [circle, draw] {22}
                            child {node [circle, draw, xshift=-30pt, color=red] {13}
                                child {node [circle, draw, xshift=-20pt] {11}
                                    child {node [circle, fill] {}}%{$\blacksquare$}}
                                    child {node [circle, fill] {}}
                                }
                                child {node [circle, draw, xshift=20pt] {18}
                                    child {node [circle, draw, color=red] {16}
                                        child {node [circle, fill] {}}
                                        child {node [circle, fill] {}}
                                    }
                                    child {node [circle, fill] {}}
                                }
                            }
                            child {node [circle, draw, xshift=30pt] {28}
                                child {node [circle, fill] {}}
                                child {node [circle, draw, color=red] {31}
                                    child {node [circle, fill] {}}
                                    child {node [circle, fill] {}}
                                }
                            }
                        ;
                    \end{tikzpicture}
                \end{center}
            \end{indt}
            
            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Définition (\textit{hauteur noire})}}
                Soit $A$ un arbre bicolore et $x$ un n\oe ud de $A$.
                
                On appelle \textit{hauteur noire} de $x$ le nombre $h_N(x)$ de n\oe ud noirs sur les chemins du n\oe ud $x$ vers les feuilles du sous-arbre enraciné en $x$.
                
                La hauteur noire $h_N(A)$ de $A$ est la hauteur noire de sa racine.
            \end{indt}
            
            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Proposition}}
                Soit $A$ un arbre bicolore dont on note $n$ le nombre de n\oe uds internes.
                
                Alors la hauteur noire de $A$ est au plus $2\log_2(n + 1)$
                
                \vspace{6pt}
                
                \begin{indt}{$\square$ Démonstration}
                    Lemme : $\forall x$ n\oe ud de $A$, le sous-arbre enraciné en $x$ a au moins $2^{h_N(x)} - 1$ n\oe uds internes.
                    
                    \begin{indt}{$\square$ Démonstration (par induction structurelle) :}
                        $-$ Si $x$ est une feuille, $h_N(x) = 0$ et $2^{h_N(x)} - 1 = 0$ est bien le nombre de n\oe uds internes du sous-arbre enraciné en $x$.
                        
                        $-$ Si $x$ est un n\oe ud interne de fils gauche $g$ et droit $d$, les hauteurs noires de $g$ et de $d$ valent $h_N(x) - 1$ selon la coloration.
                        
                        Donc par hypothèse d'induction, les deux sous-arbres contiennent au moins $2^{h_N(x) - 1} - 1$ n\oe uds internes.
                        
                        Le sous-arbre enraciné en $x$ a donc au moins $2\lr{2^{h_N(x) - 1} - 1} + 1 = 2^{h_N(x)} - 1$ $\blacksquare$
                    \end{indt}
                    
                    \vspace{12pt}
                    
                    Par le point (3) de la définition \ref{2.2.2}, il y a au plus 1 n\oe ud rouge sur 2 sur les chemins de la racine vers les feuilles, donc $h \le 2 h_N(A)$.
                    
                    Or, par le lemme, $n \ge 2^{h_N(A)} - 1 \ge 2^{\frac h 2} - 1$ donc $h \le 2\log_2(n + 1)$ $\blacksquare$
                \end{indt}
            \end{indt}
            
            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Remarque}}
                Cette propriété garantit que les opérations des ABR sont de complexité logarithmique sur les arbres bicolores. Cependant, l'ajout et la suppression de n\oe uds peut enfreindre les règles de coloration. Il faut donc la rétablir, et nous verrons que cela ne change pas la complexité globale.
            \end{indt}
            
            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Implémentation des arbres bicolores}}
                $-$ En OCaml :
                
                \begin{lstlisting}[language=Caml, xleftmargin=80pt]
type color = Red | Black
type 'a tree =
    | Empty
    | Node of color * 'a * 'a tree * 'a tree\end{lstlisting}
                
                \vspace{6pt}
                
                $-$ En C :
                
                \begin{lstlisting}[language=C, xleftmargin=80pt]
struct node {
    int val;
    char color; //'R' or 'B'
    struct node* left;
    struct node* right;
    struct node* father;
};

typedef struct node* tree;\end{lstlisting}
                
                Le pointeur vers le père est utile pour une implémentation impérative des arbres rouges-noirs pour implémenter une opération appelée rotation.
            \end{indt}
            
            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Rotations}}
                Une rotation est une modification locale d'un sous-arbre pour inverser des liens de parenté entre n\oe uds visant à réduire le déséquilibre de hauteur entre les fils gauche et droit, tout en conservant les propriétés des ABR.
                
                \begin{center}
                    \begin{tabular}{ccc}
                        \begin{tikzpicture}
                            \node [circle, draw] {$n_1$}
                                child {node [circle, draw] {$n_2$}
                                    child {node [isosceles triangle, shape border rotate=90, inner sep=1, draw] {$t_1$}}
                                    child {node [isosceles triangle, shape border rotate=90, inner sep=1, draw] {$t_2$}}
                                }
                                child {node [isosceles triangle, shape border rotate=90, inner sep=1, draw] {$t_3$}}
                            ;
                        \end{tikzpicture}
                        &                        
                        \begin{tabular}{c}
                            rotation droite $\longrightarrow$
                            \\
                            $\longleftarrow$ rotation gauche
                        \end{tabular}
                        &
                        \begin{tikzpicture}
                            \node [circle, draw] {$n_2$}
                                child {node [isosceles triangle, shape border rotate=90, inner sep=1, draw] {$t_1$}}
                                child {node [circle, draw] {$n_1$}
                                    child {node [isosceles triangle, shape border rotate=90, inner sep=1, draw] {$t_2$}}
                                    child {node [isosceles triangle, shape border rotate=90, inner sep=1, draw] {$t_3$}}
                                }
                            ;
                        \end{tikzpicture}
                    \end{tabular}
                \end{center}
                
                Code en C :
                
                \begin{lstlisting}[language=C, xleftmargin=80pt]
void right_rotation(tree n1, tree* root) {
    tree n2 = n1->left;
    n1->left = n2->right;
    
    if (n2->right != NULL)
        n2->right->father = n1;
    
    n2->father = n1->father;
    
    if (n2->father == NULL)
        *root = n2;
    else if (n1->father->left == n1)
        n1->father->left = n2;
    else
        n1->father->right = n2;
    
    n2->right = n1;
    n1->father = n2;
}\end{lstlisting}
            \end{indt}
            
            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Insertion d'un n\oe ud}}
                Idée : on procède comme dans les ABR (on descend jusqu'à une feuille qu'on remplace par un nouveau n\oe ud) et on crée un n\oe ud rouge par défaut : cela ne modifie pas la hauteur noire donc le résultat est un arbre bicolore valide sauf si le nouveau n\oe ud est la racine ou si le père de ce nouveau n\oe ud est rouge.
                
                Code :
                
                \newpage
                
                \begin{lstlisting}[language=C, xleftmargin=80pt]
void insert(int m, tree* root) {
    tree f = NULL, n = *root;
    
    while (n != NULL) {
        f = n;
        
        if (m < n->val)
            n = n->left;
        else
            n = n->right;
    }
    n = (tree) malloc(sizeof(struct node));
    n->val = m;
    n->father = f;
    n->left = NULL;
    n->right = NULL;
    n->color = 'R';
    
    if (f == NULL) {
        n->color = 'B';
        *root = n;
        return;
    }
    
    if (m < f->val)
        f->left = n;
    else
        f->right = n;
    
    fix_insert(n, root);
}\end{lstlisting}
                
                \begin{indt}{On distingue 4 cas pour la fonction \texttt{fix\_insert} :}
                    $-$ Le père de $n$ est noir : il n'y a rien à corriger ;
                    
                    $-$ Le père de $n$ est rouge et son oncle est aussi rouge. \`A inversion des fils gauches / droit près, on est dans la situation :
                        \begin{center}
                            \begin{tikzpicture}
                                \node {$\vdots$}
                                    child {node [circle, draw] {$g$} %edge from parent [dashed]
                                        child {node [circle, draw, color=red, xshift=-20pt] {$f$}
                                            child {node [circle, draw] {$n$}
                                                child {node [isosceles triangle, shape border rotate=90, inner sep=1, draw] {$t_1$}}
                                                child {node [isosceles triangle, shape border rotate=90, inner sep=1, draw] {$t_2$}}
                                            }
                                            child {node [isosceles triangle, shape border rotate=90, inner sep=1, draw] {$t_3$}}
                                        }
                                        child {node [circle, draw, color=red, xshift=20pt] {$a$}
                                            child {node [isosceles triangle, shape border rotate=90, inner sep=1, draw] {$t_4$}}
                                            child {node [isosceles triangle, shape border rotate=90, inner sep=1, draw] {$t_5$}}
                                        }
                                }
                                ;
                            \end{tikzpicture}
                            
                            \vspace{12pt}
                        
                            Changement de coloration $\downarrow$
                        
                            \begin{tikzpicture}
                                \node {$\vdots$}
                                    child {node [circle, draw, color=red] {$g$} %edge from parent [dashed]
                                        child {node [circle, draw, xshift=-20pt] {$f$}
                                            child {node [circle, draw, color=red] {$n$}
                                                child {node [isosceles triangle, shape border rotate=90, inner sep=1, draw] {$t_1$}}
                                                child {node [isosceles triangle, shape border rotate=90, inner sep=1, draw] {$t_2$}}
                                            }
                                            child {node [isosceles triangle, shape border rotate=90, inner sep=1, draw] {$t_3$}}
                                        }
                                        child {node [circle, draw, xshift=20pt] {$a$}
                                            child {node [isosceles triangle, shape border rotate=90, inner sep=1, draw] {$t_4$}}
                                            child {node [isosceles triangle, shape border rotate=90, inner sep=1, draw] {$t_5$}}
                                        }
                                    }
                                ;
                            \end{tikzpicture}
                            
                            Puis appel récursif sur $g$.
                        \end{center}
                    
                    \vspace{6pt}
                    
                    $-$ \`A cause d'un appel récursif, on obtient une racine rouge : on la colore en noir.
                    
                    $-$ Le père de $n$ est rouge et son oncle est noir : on effectue si besoin une rotation du père de $n$ pour obtenir le n\oe ud rouge le plus bas comme petit-fils gauche-gauche ou droite-droite de son grand-père :
                    \begin{center}
                        \begin{tikzpicture}
                            \node {$\vdots$}
                                child {node [circle, draw] {$g$}
                                    child {node [circle, draw, color=red, xshift=-20pt] {$p$}
                                        child {node [isosceles triangle, shape border rotate=90, inner sep=1, draw] {$t_1$}}
                                        child {node [circle, draw, color=red] {$n$}
                                            child {node [isosceles triangle, shape border rotate=90, inner sep=1, draw] {$t_2$}}
                                            child {node [isosceles triangle, shape border rotate=90, inner sep=1, draw] {$t_3$}}
                                        }
                                    }
                                    child {node [circle, draw, xshift=20pt] {$u$}
                                        child {node [isosceles triangle, shape border rotate=90, inner sep=1, draw] {$t_4$}}
                                        child {node [isosceles triangle, shape border rotate=90, inner sep=1, draw] {$t_5$}}
                                    }
                                }
                            ;
                        \end{tikzpicture}
                        
                        \vspace{6pt}
                        
                        Rotation gauche de $p$ $\downarrow$
                        
                        \vspace{3pt}
                        
                        \begin{tikzpicture}
                            \node {$\vdots$}
                                child {node [circle, draw] {$g$}
                                    child {node [circle, draw, color=red, xshift=-20pt] {$n$}
                                        child {node [circle, draw, color=red] {$p$}
                                            child {node [isosceles triangle, shape border rotate=90, inner sep=1, draw] {$t_1$}}
                                            child {node [isosceles triangle, shape border rotate=90, inner sep=1, draw] {$t_2$}}
                                        }
                                        child {node [isosceles triangle, shape border rotate=90, inner sep=1, draw] {$t_3$}}
                                    }
                                    child {node [circle, draw, xshift=20pt] {$u$}
                                        child {node [isosceles triangle, shape border rotate=90, inner sep=1, draw] {$t_4$}}
                                        child {node [isosceles triangle, shape border rotate=90, inner sep=1, draw] {$t_5$}}
                                    }
                                }
                            ;
                        \end{tikzpicture}
                    \end{center}
                    
                    On effectue ensuite une rotation grand-père et on rectifie la coloration.
                    
                    Rotation droite de $g$ :
                    
                    \begin{center}
                        \begin{tikzpicture}
                            \node {$\vdots$}
                                child {node [circle, draw, color=red] {$n$}
                                    child {node [circle, draw, color=red, xshift=-20pt] {$p$}
                                        child {node [isosceles triangle, shape border rotate=90, inner sep=1, draw] {$t_1$}}
                                        child {node [isosceles triangle, shape border rotate=90, inner sep=1, draw] {$t_2$}}
                                    }
                                    child {node [circle, draw, xshift=20pt] {$g$}
                                        child {node [isosceles triangle, shape border rotate=90, inner sep=1, draw] {$t_3$}}
                                        child {node [circle, draw] {$u$}
                                            child {node [isosceles triangle, shape border rotate=90, inner sep=1, draw] {$t_4$}}
                                            child {node [isosceles triangle, shape border rotate=90, inner sep=1, draw] {$t_5$}}
                                        }
                                    }
                                }
                            ;
                        \end{tikzpicture}
                    \end{center}
                    
                    Correction de coloration car $h_N(g) = h_N(p) + 1$ :
                    
                    \begin{center}
                        \begin{tikzpicture}
                            \node {$\vdots$}
                                child {node [circle, draw] {$n$}
                                    child {node [circle, draw, color=red, xshift=-20pt] {$p$}
                                        child {node [isosceles triangle, shape border rotate=90, inner sep=1, draw] {$t_1$}}
                                        child {node [isosceles triangle, shape border rotate=90, inner sep=1, draw] {$t_2$}}
                                    }
                                    child {node [circle, draw, color=red, xshift=20pt] {$g$}
                                        child {node [isosceles triangle, shape border rotate=90, inner sep=1, draw] {$t_3$}}
                                        child {node [circle, draw] {$u$}
                                            child {node [isosceles triangle, shape border rotate=90, inner sep=1, draw] {$t_4$}}
                                            child {node [isosceles triangle, shape border rotate=90, inner sep=1, draw] {$t_5$}}
                                        }
                                    }
                                }
                            ;
                        \end{tikzpicture}
                    \end{center}
                    
                    pas d'appels récursifs.
                \end{indt}
                
                \vspace{12pt}
                
                Remarque : comme les appels récursifs éventuels font diminuer la profondeur de 2 unités, il y en a au plus $\dfrac h 2$.
                
                \vspace{12pt}
                
                Donc la complexité de l'ajout de n\oe ud reste logarithmique.
                
                \vspace{12pt}
                
                %Code en C :
                \newpage
                
                \begin{lstlisting}[language=C, xleftmargin=80pt]
void fix_insert(tree n, tree* root) {
    if (n->father == NULL) {
        n->color = 'B';
        return;
    }
    
    if (n->father->color == 'B')
        return;
    
    if (uncle(n)->color == 'R') { //Exo : uncle implementation
        n->father->color = 'B';
        uncle(n)->color = 'B';
        n->father->father->color = 'R';
        fix_insert(n->father->father, root);
    }
    else {
        tree p = n->father, g = n->father->father;
        
        if (n == g->left->right) {
            left_rotation(p, root);
            swap(&n, &p); //Exo : swap implementation
        }
        else if (n == g->right->left) {
            right_rotation(p, root);
            swap(&n, &p);
        }
        
        if (n == p->left)
            right_rotation(g, root);
        else
            left_rotation(g, root);
        
        p->color = 'B';
        g->color = 'R';
    }
}
                \end{lstlisting}
            \end{indt}
            
            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Supression d'un n\oe ud}}
                On ramène l'étude de la supression d'un n\oe ud à celle de l'extraction du maximum grâce à la première idée de \ref{2.1.10}.
                
                Le maximum est situé dans le n\oe ud interne le plus à droite, donc son fils droit est une feuille vide. On a plusieurs cas possibles :
                
                \begin{center}
                    \begin{tabular}{ccccc}
                        \begin{tikzpicture}
                            \node {$\vdots$}
                                child {node [circle, draw] {$m$}
                                    child {node [circle, fill] {}}
                                    child {node [circle, fill] {}}
                                }
                            ;
                        \end{tikzpicture}
                        &
                        
                        &
                        \begin{tikzpicture}
                            \node {$\vdots$}
                                child {node [circle, draw, color=red] {$n$}
                                    child {node [circle, fill] {}}
                                    child {node [circle, fill] {}}
                                }
                            ;
                        \end{tikzpicture}
                        &
                        
                        &
                        \begin{tikzpicture}
                            \node {$\vdots$}
                                child {node [circle, draw] {$m$}
                                    child {node [circle, draw, color=red] {$n$}
                                        child {node [circle, fill] {}}
                                        child {node [circle, fill] {}}
                                    }
                                    child {node [circle, fill] {}}
                                }
                            ;
                        \end{tikzpicture}
                        \\
                        $\downarrow$
                        &
                        &
                        $\downarrow$
                        &
                        &
                        $\downarrow$
                        \\
                        \begin{tikzpicture}
                            \node {$\vdots$}
                                child {node [circle, fill] {}}
                            ;
                        \end{tikzpicture}
                        &
                        
                        &
                        \begin{tikzpicture}
                            \node {$\vdots$}
                                child {node [circle, fill] {}}
                            ;
                        \end{tikzpicture}
                        &
                        
                        &
                        \begin{tikzpicture}
                            \node {$\vdots$}
                                child {node [circle, draw, color=red] {$n$}
                                    child {node [circle, fill] {}}
                                    child {node [circle, fill] {}}
                                }
                            ;
                        \end{tikzpicture}
                    \end{tabular}
                \end{center}
                
                $\bullet$ Dans le troisième cas, on peut avoir un conflit rouge-rouge avec le père de $m$
                
                \vspace{6pt}
                
                $\bullet$ Dans les cas 1 et 3, on a fait diminuer la hauteur noire.
                
                Si $n$ était la racine, ce problème serait facilement résolu. On se place donc dans le cas d'un fils droit dont la hauteur noire est inférieure d'une unité à celle de son frère.
                
                L'idée est de faire remonter un n\oe ud noir du sous-arbre du frère pour rétablir l'étiquette des hauteurs noires.
                
                \vspace{6pt}
                
                $\bullet$ Si le père est rouge, alors le frère est noir et on peut utiliser une rotation :
                
                \begin{center}
                    \begin{tabular}{ccc}
                        \begin{tikzpicture}
                            \node {$\vdots$}
                                child {node [circle, draw, color=red] {$f$}
                                    child {node [circle, draw] {$b$}
                                        child {node [isosceles triangle, shape border rotate=90, inner sep=1, draw] {$t_1$}}
                                        child {node [isosceles triangle, shape border rotate=90, inner sep=1, draw] {$t_2$}}
                                    }
                                    child {node [isosceles triangle, shape border rotate=90, inner sep=1, draw] {$t_3$}}
                                }
                            ;
                        \end{tikzpicture}
                        &
                        $\longrightarrow$
                        &
                        \begin{tikzpicture}
                            \node {$\vdots$}
                                child {node [circle, draw] {$b$}
                                    child {node [isosceles triangle, shape border rotate=90, inner sep=1, draw] {$t_1$}}
                                    child {node [circle, draw, color=red] {$f$}
                                        child {node [isosceles triangle, shape border rotate=90, inner sep=1, draw] {$t_2$}}
                                        child {node [isosceles triangle, shape border rotate=90, inner sep=1, draw] {$t_3$}}
                                    }
                                }
                            ;
                        \end{tikzpicture}
                    \end{tabular}
                \end{center}
                
                $\bullet$ Si le père et le frère sont noirs, on colore le père en rouge et on applique une rotation comme avant.
                
                \begin{center}
                    \begin{tabular}{ccc}
                        \begin{tikzpicture}
                            \node {$\vdots$}
                                child {node [circle, draw] {$f$}
                                    child {node [circle, draw] {$b$}
                                        child {node [isosceles triangle, shape border rotate=90, inner sep=1, draw] {$t_1$}}
                                        child {node [isosceles triangle, shape border rotate=90, inner sep=1, draw] {$t_2$}}
                                    }
                                    child {node [isosceles triangle, shape border rotate=90, inner sep=1, draw] {$t_3$}}
                                }
                            ;
                        \end{tikzpicture}
                        &
                        $\longrightarrow$
                        &
                        \begin{tikzpicture}
                            \node {$\vdots$}
                                child {node [circle, draw] {$b$}
                                    child {node [isosceles triangle, shape border rotate=90, inner sep=1, draw] {$t_1$}}
                                    child {node [circle, draw, color=red] {$f$}
                                        child {node [isosceles triangle, shape border rotate=90, inner sep=1, draw] {$t_2$}}
                                        child {node [isosceles triangle, shape border rotate=90, inner sep=1, draw] {$t_3$}}
                                    }
                                }
                            ;
                        \end{tikzpicture}
                    \end{tabular}
                \end{center}
                
                En plus de l'éventuel conflit rouge-rouge, la hauteur noire de ce sous-arbre a diminué et il faut appliquer la correction récursivement.
                
                \vspace{6pt}
                
                $\bullet$ Le père est noir, et le frère est rouge :
                
                \begin{center}
                    \begin{tabular}{ccc}
                        \begin{tikzpicture}
                            \node {$\vdots$}
                                child {node [circle, draw] {$f$}
                                    child {node [circle, draw, color=red] {$b$}
                                        child {node [circle, draw, xshift=-15pt] {$n_1$}
                                            child {node [isosceles triangle, shape border rotate=90, inner sep=1, draw] {$t_1$}}
                                            child {node [isosceles triangle, shape border rotate=90, inner sep=1, draw] {$t_2$}}
                                        }
                                        child {node [circle, draw, xshift=15pt] {$n_2$}
                                            child {node [isosceles triangle, shape border rotate=90, inner sep=1, draw] {$t_3$}}
                                            child {node [isosceles triangle, shape border rotate=90, inner sep=1, draw] {$t_4$}}
                                        }
                                    }
                                    child {node [isosceles triangle, shape border rotate=90, inner sep=1, draw] {$t_5$}}
                                }
                            ;
                        \end{tikzpicture}
                        &
                        $\longrightarrow$
                        &
                        \begin{tikzpicture}
                            \node {$\vdots$}
                                child {node [circle, draw] {$b$}
                                    child {node [circle, draw, xshift=-20pt] {$n_1$}
                                        child {node [isosceles triangle, shape border rotate=90, inner sep=1, draw] {$t_1$}}
                                        child {node [isosceles triangle, shape border rotate=90, inner sep=1, draw] {$t_2$}}
                                    }
                                    child {node [circle, draw, xshift=20pt] {$f$}
                                        child {node [circle, draw, color=red] {$n_2$}
                                            child {node [isosceles triangle, shape border rotate=90, inner sep=1, draw] {$t_3$}}
                                            child {node [isosceles triangle, shape border rotate=90, inner sep=1, draw] {$t_4$}}
                                        }
                                        child {node [isosceles triangle, shape border rotate=90, inner sep=1, draw] {$t_5$}}
                                    }
                                }
                            ;
                        \end{tikzpicture}
                    \end{tabular}
                \end{center}
                
                Il peut y avoir un conflit rouge-rouge mais la hauteur noire est bien corrigée
                
                \vspace{12pt}
                
                Remarque : comme pour l'insertion, on effectue un nombre logarithmique de corrections, donc la complexité attendue est préservée.
            \end{indt}
        \end{indt}
        
    \end{indt}
    
    \vspace{12pt}
    
    \begin{indt}{\section{Files de priorité}}
        
        \begin{indt}{\subsection{Définition, premières implémentations}}
            \begin{indt}{\subsubsection{Introduction}}
                La notion de \textit{file de priorité} généralise celles de pile et de file : on extrait les éléments en fonction de leur priorité qui n'est pas nécessairement fonction de l'ordre d'insertion.
            \end{indt}
            
            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Définition (\textit{file de priorité})}}
                \begin{indt}{Une \textit{file de priorité} est une structure de données associant des valeurs prises dans un ensemble $E$ à celles prises dans un ensemble totalement ordonné $(K,\ \le)$ et dont les opérations sont les suivantes :}
                    $-$ Création d'une file de priorité vide ;
                    
                    $-$ Test de vacuité ;
                    
                    $-$ Insertion d'un élément de $E$ associé à une priorité $k \in K$ ;
                    
                    $-$ Modification de la priorité d'un élément ;
                    
                    $-$ Extraction de l'élément de priorité maximale.
                \end{indt}
                
                \vspace{12pt}
                
                On parle de file de priorité max, par opposition aux files de priorité min où l'on extrait l'élément de priorité minimale.
            \end{indt}
            
            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Implémentation par liste triée}}
                On stocke les couples (éléments, priorité) triés par priorité décroissante.
                
                $-$ Création / test de vacuité : $\mathcal O(1)$
                
                $-$ Insertion / modification de priorité : $\mathcal O(n)$
                
                $-$ Extraction du max : $\mathcal O(1)$
            \end{indt}
            
            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Implémentation par ABR équilibrés}}
                $-$ Création / test de vacuité : $\mathcal O(1)$
                
                $-$ Insertion / extraction du max : $\mathcal O(\log n)$
                
                $-$ Modification de priorité : $\mathcal O(\log n)$ (supression + insertion)
            \end{indt}
            
            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Arbres tournois}}
                \begin{indt}{\textbf{Définition :}}
                    Soit $(K,\ \le)$ un ensemble totalement ordonné.
                    
                    Un \textit{arbre tournoi} est un arbre binaire étiqueté par des éléments de $K$ tel que pour tout n\oe ud, l'étiquette de ce n\oe ud est supérieure à toutes celles de ses descendants.
                \end{indt}
                
                \vspace{12pt}
                
                Exemple :
                \begin{center}
                    \begin{tikzpicture}
                        \node [circle, draw] {12}
                            child {node [circle, draw, xshift=-20pt] {10}
                                child {node [circle, draw] {3}}
                                child {node [circle, draw] {2}
                                    child {node [circle, draw, xshift=20pt] {1}}
                                }
                            }
                            child {node [circle, draw, xshift=20pt] {11}
                                child {node [circle, draw] {5}}
                                child {node [circle, draw] {5}
                                    child {node [circle, draw, xshift=20pt] {4}
                                        child {node [circle, draw, xshift=20pt] {3}}
                                    }
                                }
                            }
                        ;
                    \end{tikzpicture}
                \end{center}
            \end{indt}
            
            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Implémentation par arbre tournoi}}
                \label{3.1.6}
                
                $-$ Création / test de vacuité : $\mathcal O(1)$
                
                $-$ Extraction du max : $\mathcal O(h)$ en fusionnant les deux sous-arbres ou en plaçant l'une des feuilles à la place de la racine et en le faisant redescendre (on parle de \textit{percolation descendante}).
                
                Exemple avec l'arbre précédant :
                \begin{center}
                    \begin{tikzpicture}
                        \node [circle, draw] {11}
                            child {node [circle, draw, xshift=-20pt] {10}
                                child {node [circle, draw] {3}}
                                child {node [circle, draw] {2}
                                    child {node [circle, draw, xshift=20pt] {1}}
                                }
                            }
                            child {node [circle, draw, xshift=20pt] {5}
                                child {node [circle, draw] {3}}
                                child {node [circle, draw] {5}
                                    child {node [circle, draw, xshift=20pt] {4}
                                        %child {node [circle, draw, xshift=20pt] {3}}
                                    }
                                }
                            }
                        ;
                    \end{tikzpicture}
                \end{center}
                
                $-$ Insertion : $\mathcal O(h)$ en plaçant une nouvelle feuille que l'on fait remonter (\textit{percolation ascendante})
                
                Exemple avec l'arbre ci-dessus :
                \begin{center}
                    \begin{tikzpicture}
                        \node [circle, draw] {11}
                            child {node [circle, draw, xshift=-20pt] {11}
                                child {node [circle, draw] {10}
                                    child {node [circle, draw, xshift=-20pt] {3}}
                                }
                                child {node [circle, draw] {2}
                                    child {node [circle, draw, xshift=20pt] {1}}
                                }
                            }
                            child {node [circle, draw, xshift=20pt] {5}
                                child {node [circle, draw] {3}}
                                child {node [circle, draw] {5}
                                    child {node [circle, draw, xshift=20pt] {4}
                                        %child {node [circle, draw, xshift=20pt] {3}}
                                    }
                                }
                            }
                        ;
                    \end{tikzpicture}
                \end{center}
                
                $-$ Modification de priorité : percolation selon la nouvelle priorité : $\mathcal O(h)$
                
                \vspace{12pt}
                
                \begin{indt}{Besoins :}
                    $-$ Arbre équilibré ;
                    
                    $-$ Trouver le père d'un n\oe ud donné ;
                    
                    $-$ Accès rapide aux feuilles
                    
                    $-$ Accès en temps constant à un n\oe ud donné.
                \end{indt}
            \end{indt}
        \end{indt}
        
        \vspace{12pt}
        
        \begin{indt}{\subsection{Tas binaire}}
            \begin{indt}{\subsubsection{Définition (\textit{arbre parfait})}}
                \begin{indt}{Un \textit{arbre parfait} est un arbre binaire strict tel que :}
                    (1) Toutes les feuilles sont de profondeur $h$ ou $h - 1$, où $h$ est la hauteur ;
                    
                    (2) $\forall p < h$, il y a exactement $2^p$ n\oe uds de profondeur $p$ ;
                    
                    (3) Les feuilles de profondeur $h$ sont ``tassées'' à gauche.
                \end{indt}
                
                \vspace{12pt}
                
                Attention : certains parlent d'arbre complet.
            \end{indt}
            
            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Exemple}}
                \label{3.2.2}
                
                \begin{center}
                    \begin{tikzpicture}
                        \node [circle, draw] {1}
                            child {node [circle, draw] {2}
                                child {node [circle, draw] {4}}
                                child {node [circle, draw] {5}}
                            }
                            child {node [circle, draw] {3}}
                        ;
                    \end{tikzpicture}
                \end{center}
            \end{indt}
            
            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Proposition}}
                Un arbre parfait à $n$ n\oe uds est de hauteur $h = \floor{\log_2 n}$
                
                \begin{indt}{$\square$ Démonstration :}
                    Le nombre de n\oe uds est compris entre le nombre d'un arbre complet de hauteur $h - 1$ et celui d'un arbre complet de hauteur $h$.
                    
                    Or le nombre de n\oe uds d'un arbre complet de hauteur $l$ est
                        \[ \sum_{p = 0}^{l} 2^p = 2^{l + 1} - 1 \qquad \boxed{\rm Exo} \]
                    
                    Donc $2^h - 1 < n \le 2^{h + 1} - 1$
                    
                    donc $2^h \le n < 2^{h + 1}$, d'où $h \le \log_2 n < h + 1$ $\blacksquare$
                \end{indt}
            \end{indt}
            
            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Représentation par tableaux}}
                On place la racine dans la case d'indice 0 et pour tout n\oe ud d'indice $i$, on place ses fils gauche et droit dans les cases d'indices $2i + 1$ et $2i + 2$ s'ils existent.
                
                \vspace{12pt}
                
                Exemple pour l'arbre en \ref{3.2.2} : 
                \begin{tabular}{|c|c|c|c|c|}
                    \hline
                    1 & 2 & 3 & 4 & 5
                    \\
                    \hline
                \end{tabular}
                
                C'est un parcours en largeur.
                
                \vspace{12pt}
                
                Remarque : cela répond aux besoins exprimés en \ref{3.1.6} : feuilles à partir de l'indice $\floor{\dfrac n 2}$, père du n\oe ud $i$ à l'indice $\floor{\dfrac{i - 1}{2}}$
            \end{indt}
            
            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Définition (\textit{tas})}}
                Un \textit{tas} est un arbre tournoi parfait.
                
                On parle parfois de \textit{tas max}.
            \end{indt}
            
            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Implémentation}}
                On peut choisir d'utiliser un tableau statique ou un tableau dynamique.
                
                on utilisera le type suivant :
                \begin{lstlisting}[language=Caml, xleftmargin=80pt]
type 'a heap = {t : 'a array; mutable n : int}\end{lstlisting}
            \end{indt}
            
            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Percolation descendante}}
                sift = tamis.
                
                \begin{lstlisting}[language=Caml, xleftmargin=80pt]
let rec sift_down (hp : 'a heap) (i : int) : unit =
    let j = ref i in
    if 2*i + 1 < hp.n && hp.t.(2*i + 1) > hp.t.(i) then
        j := 2*i + 1;
    if 2*i + 2 < hp.n && hp.t.(2*i + 2) > hp.t.(!j) then
        j := 2*i + 2;
    if !j <> i then begin
        swap hp.t i !j; (*Exo : coder swap*)
        sift_down hp !j
    end\end{lstlisting}
            \end{indt}
            
            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Percolation ascendante}}
                \boxed{\rm Exo}
            \end{indt}
            
            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Extraction du max}}
                \begin{lstlisting}[language=Caml, xleftmargin=80pt]
let take_max (hp : 'a heap) : 'a =
    swap hp.t 0 (hp.n - 1);
    hp.n <- hp.n - 1;
    sift_down hp 0 ;
    hp.t.(hp.n)\end{lstlisting}
            \end{indt}
            
            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Insertion}}
                \begin{lstlisting}[language=Caml, xleftmargin=80pt]
let insert (x : 'a) (hp : 'a heap) : unit =
    hp.t.(hp.n) <- x;
    sift_up hp hp.n;
    hp.n <- hp.n + 1\end{lstlisting}
            \end{indt}
            
            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Conversion d'un tableau en tas}}
                $\mathcal O(n\log n)$ par insertion successives car chaque feuille insérée peut percoler jusqu'à la racine.
                
                \vspace{12pt}
                
                Construction par forêt : on voit les éléments du tableau comme des tas séparés que l'on fusionne :
                \begin{lstlisting}[language=Caml, xleftmargin=80pt]
let array_to_heap (t : 'a array) : 'a heap =
    let hp = {t = Array.copy t ; n = Array.length t} in
    for i = hp.n / 2 - 1 downto 0 do
        sift_down hp i
    done;
    hp\end{lstlisting}
                
                Exemple :
                
                \begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c|c|}
                    \hline
                    2 & 11 & 1 & 3 & 0 & 3 & 2 & 5 & $-8$ & $-2$ & 5 & 4
                    \\
                    \hline
                \end{tabular}
                
                \begin{center}
                    \begin{tikzpicture}
                        \node [circle, draw] {2}
                            child {node [circle, draw, xshift=-50pt] {11}
                                child {node [circle, draw, xshift=-20pt] {3}
                                    child {node [circle, draw] {5}}
                                    child {node [circle, draw] {$-8$}}
                                }
                                child {node [circle, draw, xshift=20pt] {0}
                                    child {node [circle, draw] {$-2$}}
                                    child {node [circle, draw] {5}}
                                }
                            }
                            child {node [circle, draw, xshift=50pt] {1}
                                child {node [circle, draw] {3}
                                    child {node [circle, draw, xshift=-20pt] {4}}
                                }
                                child {node [circle, draw] {2}}
                            }
                        ;
                    \end{tikzpicture}
                \end{center}
                
                Donne :
                
                \begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c|c|}
                    \hline
                    11 & 5 & 4 & 5 & 2 & 3 & 2 & 3 & $-8$ & $-2$ & 0 & 1
                    \\
                    \hline
                \end{tabular}
                
                \begin{center}
                    \begin{tikzpicture}
                        \node [circle, draw] {11}
                            child {node [circle, draw, xshift=-50pt] {5}
                                child {node [circle, draw, xshift=-20pt] {5}
                                    child {node [circle, draw] {3}}
                                    child {node [circle, draw] {$-8$}}
                                }
                                child {node [circle, draw, xshift=20pt] {2}
                                    child {node [circle, draw] {$-2$}}
                                    child {node [circle, draw] {0}}
                                }
                            }
                            child {node [circle, draw, xshift=50pt] {4}
                                child {node [circle, draw] {3}
                                    child {node [circle, draw, xshift=-20pt] {1}}
                                }
                                child {node [circle, draw] {2}}
                            }
                        ;
                    \end{tikzpicture}
                \end{center}
                
                \vspace{12pt}
                
                Correction : invariant $I(i) : \forall j \ge i$, l'arbre de racine $j$ est un tas.
                
                Complexité : chaque n\oe ud de profondeur $p$ ne peut descendre que de $h - p$ niveaux.
                    \[ \sum_{p = 0}^{h - 1} (h - p) 2^p = \sum_{p = 1}^h p 2^{h - p} = 2^h \sum_{p = 1}^h p 2^{-p} \le 2^h \underbrace{\sum_{p = 1}^\infty p 2^{-p}}_{\text{constant}} \]
                
                donc $\mathcal O(2^h)$, \textit{i.e} $\mathcal O(n)$.
            \end{indt}
            
            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Tri par tas}}
                \begin{lstlisting}[language=Caml, xleftmargin=80pt]
let heap_sort (a : 'a array) : unit =
    let hp = array_to_heap a
    and n = Array.length a in
    for i = n - 1 downto 0 do
        a.(i) <- take_max hp
    done\end{lstlisting}
                
                Complexité : conversion en $\mathcal O(n)$ + $n$ extractions de max en $\mathcal O(\log n)$ donc en $\mathcal O(n\log n)$.
                
                Remarque : le type \texttt{'a heap} n'est pas nécessaire, on peut tout faire en place sur le tableau $\rightarrow$ $\mathcal O(1)$ en espace.
            \end{indt}
        \end{indt}
        
    \end{indt}
    
    
    
\end{document}
%--------------------------------------------End
