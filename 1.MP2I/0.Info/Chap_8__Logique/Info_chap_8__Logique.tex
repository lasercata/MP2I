\documentclass[a4paper, 12pt, twoside]{article}


%------------------------------------------------------------------------
%
% Author                :   Lasercata
% Last modification     :   2023.04.17
%
%------------------------------------------------------------------------


%------ini
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[french]{babel}
%\usepackage[english]{babel}


%------geometry
\usepackage[textheight=700pt, textwidth=500pt]{geometry}


%------color
\usepackage{xcolor}
\definecolor{ff4500}{HTML}{ff4500}
\definecolor{00f}{HTML}{0000ff}
\definecolor{0ff}{HTML}{00ffff}
\definecolor{656565}{HTML}{656565}

\renewcommand{\emph}{\textcolor{ff4500}}
\renewcommand{\em}{\color{ff4500}}

\newcommand{\strong}[1]{\textcolor{ff4500}{\bf #1}}
\newcommand{\st}{\color{ff4500}\bf}


%------Code highlighting
%---listings
\usepackage{listings}

\definecolor{cbg}{HTML}{272822}
\definecolor{cfg}{HTML}{ececec}
\definecolor{ccomment}{HTML}{686c58}
\definecolor{ckw}{HTML}{f92672}
\definecolor{cstring}{HTML}{e6db72}
\definecolor{cstringlight}{HTML}{98980f}
\definecolor{lightwhite}{HTML}{fafafa}

\lstdefinestyle{DarkCodeStyle}{
    backgroundcolor=\color{cbg},
    commentstyle=\itshape\color{ccomment},
    keywordstyle=\color{ckw},
    numberstyle=\tiny\color{cbg},
    stringstyle=\color{cstring},
    basicstyle=\ttfamily\footnotesize\color{cfg},
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    keepspaces=true,
    numbers=left,
    numbersep=5pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=4,
    xleftmargin=\leftskip
}

\lstdefinestyle{LightCodeStyle}{
    backgroundcolor=\color{lightwhite},
    commentstyle=\itshape\color{ccomment},
    keywordstyle=\color{ckw},
    numberstyle=\tiny\color{cbg},
    stringstyle=\color{cstringlight},
    basicstyle=\ttfamily\footnotesize\color{cbg},
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    keepspaces=true,
    numbers=left,
    numbersep=10pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=4,
    frame=L,
    xleftmargin=\leftskip
}

%\lstset{style=DarkCodeStyle}
\lstset{style=LightCodeStyle}
%Usage : \begin{lstlisting}[language=Caml] ... \end{lstlisting}

%---tcolorbox
\usepackage[many]{tcolorbox}
\DeclareTColorBox{pseudocode}{O{black}O{lightwhite}}{
    breakable,
    outer arc=0pt,
    arc=0pt,
    top=0pt,
    toprule=-.5pt,
    right=0pt,
    rightrule=-.5pt,
    bottom=0pt,
    bottomrule=-.5pt,
    colframe=#1,
    colback=#2,
    enlarge left by=10pt,
    width=\linewidth-\leftskip-10pt,
}


%-------make the table of content clickable
\usepackage{hyperref}
\hypersetup{
    colorlinks,
    citecolor=black,
    filecolor=black,
    linkcolor=black,
    urlcolor=black
}
%Uncomment this and comment above for dark mode
% \hypersetup{
%     colorlinks,
%     citecolor=white,
%     filecolor=white,
%     linkcolor=white,
%     urlcolor=white
% }


%------pictures
\usepackage{graphicx}
%\usepackage{wrapfig}

\usepackage{tikz}
\usetikzlibrary{shapes.geometric}


%------tabular
%\usepackage{color}
%\usepackage{colortbl}
%\usepackage{multirow}


%------Physics
%---Packages
%\usepackage[version=4]{mhchem} %$\ce{NO4^2-}$

%---Commands
\newcommand{\link}[2]{\mathrm{#1} \! - \! \mathrm{#2}}
\newcommand{\pt}[1]{\cdot 10^{#1}} % Power of ten
\newcommand{\dt}[2][t]{\dfrac{\mathrm d #2}{\mathrm d #1}} % Derivative


%------math
%---Packages
%\usepackage{textcomp}
%\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{mathtools} % For abs
\usepackage{stmaryrd} %for \llbracket and \rrbracket
\usepackage{mathrsfs} %for \mathscr{x} (different from \mathcal{x})

%---Commands
%-Sets
\newcommand{\N}{\mathbb{N}} %set N
\newcommand{\Z}{\mathbb{Z}} %set Z
\newcommand{\Q}{\mathbb{Q}} %set Q
\newcommand{\R}{\mathbb{R}} %set R
\newcommand{\C}{\mathbb{C}} %set C
\newcommand{\U}{\mathbb{U}} %set U
\newcommand{\seg}[2]{\left[ #1\ ;\ #2 \right]}
\newcommand{\nset}[2]{\left\llbracket #1\ ;\ #2 \right\rrbracket}

%-Exponantial / complexs
\newcommand{\e}{\mathrm{e}}
\newcommand{\cj}[1]{\overline{#1}} %overline for the conjugate.

%-Vectors
\newcommand{\vect}{\overrightarrow}
\newcommand{\veco}[3]{\displaystyle \vect{#1}\binom{#2}{#3}} %vector + coord

%-Limits
\newcommand{\lm}[2][{}]{\lim\limits_{\substack{#2 \\ #1}}} %$\lm{x \to a} f$ or $\lm[x < a]{x \to a} f$
\newcommand{\Lm}[3][{}]{\lm[#1]{#2} \left( #3 \right)} %$\Lm{x \to a}{f}$ or $\Lm[x < a]{x \to a}{f}$
\newcommand{\tendsto}[1]{\xrightarrow[#1]{}}

%-Integral
\newcommand{\dint}[4][x]{\displaystyle \int_{#2}^{#3} #4 \mathrm{d} #1} %$\dint{a}{b}{f(x)}$ or $\dint[t]{a}{b}{f(t)}$

%-left right
\newcommand{\lr}[1]{\left( #1 \right)}
\newcommand{\lrb}[1]{\left[ #1 \right]}
\newcommand{\lrbb}[1]{\left\llbracket #1 \right\rrbracket}
\newcommand{\set}[1]{\left\{ #1 \right\}}
\newcommand{\abs}[1]{\left\lvert #1 \right\rvert}
\newcommand{\ceil}[1]{\left\lceil #1 \right\rceil}
\newcommand{\floor}[1]{\left\lfloor #1 \right\rfloor}
\newcommand{\lrangle}[1]{\left\langle #1 \right\rangle}

%-Others
\newcommand{\para}{\ /\!/\ } %//
\newcommand{\ssi}{\ \Leftrightarrow \ }
\newcommand{\eqsys}[2]{\begin{cases} #1 \\ #2 \end{cases}}

\newcommand{\med}[2]{\mathrm{med} \left[ #1\ ;\ #2 \right]}  %$\med{A}{B} -> med[A ; B]$
\newcommand{\Circ}[2]{\mathscr{C}_{#1, #2}}

\renewcommand{\le}{\leqslant}
\renewcommand{\ge}{\geqslant}


%------commands
%---to quote french text
\newcommand{\simplecit}[1]{\guillemotleft$\;$#1$\;$\guillemotright}
\newcommand{\cit}[1]{\simplecit{\textcolor{656565}{#1}}}
\newcommand{\quo}[1]{\cit{\it #1}}

%---to indent
\newcommand{\ind}[1][20pt]{\advance\leftskip + #1}
\newcommand{\deind}[1][20pt]{\advance\leftskip - #1}

%---to indent a text
\newcommand{\indented}[2][20pt]{\par \ind[#1] #2 \par \deind[#1]}
\newenvironment{indt}[2][20pt]{#2 \par \ind[#1]}{\par \deind} %Titled indented env

%---title
\newcommand{\thetitle}[2]{\begin{center}\textbf{{\LARGE \underline{\emph{#1} :}} {\Large #2}}\end{center}}


%------Sections
% To change section numbering :
% \renewcommand\thesection{\Roman{section}}
% \renewcommand\thesubsection{\arabic{subsection}}
% \renewcommand\thesubsubsection{\aleph{subsection}}

% To start numbering from 0
% \setcounter{section}{-1}


%------page style
\usepackage{fancyhdr}
\usepackage{lastpage}

\setlength{\headheight}{18pt}
\setlength{\footskip}{50pt}

\pagestyle{fancy}
\fancyhf{}
\fancyhead[LE, RO]{\textit{\textcolor{black}{\today}}}
\fancyhead[RE, LO]{\large{\textsl{\emph{\texttt{\jobname}}}}}

\fancyfoot[RO, LE]{\textit{\texttt{\textcolor{black}{Page \thepage /}\pageref{LastPage}}}} %Change 'black' to 'white' for dark mode
\fancyfoot[LO, RE]{\includegraphics[scale=0.12]{/home/lasercata/Pictures/1.images_profil/logo/mieux/lasercata_logo_fly_fond_blanc.png}}

% For dark mode :
%/home/lasercata/Pictures/1.images_profil/logo/mieux/lasercata_logo_fly.png


%------init lengths
\setlength{\parindent}{0pt} %To avoid using \noindent everywhere.
\setlength{\parskip}{3pt}


%---------------------------------Begin Document
\begin{document}
    
    %For dark mode :
    % \pagecolor{black}
    % \color{white}
    
    \thetitle{Chapitre 8}{Logique}
    
    \tableofcontents
    \newpage
    
    
    \begin{indt}{\section{Introduction}}
        
        La logique est un domaine mathématique dont l'objet d'étude est l'ensemble des propriétés que l'on peut exprimer, leur valeur de vérité et la notion de démonstration. La logique propose un cadre formel pour manipuler ces notions, où l'on distingue la \textit{syntaxe}, \textit{i.e} la manière d'exprimer les propriétés, de la \textit{sémantique}, \textit{i.e} des interprétations que l'on peut donner à la syntaxe.
        
        Les démonstrations, vues en tant qu'objets mathématiques, ne seront étudiées qu'en MPI.
        
    \end{indt}
    
    \vspace{12pt}
    
    \begin{indt}{\section{Syntaxe des formules logiques}}
        
        \begin{indt}{\subsection{Logique propositionnelle}}
            \begin{indt}{\subsubsection{Introduction}}
                On décompose les propriétés que l'on cherche à exprimer pour faire ressortir leur structure logique. Les énoncés que l'on ne peut pas décomposer sont appelés \textit{atomes}. En logique propositionnelle, on abstrait les atomes en des variables dites propositionnelles.
            \end{indt}
            
            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Définition (formules de la logique propositionnelle)}}
                Soit $\mathcal V$ un ensemble de variables propositionnelles.
                
                On définit inductivement l'ensemble $\mathcal F$ des formules de la logique propositionnelle par
                    \[
                        \dfrac{x \in \mathcal V}{x \in \mathcal F}
                        \qquad
                        \dfrac{\varphi \in \mathcal F}{\neg \varphi \in \mathcal F}
                    \]
                    \[
                        \dfrac{\varphi_1 \in \mathcal F\ \varphi_2 \in \mathcal F}{\varphi_1 \vee \varphi_2 \in \mathcal F}
                        \qquad
                        \dfrac{\varphi_1 \in \mathcal F\ \varphi_2 \in \mathcal F}{\varphi_1 \wedge \varphi_2 \in \mathcal F}
                        \qquad
                        \dfrac{\varphi_1 \in \mathcal F\ \varphi_2 \in \mathcal F}{\varphi_1 \rightarrow \varphi_2 \in \mathcal F}
                    \]
                
                \vspace{6pt}
                
                On appelle $\neg$ la \textit{négation}, $\vee$ la \textit{disjonction}, $\wedge$ la \textit{conjonction}, et $\rightarrow$ l'\textit{implication}.
                
                On appelle aussi \textit{équivalence} le symbole $\leftrightarrow$ défini par
                    \[ \varphi_1 \leftrightarrow \varphi_2 = (\varphi_1 \rightarrow \varphi_2) \wedge (\varphi_2 \rightarrow \varphi_1) \]
            \end{indt}
            
            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Remarque}}
                Malgré leur nom, les symboles de la définition précédente n'ont aucune signification.
                
                Le sens des symboles tient au domaine de la sémantique. On parle ici de syntaxe abstraite.
                
                On peut utiliser une autre représentation pour les syntaxes abstraites, appelée \textit{grammaire}, qui s'écrit comme suit :
                    \[
                        \varphi ::= x \
                        |\ \neg \varphi\
                        |\ \varphi_1 \vee \varphi_2\
                        |\ \varphi_1 \wedge \varphi_2\
                        |\ \varphi_1 \rightarrow \varphi_2
                    \]
                où $x$ parcourt $\mathcal V$.
                
                L'étude précise des grammaires relève du programme de MPI.
            \end{indt}
            
            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Vocabulaire}}
                Les symboles $\neg, \vee, \wedge, \rightarrow, \leftrightarrow$ sont appelés connecteurs logiques. Ce sont eux qui définissent la structure logique des énoncés. Le nombre d'arguments d'un connecteur logique est appelé son \textit{arité}.
            \end{indt}
            
            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Représentation des formules}}
                On représente généralement les formules de manière linéaire en ajoutant des parenthèses pour désambigüiser la lecture. Par exemple, $p \vee q \wedge r$ peut se lire $p \vee (q \wedge r)$ ou $(p \vee q) \wedge r$. Par convention, la négation est prioritaire sur les autres connecteurs, donc $\neg p \vee q$ se lit $(\neg p) \vee q$ et pas $\neg (p \vee q)$.
                
                \vspace{12pt}
                
                En raison de leur définition inductive, les formules ont une représentation arborescente naturelle : chaque règle d'inférence utilisée définit un symbole de tête / connecteur principal qui est la racine du sous-arbre correspondant.
                
                \vspace{12pt}
                
                Exemple : $p \rightarrow (\neg q \vee r)$ est représenté par :
                
                \begin{center}
                    \begin{tikzpicture}
                        \node {$\rightarrow$}
                            child {node {$p$}}
                            child {node {$\vee$}
                                child {node {$\neg$}
                                    child {node {$q$}}
                                }
                                child {node {$r$}}
                            }
                        ;
                    \end{tikzpicture}
                \end{center}
                
                Remarque : on obtient un arbre (binaire) dont les n\oe uds internes sont les connecteurs logiques et les n\oe uds externes sont les atomes. L'arité d'un connecteur est l'arité du n\oe ud correspondant.
                
                L'écriture linéaire de la formule correspond au parcours en profondeur infixe, en adoptant une représentation préfixe pour les n\oe uds d'arité 1.
                
                On pourrait envisager d'utiliser les parcours préfixes et postfixe pour représenter les formules.
            \end{indt}
            
            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Vocabulaire}}
                $-$ Une \textit{sous-formule} d'une formule $\varphi$ donnée est la formule associée à un sous-arbre de l'arbre représentant $\varphi$.
                
                On définit inductivement l'ensemble $SF(\varphi)$ des sous-formules de $\varphi$ par :
                    \[
                        \forall x \in \mathcal V,\ SF(x) = \set x
                        \qquad
                        SF(\neg \varphi) = \set{\neg \varphi} \cup SF(\varphi)
                    \]
                    \[
                        \forall \circ \in \set{\vee, \wedge, \rightarrow},\ SF(\varphi_1 \circ \varphi_2) = \set{\varphi_1 \circ \varphi_2} \cup SF(\varphi_1) \cup SF(\varphi_2)
                    \]
                
                Exemple :
                    \[ SF(p \rightarrow (\neg q \vee r)) = \set{p \rightarrow (\neg q \vee r), \neg q \vee r, p, \neg q, r, q} \]
                
                \vspace{12pt}
                
                $-$ La \textit{taille} $\abs \varphi$ d'une formule $\varphi$ est le nombre de connecteurs logiques de la formule, \textit{i.e} le nombre de n\oe uds internes de l'arbre $A_\varphi$ associé à $\varphi$.
                
                \vspace{12pt}
                
                \textbf{Proposition :}
                    \[ \dfrac{\abs{A_\varphi} - 1}{2} \le \abs \varphi \le \abs{A_\varphi} - 1 \]
                
                \begin{indt}{$\square$ Démonstration :}
                    L'arbre $A_\varphi$ contient au moins une feuille donc $\abs \varphi \le \abs{A_\varphi} - 1$
                    
                    (cas d'égalité pour $\varphi$ de taille $n$ : $\varphi = \underbrace{\neg \neg \cdots \neg}_{n\ \text{fois}} p$)
                    
                    $A_\varphi$ est un arbre binaire ayant $\abs{\varphi}$ n\oe uds internes, donc il a au plus $\abs \varphi + 1$ feuilles (Chap 6, 1.1.10), donc $\abs{A_\varphi} \le \abs \varphi + \abs \varphi + 1 = 2 \abs \varphi + 1$ $\blacksquare$
                \end{indt}
                
                \vspace{12pt}
                
                $-$ La \textit{hauteur} d'une formule est la hauteur de l'arbre associé, \textit{i.e} le nombre maximal de connecteurs à traverser pour atteindre une variable propositionnelle.
                
                Exemple : la hauteur de $p \rightarrow (\neg q \vee r)$ est 3.
            \end{indt}
        \end{indt}
        
        \vspace{12pt}
        
        \begin{indt}{\subsection{Logique du premier ordre}}
            \begin{indt}{\subsubsection{Définition (\textit{langage du premier ordre})}}
                \begin{indt}{Un \textit{langage du premier ordre} est défini par une signature $\Sigma$, composée de :}
                    $-$ symboles de fonction, chacun muni d'une arité $k \in \N$. Les symboles de fonction d'arité 0 sont appelés symboles de constante ;
                    
                    $-$ symboles de prédicat ou de relation, chacun muni d'une arité $k \in \N$. Les symboles de prédicat d'arité 0 sont appelés symboles de constante propositionnelle.
                \end{indt}
            \end{indt}
            
            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Exemple : le langage de la théorie des ensembles}}
                \begin{indt}{Le langage de la théorie des ensembles est défini par la signature suivante :}
                    $-$ symboles de fonction : $\varnothing$ (arité 0), $\set \cdot$ (arité 1), $\cdot \cup \cdot$ et $\cdot \cap \cdot$ (arité 2), $\cdot^c$ (arité 1) ;
                    
                    $-$ symboles de prédicat : $\cdot = \cdot$, $\cdot \subseteq \cdot$, $\cdot \in \cdot$ (arité 2).
                \end{indt}
            \end{indt}
            
            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Définition (\textit{termes} et formules de la logique du premier ordre)}}
                Soit $\Sigma$ une signature et $\mathcal V$ un ensemble de variables.
                
                \begin{indt}{$\Sigma$ et $\mathcal V$ définissent des ensembles de termes et de formules, \textit{via} les grammaires suivantes :}
                    $-$ Termes :
                        \[
                            t ::= x\ |\ f(t_1, \ldots, t_k)
                        \]
                    où
                        \[
                            \eqsys{x\ \text{parcourt}\ \mathcal V}{(f, k)\ \text{parcourt les symboles de la fonction et leur arité}}
                        \]
                    
                    $-$ Formules :
                        \[
                            \varphi ::=
                            p(t_1, \ldots, t_k)\
                            |\ \neg \varphi\
                            |\ \varphi_1 \vee \varphi_2\
                            |\ \varphi_1 \wedge \varphi_2\
                            |\ \varphi_1 \rightarrow \varphi_2\
                            |\ \forall x\ \varphi\
                            |\ \exists x\ \varphi
                        \]
                    où :
                        \[
                            \eqsys{x\ \text{parcourt}\ \mathcal V}{(p, k)\ \text{parcourt les symboles de prédicat et leur arité}}
                        \]
                \end{indt}
                
                On appelle $\forall$ le \textit{quantificateur universel}, et $\exists$ le \textit{quantificateur existentiel}.
                
                Les atomes de cette logique sont les formules de la forme $p(t_1, \ldots, t_k)$.
                
                    \[ \exists! x,\ P(x)\ \equiv\ \exists x\ (P(x) \wedge \forall y (P(y) \rightarrow y = x)) \]
                
                On parle de logique du premier ordre car on ne peut quantifier que sur des variables représentant des termes.
                Si l'on peut quantifier sur des variables représentant des formules, on parle de logique du second ordre.
            \end{indt}
            
            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Exemple}}
                En théorie des ensembles, la formule $(\forall A, \forall B, A \cap B \subseteq A) \wedge \varnothing \subseteq A$ est représentée de manière arborescente par :
                \begin{center}
                    \begin{tikzpicture}[terme/.style={shape=rectangle, draw=ff4500}, atome/.style={shape=circle, draw=blue}]
                        \node {$\wedge$}
                            child {node [xshift=-20pt] {$\forall A$}
                                child {node {$\forall B$}
                                    child {node {$\subseteq$}
                                        child {node (cap) {$\cap$}
                                            child {node {$A$}}
                                            child {node {$B$}}
                                        }
                                        child {node (A)  [terme] {$A$}}
                                    }
                                }
                            }
                            child {node [xshift=20pt] {$\subseteq$}
                                child {node (v)  [terme] {$\varnothing$}}
                                child {node [terme] {$A$}}
                            }
                        ;
                        
                        \draw[terme] (-3.2, -7.8) rectangle (-1.2, -5.75);
                        \draw[atome] (-1.5, -6.5) circle (2.3cm);
                        \draw[atome] (1.47, -2.5) circle (1.35cm);
                        
                        \matrix [draw, below left] at (5, -5) {
                            \node [terme, label=right:terme] {}; \\
                            \node [atome, label=right:atome] {}; \\
                        };
                    \end{tikzpicture}
                \end{center}
            \end{indt}
            
            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Remarque}}
                $\bullet$ La logique du premier ordre est aussi appelée calcul des prédicats.
                
                \vspace{12pt}
                
                $\bullet$ Dans une formule du premier ordre, les variables peuvent être ``capturées'' par un quantificateur ou indépendantes de toute quantification.
                
                On peut voir une formule comme une propriété des variables indépendantes de toute quantification et donc remplacer ces variables par des termes concrets.
                
                \vspace{12pt}
                
                $\bullet$ Le calcul propositionnel est un cas particulier du calcul des prédicats où il n'y a que des constantes propositionnelles (les quantificateurs et les termes deviennent inutiles).
            \end{indt}
            
            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Définition (variables libres / liées)}}
                Les \textit{variables libres} d'une formule $\varphi$ sont les variables qui ne sont pas ``capturées'' par un quantificateur. On les définit inductivement par
                
                    $
                        \begin{array}{l}
                            \displaystyle
                            FV(p(t_1, \ldots, t_n)) = \bigcup_{i = 1}^n \mathrm{Vars}(t_i) 
                            \quad
                            \text{où}
                            \quad
                            \eqsys{\mathrm{Vars}(x) = \set x}{\displaystyle \mathrm{Vars}(f(t_1, \ldots, t_n)) = \bigcup_{i = 1}^n \mathrm{Vars}(t_i)}
                            \\
                            FV(\neg \varphi) = FV(\varphi)
                            \vspace{6pt}
                            \\
                            \forall \circ \in \set{\vee, \wedge, \rightarrow},\ FV(\varphi_1 \circ \varphi_2) = FV(\varphi_1) \cup FV(\varphi_2)
                            \vspace{6pt}
                            \\
                            \forall Q \in \set{\exists, \forall},\ FV(Q x\ \varphi) = FV(\varphi) \setminus \set x
                        \end{array}
                    $
                
                \vspace{12pt}
                
                Exemple :
                
                $FV(\forall x,\ x + S y > 0) = \set y$
                
                \begin{center}
                    \begin{tikzpicture}[circ/.style={shape=circle, draw=black}]
                        \node [circ] {$\forall x$}
                            child {node [circ] {$>$}
                                child {node [circ] {$+$}
                                    child {node [circ] {$x$}}
                                    child {node [circ] {$S$}
                                        child {node [circ] {$y$}}
                                    }
                                }
                                child {node [circ] {$0$}}
                            }
                        ;
                    \end{tikzpicture}
                \end{center}
                
                $FV((\forall x\ x + y = 1) \wedge (\forall y\ x + y = 1)) = \set{x, y}$
                
                Une variable est dite \textit{liée} si elle n'est pas libre. Un même nom de variable peut avoir des occurrences libres et des occurrences liées. Dans une formule de la forme $Q x\ \varphi$ où $Q \in \set{\forall, \exists}$, on dit que $\varphi$ est la portée de la liaison pour $x$. Une variable est donc libre si elle admet une occurrence hors de la portée de toutes les liaisons pour cette variable et une variable est liée si toutes ses occurrences sont dans la portée d'une liaison pour cette variable.
                
                Une formule dont toutes les variables sont liées est dite \textit{close}.
            \end{indt}
            
            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Remarque}}
                Le nom des variables liées n'est pas important.
                
                Exemple : $\forall x,\ x = x$ et $\forall y,\ y = y$ expriment la même propriété.
                
                On identifiera donc les formules au renommage près de leurs variables liées.
                
                On appelle cela \textit{l'$\alpha$-équivalence}.
                
                Lors du renommage de variables liées, il faut faire attention au phénomène de \textit{capture} de variables, par exemple $\forall y,\ x + y = 1$ n'est pas la même formule que $\forall x,\ x + x = 1$.
            \end{indt}
            
            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Définition (\textit{substitution})}}
                Soit $\varphi$ une formule, $x$ une variable, et $t$ un terme.
                
                La substitution de $t$ à $x$ dans $\varphi$, notée $\varphi [x := t]$ est définie inductivement par :
                    \[
                        p(t_1, \ldots, t_n) [x := t] = p(t_1[x := t], \ldots, t_n [x := t])
                    \]
                où
                    \[
                        \begin{cases}
                            x [x := t] = t
                            \\
                            y [x := t] = y\ \forall y \in \mathcal V \setminus \set x
                            \\
                            f(t_1, \ldots, t_n) [x := t] = f(t_1 [x := t], \ldots, t_n [x := t])
                        \end{cases}
                    \]
                    
                    \[
                        \begin{array}{l}
                            (\neg \varphi) [x := t] = \neg (\varphi [x := t])
                            \vspace{6pt}
                            \\
                            \forall \circ \in \set{\vee, \wedge, \rightarrow},\ (\varphi_1 \circ \varphi_2) [x := t] = \varphi_1[x := t] \circ \varphi_2 [x := t]
                            \vspace{6pt}
                            \\
                            \forall Q \in \set{\forall, \exists},\ (Q x\ \varphi)[x := t] = Q x\ \varphi
                            \vspace{6pt}
                            \\
                            \forall Q \in \set{\exists, \forall},\ (Q y\ \varphi)[x := t] = Q y\ (\varphi [x := t])\ \text{si $y \neq x$ et $y \not \in \mathrm{Vars}(t)$}
                        \end{array}
                    \]
                
                Exemple :
                
                $(\forall x,\ x = x)[x := 2 + 2] = \forall x,\ x = x$
                car
                $(\forall x,\ x = x)\ \underset{\alpha}{\equiv} \ (\forall y,\ y = y)$
                
                \vspace{6pt}
                
                $((\forall x,\ x + y = 1) \wedge (\forall y, \ x + y = 1))[x := 2] = (\forall x,\ x + y = 1) \wedge (\forall y,\ 2 + y = 1)$
                
                \vspace{12pt}
                
                $(\forall y,\ y = y + x)[x := 1 + y] \neq \forall y (y = y + 1 + y)$
                
                Mais plutôt $\forall z,\ z = z + 1 + y$ : on renomme les occurrences liées dans $\varphi$ des variables de $t$ avant de les substituer.
            \end{indt}
            
            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Remarque}}
                Le principe de l'$\alpha$-équivalence et les restrictions de la substitution sont liées aux questions de sémantique : l'$\alpha$-équivalence et la substitution doivent en quelque sorte conserver la signification logique des formules.
            \end{indt}
        \end{indt}
        
    \end{indt}
    
    \vspace{12pt}
    
    \begin{indt}{\section{Sémantique de la logique propositionnelle}}
        
        \begin{indt}{\subsection{Vocabulaire}}
            \begin{indt}{\subsubsection{Introduction}}
                Définir une sémantique revient à donner du sens aux symboles utilisés dans la syntaxe abstraite. On doit donc choisir un ensemble de valeurs qui servent d'interprétations aux termes construits à l'aide de la syntaxe et on doit décrire l'effet des symboles sur cet ensemble de valeurs.
                
                \vspace{12pt}
                
                Exemple : on considère des termes arithmétiques définis par :
                    \[ t ::= x\ |\ c\ |\ t_1 + t_2\ |\ t_1 - t_2\ |\ t_1 \times t_2 \]
                où $x$ parcourt un ensemble $\mathcal V$ de variables et $c$ parcourt $\N$, l'ensemble des constantes.
                
                On peut définir une sémantique en choisissant $\N$ pour l'ensemble des valeurs, $c + 1$ comme interprétation de $c$, la fonction $\min$ comme interprétation de $+$, la fonction $\max$ pour $-$, et l'addition pour $\times$.
                
                On peut bien-sûr donner une autre sémantique à ces termes, plus en cohérence avec les règles de l'arithmétique.
                
                Problème : l'interprétation des variables : elle dépend d'un contexte qui donne une valeur à chaque variable.
                
                Les sémantiques sont donc paramétrées par un environnement.
            \end{indt}
            
            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Définition (\textit{valuation})}}
                Une \textit{valuation} est une fonction de l'ensemble $\mathcal V$ des variables dans l'ensemble des valeurs choisies pour définir la sémantique. On parle aussi d'environnement, ou, dans le cas de la logique propositionnelle, de \textit{distribution} de vérité. L'ensemble des valeurs de vérité est noté $\set{V, F}$ où $V$ est la valeur vraie et $F$ la valeur fausse.
            \end{indt}
            
            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Définition (valeur de vérité d'une formule)}}
                Soit $\varphi$ une formule et $v$ une valuation.
                
                On définit inductivement l'interprétation de $\varphi$ pour $v$, notée $\llbracket \varphi \rrbracket_v$, par :
                    \[ \forall x\ \text{variable propositionnelle},\ \llbracket x \rrbracket_v = v(x) \]
                    \[ \llbracket \neg \varphi \rrbracket_v = \eqsys{V\ \text{si $\llbracket \varphi \rrbracket_v = F$}}{F\ \text{sinon}} \]
                    \[ \llbracket \varphi_1 \vee \varphi_2 \rrbracket_v = \eqsys{F\ \text{si $\llbracket \varphi_1 \rrbracket_v = \llbracket \varphi_2 \rrbracket_v = F$}}{V\ \text{sinon}} \]
                    \[ \llbracket \varphi_1 \wedge \varphi_2 \rrbracket_v = \eqsys{V\ \text{si $\llbracket \varphi_1 \rrbracket_v = \llbracket \varphi_2 \rrbracket_v = V$}}{F\ \text{sinon}} \]
                    \[ \llbracket \varphi_1 \rightarrow \varphi_2 \rrbracket_v = \eqsys{F\ \text{si $\llbracket \varphi_1 \rrbracket_v = V$ et $\llbracket \varphi_2 \rrbracket_v = F$}}{V\ \text{sinon}} \]
                
                On dit $v$ est un modèle de $\varphi \ssi \llbracket \varphi \rrbracket_v = V$
            \end{indt}
            
            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Définition (\textit{tautologie} / \textit{antilogie} / \textit{satisfiabilité})}}
                Soit $\varphi$ une formule.
                
                \begin{indt}{On dit que $\varphi$ est}
                    $-$ une \textit{tautologie} $\ssi$ toute valuation est un modèle de $\varphi$. On note alors $\vDash \varphi$ ;
                    
                    $-$ une \textit{antilogie} $\ssi$ elle n'admet aucun modèle ;
                    
                    $-$ \textit{satisfiable} $\ssi$ elle admet au moins un modèle.
                \end{indt}
            \end{indt}
            
            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Remarque}}
                On ajoute parfois à la syntaxe une tautologie notée $\top$ et une antilogie notée $\bot$.
                
                On peut toutefois les encoder :
                    \[ \top = x \vee \neg x \qquad \bot = x \wedge \neg x \]
                
                La tautologie $\varphi \vee \neg \varphi$ est appelée loi du tiers exclu.
                
                \boxed{\rm Exo} Montrer que les formules suivantes sont des tautologies :
                
                $p \rightarrow (q \rightarrow p), (p \rightarrow q) \vee (q \rightarrow r), (p \rightarrow (q \rightarrow r)) \rightarrow ((p \rightarrow q) \rightarrow (p \rightarrow r))$
                
                \vspace{12pt}
                
                Ex : Falso Quadlilet : $\bot \rightarrow \varphi$
                
                $\neg \neg \varphi \rightarrow \varphi$ (non admis par tout le monde)
                
                principe de démonstration par l'absurde : $\neg \neg \varphi = \neg \varphi \rightarrow \bot$
            \end{indt}
            
            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Définition (\textit{table de vérité})}}
                La \textit{table de vérité} de $\varphi$ est la table indexée par les valuations des variables de $\varphi$ et qui contient comme entrée correspondant à une valuation $v$ la valeur $\llbracket \varphi \rrbracket_v$.
                
                On représente la table de $\varphi$, de variables $x_1, \ldots, x_n$, en plaçant une colonne pour chaque $x_i$ et une colonne pour $\varphi$.
                
                Pour chaque valuation $v$, l'entrée correspondant à $x_i$ est $v(x_i)$ et l'entrée correspondant à $\varphi$ est $\llbracket \varphi \rrbracket_v$.
            \end{indt}
            
            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Exemple : table de vérité de $p \leftrightarrow q$}}
                $p \leftrightarrow q = (p \rightarrow q) \wedge (q \rightarrow p)$
                
                \begin{tabular}{c|c|c|c|c}
                    $p$ & $q$ & $p \rightarrow q$ & $q \rightarrow p$ & $p \leftrightarrow q$
                    \\
                    \hline
                    $F$ & $F$ & $V$ & $V$ & $V$
                    \\
                    $F$ & $V$ & $V$ & $F$ & $F$
                    \\
                    $V$ & $F$ & $F$ & $V$ & $F$
                    \\
                    $V$ & $V$ & $V$ & $V$ & $V$
                \end{tabular}
                
                Remarque : Ici on a considéré des colonnes supplémentaires pour des sous-formules pour simplifier le calcul.
            \end{indt}
            
            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Remarque}}
                \label{3.1.8}
                
                Construire une table de vérité est un algorithme simple pour déterminer si une formule est satisfiable / une tautologie / une antilogie.
                
                Cependant, si $\varphi$ a $n$ variables distinctes, alors il y a $2^n$ lignes dans sa table de vérité.
                
                De plus, étant donné $v$, déterminer $\llbracket \varphi \rrbracket_v$ se fait en temps $\mathcal O(\abs \varphi)$ et $\varphi$ peut avoir au plus $\abs\varphi + 1$ variables distinctes.
                
                Cela donne donc un algorithme de complexité $\mathcal O(\abs\varphi 2^{\abs\varphi})$
            \end{indt}
            
            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Proposition}}
                Il y a $2^{(2^n)}$ tables de vérités distinctes pour des formules à $n$ variables distinctes.
                
                \begin{indt}{$\square$ Démonstration :}
                    Il y a $2^n$ lignes dans une table et pour chaque ligne on a le choix entre 2 valeurs de vérité $\blacksquare$
                \end{indt}
            \end{indt}
        \end{indt}
        
        \vspace{12pt}
        
        \begin{indt}{\subsection{Conséquence et équivalence}}
            \begin{indt}{\subsubsection{Définition (\textit{conséquence})}}
                \label{3.2.1}
                
                Soient $\varphi$ et $\psi$ deux formules.
                
                On dit que $\psi$ est une conséquence logique de $\varphi$, noté $\varphi \vDash \psi$, si tout modèle de $\varphi$ est un modèle de $\psi$.
            \end{indt}
            
            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Proposition}}
                Soient $\varphi$ et $\psi$ deux formules.
                    \[ \varphi \vDash \psi \ssi \vDash \varphi \rightarrow \psi \]
                
                \begin{indt}{$\square$ Démonstration :}
                    $
                        \begin{array}{rcl}
                            \varphi \vDash \psi &\ssi& \text{tout modèle de $\varphi$ est un modèle de $\psi$}
                            \\
                            &\ssi& \forall\ \text{valutation $v$, soit $\lrbb \varphi _v = V = \lrbb{\psi}_v$, soit $\lrbb{\varphi}_v = F$}
                            \\
                            &\ssi& \forall\ \text{valuation $v$, $\lrbb{\varphi \rightarrow \psi}_v = V$}
                            \\
                            &\ssi& \vDash \varphi \rightarrow \psi \quad \blacksquare
                        \end{array}
                    $
                \end{indt}
            \end{indt}
            
            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Généralisation aux ensembles de formules}}
                $-$ Modèle : un modèle d'un ensemble $\Gamma$ de formules est une valuation $v$ telle que
                    \[ \forall \varphi \in \Gamma,\ \lrbb{\varphi}_v = V \]
                
                \begin{indt}{$-$ Satisfiabilité : un ensemble $\Gamma$ de formules est dit :}
                    $\bullet$ satisfiable si $\Gamma$ admet un modèle ;
                    
                    $\bullet$ contradictoire si $\Gamma$ n'admet pas de modèle.
                \end{indt}
                
                \vspace{12pt}
                
                $-$ Conséquence logique : une formule $\varphi$ est conséquence logique d'un ensemble $\Gamma$ de formules si tout modèle de $\Gamma$ est modèle de $\varphi$. On note alors $\Gamma \vDash \varphi$.
                
                \vspace{12pt}
                
                Remarques :
                
                $-$ $\varphi \vDash \psi \ssi \set \varphi \vDash \psi$
                
                $-$ L'intuition est la suivante : un ensemble de formules $\Gamma$ définit une théorie (un ensemble d'axiomes) et on s'intéresse aux formules vraies dans cette théorie (les conséquences logiques de $\Gamma$).
            \end{indt}
            
            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Proposition}}
                \begin{pseudocode}
                    Soit $\Gamma$ un ensemble de formules, et $\varphi$ une formule.
                        \[ \Gamma \vDash \varphi \ssi \Gamma \cup \set{\neg \varphi}\ \text{est contradictoire} \]
                \end{pseudocode}
                
                \begin{indt}[18pt]{$\square$ Démonstration :}
                    $
                        \begin{array}{rcl}
                            \Gamma \vDash \varphi &\ssi& \text{tout modèle de $\Gamma$ est un modèle de $\varphi$}
                            \vspace{6pt}
                            \\
                            &\ssi& \forall\ \text{valuation}\ v,\
                            \left|
                            \begin{array}{l}
                                \text{soit $v$ n'est pas un modèle de $\Gamma$}
                                \\
                                \text{soit}
                                \begin{cases}
                                    v\ \text{est un modèle de $\Gamma$}
                                    \\
                                    \lrbb \varphi _v = V
                                \end{cases}
                            \end{array}
                            \right.
                            \vspace{6pt}
                            \\
                            &\ssi& \forall\ \text{valuation $v$},\
                            \left|
                            \begin{array}{l}
                                \text{soit $v$ n'est pas un modèle de $\Gamma$}
                                \\
                                \text{soit}
                                \begin{cases}
                                    v\ \text{est un modèle de $\Gamma$}
                                    \\
                                    \lrbb{\neg \varphi}_v = F
                                \end{cases}
                            \end{array}
                            \right.
                            \vspace{6pt}
                            \\
                            &\ssi& \Gamma \cup \set{\neg \varphi}\ \text{n'admet aucun modèle}
                            \\
                            &\ssi& \Gamma \cup \set{\neg \varphi}\ \text{est contradictoire.} \quad \blacksquare
                        \end{array}
                    $
                \end{indt}
            \end{indt}
            
            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Proposition}}
                \begin{pseudocode}
                    Soient $(\varphi_k)_{k \in \nset 1 n}$ et $\psi$ des formules.
                        \[ \set{\varphi_k\ |\ k \in \nset 1 n} \vDash \psi \ssi \bigwedge_{k = 1}^n \varphi_k \rightarrow \psi \]
                \end{pseudocode}
                
                \begin{indt}{$\square$ Démonstration :}
                    \textbf{Lemme} : Soit $\Gamma$ un ensemble de formules, et $\varphi, \psi$ deux formules.
                        \[ \Gamma \cup \set \varphi \vDash \psi \ssi \Gamma \vDash \varphi \rightarrow \psi \]
                    
                    \begin{indt}{$\square$ Démonstration du lemme :}
                        $
                            \begin{array}{rcl}
                                \Gamma \cup \set \varphi \vDash \psi &\ssi& \forall\ \text{valuation $v$},\
                                \left|
                                \begin{array}{l}
                                    \text{soit $v$ n'est pas un modèle de $\Gamma \cup \set\varphi$}
                                    \\
                                    \text{soit $\lrbb{\varphi}_v = V$}
                                \end{array}
                                \right.
                                \vspace{6pt}
                                \\
                                &\ssi& \forall\ \text{valuation $v$,}\
                                \left|
                                \begin{array}{l}
                                    \text{soit $v$ n'est pas un modèle de $\Gamma$}
                                    \\
                                    \text{soit $\lrbb{\varphi}_v = F$, soit $\lrbb \varphi _v = V = \lrbb \psi _v$}
                                \end{array}
                                \right.
                                \vspace{6pt}
                                \\
                                &\ssi& \forall\ \text{valuation $v$},\
                                \left|
                                \begin{array}{l}
                                    \text{soit $v$ n'est pas un modèle de $\Gamma$}
                                    \\
                                    \text{soit $\lrbb{\varphi \rightarrow \psi}_v = V$}
                                \end{array}
                                \right.
                                \vspace{6pt}
                                \\
                                &\ssi& \Gamma \vDash \varphi \rightarrow \psi \quad \blacksquare
                            \end{array}
                        $
                    \end{indt}
                    
                    \vspace{12pt}
                    
                    On procède alors par récurrence en remarquant que
                        \[ \forall \varphi_1, \varphi_2,\ (\varphi_1 \wedge \varphi_2) \rightarrow \varphi\ \text{et}\ \varphi_1 \rightarrow (\varphi_2 \rightarrow \varphi) \]
                    ont les mêmes modèles $\blacksquare$
                \end{indt}
                
                \vspace{12pt}
                
                Remarque : cela ne s'exprime que pour les ensembles finis de formules, car les formules sont des objets finis. Le théorème de compacité (H.P) permet toujours de se ramener à un ensemble fini de formules.
            \end{indt}
            
            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Définition (\textit{équivalence})}}
                Soient $\varphi, \psi$ deux formules.
                
                On dit que $\varphi$ et $\psi$ sont équivalentes, noté $\varphi \equiv \psi$, si $\varphi$ et $\psi$ ont les mêmes modèles.
            \end{indt}
            
            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Remarque}}
                $\bullet$ $\varphi \equiv \psi \ssi (\varphi \vDash \psi\ \text{et}\ \psi \vDash \varphi) \ssi \varphi \leftrightarrow \psi$ (d'après \ref{3.2.1}, p.\pageref{3.2.1})
                
                $\bullet$ $\equiv$ est une relation d'équivalence
                
                $\bullet$ Deux formules sont équivalentes si elles ont la même table de vérité, donc il y a au plus $2^{(2^n)}$ classes d'équivalences pour des formules à $n$ variables.
                
                On verra comment construire une formule associée à chaque table de vérité possible.
            \end{indt}
            
            \vspace{12pt}
            
            \begin{indt}{\subsubsection{\'Equivalences classiques}}
                $\bullet$ \'Elément neutre :
                    \[ \varphi \wedge \top \equiv \varphi \qquad \varphi \vee \bot \equiv \varphi \]
                
                $\bullet$ \'Elément absorbant :
                    \[ \varphi \wedge \bot \equiv \bot \qquad \varphi \vee \top \equiv \top \]
                
                $\bullet$ Commutativité :
                    \[ \varphi_1 \wedge \varphi_2 \equiv \varphi_2 \wedge \varphi_1 \qquad \varphi_1 \vee \varphi_2 \equiv \varphi_2 \vee \varphi_1 \]
                
                $\bullet$ Associativité :
                    \[ \varphi_1 \wedge (\varphi_2 \wedge \varphi_3) \equiv (\varphi_1 \wedge \varphi_2) \wedge \varphi_3 \qquad \varphi_1 \vee (\varphi_2 \vee \varphi_3) \equiv (\varphi_1 \vee \varphi_2) \vee \varphi_3 \]
                
                $\bullet$ Distributivité :
                    \[ \varphi_1 \wedge (\varphi_2 \vee \varphi_3) \equiv (\varphi_1 \wedge \varphi_2) \vee (\varphi_1 \wedge \varphi_3) \]
                    \[ \varphi_1 \vee (\varphi_2 \wedge \varphi_3) \equiv (\varphi_1 \vee \varphi_2) \wedge (\varphi_1 \vee \varphi_3) \]
                
                $\bullet$ Idempotence :
                    \[ \varphi \wedge \varphi \equiv \varphi \qquad \varphi \vee \varphi \equiv \varphi \]
                
                $\bullet$ Involutivité :
                    \[ \neg \neg \varphi \equiv \varphi \]
                
                $\bullet$ Règles de complément (tiers exclu) :
                    \[ \varphi \wedge \neg \varphi \equiv \bot \qquad \varphi \vee \neg \varphi \equiv \top \]
                
                $\bullet$ Lois de De Morgan :
                    \[ \neg (\varphi \wedge \psi) \equiv \neg \varphi \vee \neg \psi \qquad \neg (\varphi \vee \psi) \equiv \neg \varphi \wedge \neg \psi \]
                
                $\bullet$ Décomposition de l'implication :
                    \[ \varphi \rightarrow \psi \equiv \neg (\varphi \wedge \neg \psi) \equiv \neg \varphi \vee \psi \]
                
                $\bullet$ Contraposition :
                    \[ \varphi \rightarrow \psi \equiv \neg \psi \rightarrow \neg \varphi \]
                
                $\bullet$ Currification :
                    \[ (\varphi_1 \wedge \varphi_2) \rightarrow \varphi_3 \equiv \varphi_1 \rightarrow (\varphi_2 \rightarrow \varphi_3) \]
            \end{indt}
            
            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Remarque}}
                Ces équivalences définissent des règles de simplification qui présentent la valeur logique des formules. Ces règles peuvent aussi s'appliquer aux sous formules d'une formule donnée. On dit que l'équivalence passe au contexte et que c'est une relation de congruence. Ces règles permettent de donner une forme particulière aux formules afin de simplifier l'étude de leur satisfiabilité.
            \end{indt}
        \end{indt}
        
        \vspace{12pt}
        
        \begin{indt}{\subsection{Formes normales}}
            \begin{indt}{\subsubsection{Définition (\textit{littéraux, classes, formes normales})}}
                $-$ Un \textit{littéral} est une formule qui est soit une variable, soit la négation d'une variable ;
                
                $-$ Une \textit{classe conjonctive} (resp. \textit{disjonctive}) est une conjonction (resp. disjonction) de littéraux ;
                
                $-$ Une formule sous \textit{forme normale disjonctive} (resp. \textit{conjonctive}) est une disjonction (resp. conjonction) de classes conjonctives (resp. disjonctives).
            \end{indt}
            
            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Exemple}}
                $(\neg x \wedge \neg y) \vee (\neg x \wedge \neg z \wedge t)$ est une FND (Forme Normale Disjonctive)
                
                $(x \vee y) \wedge (\neg x \vee \neg y)$ est une FNC (c'est XOR)
            \end{indt}
            
            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Théorème}}
                \begin{pseudocode}
                    Toute formule est équivalente à une forme normale conjonctive (resp. disjonctive).
                \end{pseudocode}
                
                \vspace{6pt}
                
                \begin{indt}{$\square$ Démonstration}
                    \begin{indt}{(1) Il suffit de montrer le théorème pour les FND :}
                        Soit $\varphi$ une formule. Alors $\neg \varphi$ est équivalente à une FND.
                        
                        Cette FND, $\displaystyle \bigvee_{i = 1}^n c_i$ où $\forall i \in \nset 1 n$, la classe $c_i$ s'écrit $\displaystyle \bigwedge_{j = 1}^{m_i} l_{i, j}$ avec les $l_{i, j}$ des littéraux.
                        
                        Donc
                            \[
                                \begin{array}{rcl}
                                    \varphi
                                    &\equiv& \neg \neg \varphi
                                    \vspace{6pt}
                                    \ \equiv\ \displaystyle \neg \lr{\bigvee_{i = 1}^n c_i}
                                    \vspace{6pt}
                                    \ \equiv\ \displaystyle \bigwedge_{i = 1}^n \neg c_i
                                    \vspace{6pt}
                                    \\
                                    &\equiv& \displaystyle \bigwedge_{i = 1}^n \neg \lr{\bigwedge_{j = 1}^{m_i} l_{i, j}}
                                    \vspace{6pt}
                                    \ \equiv\ \displaystyle \bigwedge_{i = 1}^n \bigvee_{j = 1}^{m_i} \neg l_{i, j}
                                    \vspace{6pt}
                                    \\
                                    &\equiv& \displaystyle \underbrace{\bigwedge_{i = 1}^n \bigvee_{j = 1}^{m_i} \widetilde{l_{i, j}}}_{\text{FNC}}
                                \end{array}
                            \]
                        où
                            \[
                                \forall (i, j),\ \widetilde{l_{i, j}} =
                                \left\{
                                \begin{array}{ll}
                                    \neg x_{i, j} & \text{si $l_{i ,j} = x_{i ,j} \in \mathcal V$}
                                    \\
                                    x_{i ,j} & \text{si $l_{i ,j} = \neg \underbrace{x_{i, j}}_{\in \mathcal V}$}
                                    \vspace{-12pt}
                                \end{array}
                                \right.
                            \]
                    \end{indt}
                    
                    %\vspace{12pt}
                    \newpage
                    
                    \begin{indt}{(2) Soit $\varphi$ une formule. Montrons que $\varphi$ est équivalente à une FND.}
                        Soit $v$ une valuation. On construit la classe
                            \[ c_v = \bigwedge_{\substack{x \in \mathcal V \\ v(x) = V}} x \wedge \bigwedge_{\substack{x \in \mathcal V \\ v(x) = F}} \neg x \]
                        (classe conjonctive)
                        
                        \boxed{\rm Exo} : $v$ est l'unique modèle de $c_v$.
                        
                        \vspace{12pt}
                        
                        Alors $\varphi \equiv \displaystyle \bigvee_{v\ |\ \lrbb{\varphi}_v = V} c_v$ (FND) $\blacksquare$
                    \end{indt}
                \end{indt}
            \end{indt}
            
            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Remarque}}
                $-$ On a démontré qu'il existe une formule associée à toute
                table de vérité.
                
                $-$ La normalisation d'une formule peut réutiliser une formule de taille exponentielle en la taille de la formule initiale.
                
                Exemple :
                    \[ \varphi = \bigwedge_{k = 1}^n (x_k \wedge y_k) \]
                est une FNC (dont la FND est de taille exponentielle en $n$)
                
                \boxed{\rm Exo} cette formule admet $3^n$ modèles.
                
                \vspace{12pt}
                
                $-$ Si on ne s'intéresse qu'à la satisfiabilité d'une formule, il est inutile de préserver l'équivalence : il suffit de considérer une formule qui est équistaisfiable, \textit{i.e} satisfiable si et seulement si la formule initiale est satisfiable.
            \end{indt}
            
            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Transformation de Tseitin (H.P)}}
                Idée : on ajoute de nouvelles variables qui seront ``équivalentes'' aux sous-formules.
                
                Soit $\varphi$ une formule. $\forall \psi \in SF(\varphi)$, on ajoute une variable $p_\psi$ et on construit une FNC $f_\psi$ définie inductivement par :
                    \[
                        \begin{array}{lrl}
                            f_x &=& (\neg p_x \vee x) \wedge (p_x \vee \neg x)
                            \\
                            f_{\neg \psi} &=& (\neg p_{\neg \psi} \vee \neg p_\psi) \wedge (p_{\neg \psi} \vee p_\psi)
                            \\
                            f_{\psi_1 \vee \psi_2} &=& (\neg p_{\psi_1 \vee \psi_2} \wedge p_{\psi_1} \vee p_{\psi_2}) \wedge (p_{\psi_1 \vee \psi_2} \vee \neg p_{\psi_1}) \wedge (p_{\psi_1 \vee \psi_2} \vee \neg p_{\psi_2})
                            \\
                            f_{\psi_1 \wedge \psi_2} &=& (\neg p_{\psi_1 \wedge \psi_2} \vee p_{\psi_1}) \wedge (\neg p_{\psi_1 \wedge \psi_2} \vee p_{\psi_2}) \wedge (p_{\psi_1 \wedge \psi_2} \vee \neg p_{\psi_1} \vee \neg p_{\psi_2})
                        \end{array}
                    \]
                
                On suppose avoir éliminé les simplifications ce qui ne fait que doubler la taille de la formule dans le pire cas.
                
                \vspace{12pt}
                
                La transformée de Tseitin de $\varphi$ est alors
                    \[ p_\varphi \wedge \bigwedge_{\psi \in SF(\varphi)} f_\psi \]
                qui est une FNC.
                
                \vspace{12pt}
                
                Remarque : la transformée de Tseitin se calcule en temps linéaire en la taille de la formule.
                
                Proposition (admise) : $\varphi$ et $p_\varphi \wedge \displaystyle \bigwedge_{\psi \in SF(\varphi)} f_\psi$ sont équisatisfiable.
                
                Idée : $f_\psi$ exprime $\psi \leftrightarrow p_\psi$.
            \end{indt}
        \end{indt}
        
    \end{indt}
    
    \vspace{12pt}
    
    \begin{indt}{\section{Problème de la satisfiabilité des formules propositionnelles}}
        
        \begin{indt}{\subsection{Présentation du problème}}
            \begin{indt}{\subsubsection{Définition (\textit{Problème SAT})}}
                Le problème SAT est le problème de décision suivant : étant donné une formule $\varphi$ de la logique propositionnelle, $\varphi$ est-elle satisfiable ?
            \end{indt}
            
            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Remarque}}
                Il existe un algorithme pour répondre à ce problème (on dit que SAT est décidable), mais l'algorithme vu en \ref{3.1.8} (p.\pageref{3.1.8}) est de complexité exponentielle.
                
                Question : peut-on faire mieux ?
            \end{indt}
            
            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Proposition}}
                \label{4.1.3}
                
                \begin{pseudocode}
                    Une clause conjonctive est une antinomie (= antilogie) $\ssi$ elle contient une variable et sa négation.
                \end{pseudocode}
                
                \begin{indt}{$\square$ Démonstration :}
                    \boxed{\Leftarrow} Si la clause s'écrit $x \wedge \neg x \wedge c$ (à l'ordre près des littéraux), alors
                        \[ \forall v,\ \lrbb{x \wedge \neg x \wedge c}_v = F \]
                    car $\lrbb{x \wedge \neg x}_v = F$.
                    
                    \vspace{12pt}
                    
                    \boxed{\Rightarrow} Par contraposée, on suppose que la clause ne contient pas une variable et sa négation. On montre qu'elle est satisfiable.
                    
                    On peut supposer que les littéraux portent sur des variables deux à deux distinctes. ($x \wedge x = x$ et $\neg x \wedge \neg x =\neg x $)
                    
                    On note alors $l_1, \ldots, l_n$ les littéraux, et $x_1, \ldots, x_n$ les variables associées.
                    
                    On définit une valuation $v$ par
                        \[ \forall i \in \nset 1 n,\ v(x_i) = \eqsys{V\ \text{si $l_i = x_i$}}{F\ \text{si $l_i = \neg x_i$}} \]
                    Alors
                        \[ \lrbb{\bigwedge_{i = 1}^n l_i}_v = V \]
                    donc la clause est satisfiable $\blacksquare$
                \end{indt}
            \end{indt}
            
            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Corollaire}}
                \begin{pseudocode}
                    On peut résoudre SAT en temps polynomial pour les FND
                \end{pseudocode}
                
                \begin{indt}{$\square$ Démonstration :}
                    Une FND est satisfiable $\ssi$ l'une de ses clauses est satisfiable
                    
                    $\ssi$ l'une de ses clauses ne contient pas une variable et sa négation.
                    
                    \vspace{12pt}
                    
                    Vérifier si une clause ne contient pas une variable et sa négation se fait en temps $\mathcal O(n^2)$ si la clause contient $n$ littéraux, voire $\mathcal O(n)$ si les variables sont représentées par des entiers.
                    
                    On applique cette vérification à chaque clause $\blacksquare$
                \end{indt}
            \end{indt}
            
            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Remarque}}
                $-$ On ne sait pas s'il est possible de résoudre SAT en temps polynomial (\textit{cf} cours sur la classe NP).
                
                \vspace{12pt}
                
                $-$ C'est déjà le cas pour certains cas particuliers de SAT.
            \end{indt}
            
            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Définition ($k$-SAT)}}
                \'Etant donné $k \in \N^*$, $k$-SAT est le problème de décision suivant : étant donné une formule $\varphi$ sous FNC telle que chaque clause contient au plus $k$ littéraux, $\varphi$ est-elle satisfiable ?
            \end{indt}
            
            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Remarque}}
                $-$ $1$-SAT est résoluble en temps polynomial (\textit{cf} \ref{4.1.3}, p.\pageref{4.1.3})
                
                $-$ On verra que $2$-SAT est résoluble en temps polynomial (\textit{cf} cours sur la théorie des graphes).
                
                $-$ La transformation de Tseitin fournit pour toute formule $\varphi$ une instance de $3$-SAT qui est de taille linéaire en la taille de $\varphi$ et qui est équisatifiable à $\varphi$, donc on ne sait pas résoudre $k$-SAT en temps polynomial pour $k \ge 3$.
                
                $-$ SAT et ses restrictions sont des problèmes importants car ils servent à modéliser de nombreux problèmes. On parle de réduction de ces problèmes à SAT.
            \end{indt}
            
            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Exemple de réduction à SAT}}
                Le problème du Sudoku
                
                $\bullet$ Rappel des règles : on dispose d'une grille $n \times n$ qu'on veut remplir avec des entiers de $\nset 1 n$ de telle sorte que chaque ligne / colonne / bloc de taille $l \times l$, où $n = l^2$ contienne chaque entier exactement une fois.
                
                Une grille peut être partiellement pré-remplie afin qu'il n'existe qu'une seule solution.
                
                \vspace{12pt}
                
                $\bullet$ Réduction à SAT : on introduit $n^3$ variables propositionnelles $(x_{i, j}^k)_{i, j, k \in \nset 1 n}$.
                
                Idée : $x_{i, j}^k$ signifie ``la case $(i, j)$ contient l'entier $k$''.
                
                On peut représenter les règles à l'aide de formules :
                
                $-$ Chaque case contient un unique chiffre :
                    \[ \bigwedge_{i = 1}^n \bigwedge_{j = 1}^n \bigvee_{k = 1}^n \lr{x_{i, j}^k \wedge \bigwedge_{k' \neq k} \neg x_{i, j}^{k'}} \]
                
                $-$ Chaque ligne contient au moins une fois chaque chiffre :
                    \[ \bigwedge_{k = 1}^n \bigwedge_{i = 1}^n \bigvee_{j = 1}^n x_{i, j}^k  \]
                
                $-$ Chaque ligne contient au plus une fois chaque chiffre :
                    \[ \bigwedge_{i = 1}^n \bigwedge_{j = 1}^n \bigwedge_{k = 1}^n \lr{x_{i, j}^k \rightarrow \bigwedge_{j' \neq j} \neg x_{i, j'}^k} \]
                
                $-$ Ect.
                
                ($\bigwedge$ est la version finie de $\forall$, et $\bigvee$ est la version finie de $\exists$)
                
                \vspace{12pt}
                
                On peut représenter les cases pré-remplies par des clauses unitaires $x_{i, j}^k$ (si la case $(i, j)$ est pré-remplie avec $k$)
                
                La conjonction de toutes ces formules donne une instance de SAT telle que tout modèle de cette conjonction représente une solution.
            \end{indt}
        \end{indt}
        
        \begin{indt}{\subsection{Résolution du problème SAT}}
            \begin{indt}{\subsubsection{Algorithme de Quine}}
                L'algorithme de Quine est un algorithme de résolution de SAT pour les FNC.
                
                Idée : on teste toutes les valuations possibles, mais en construisant de manière incrémentale les valuations en simplifiant la formule lors de la construction.
                
                Si $v(x) = V$ et si une clause $c$ contient $x$, alors $\lrbb c _v = V$ donc on peut retirer $c$ de la formule.
                
                Si $v(x) = V$ et si une clause $c$ contient $\neg x$, alors $\lrbb c _v = \lrbb{c \setminus \set{\neg x}}_v$ donc on peut retirer $\neg x$ de $c$.
                
                Cas symétrique si $v(x) = F$.
                
                Si on parvient à retirer toutes les clauses, alors la formule est satisfiable.
                
                Si on retire tous les littéraux d'une clause, alors elle n'est pas satisfiable dans la valuation partielle : il faut donc changer de valuation partielle en revenant sur les choix précédents.
                
                \vspace{12pt}
                
                Algorithme :
                
                Entrée : ensemble de clauses disjonctives $C$
                
                \begin{pseudocode}
                    \begin{indt}{fonction Quine($C$) :}
                        Si $C = \varnothing$ alors renvoyer vrai
                        
                        Si la clause vide $\in C$, alors envoyer faux
                        
                        \vspace{6pt}
                        
                        Choisir $x$, une variable apparaissant dans une clause de $C$
                        
                        $C' \leftarrow C$, où toute clause contenant $x$ a été supprimée et où $\neg x$  a été retiré de toutes les clauses.
                        
                        \vspace{6pt}
                        
                        Si Quine($C'$) alors renvoyer vrai
                        
                        \begin{indt}{Sinon : \textcolor{656565}{\it // on choisit $v(x) = F$}}
                            $C'' \leftarrow C$ où toute clause contenant $\neg x$ a été supprimée et où $x$ a été retiré de toutes les clauses
                            
                            Renvoyer Quine($C''$)
                        \end{indt}
                    \end{indt}
                \end{pseudocode}
                
                Dans le pire cas, on teste toutes les valuations, d'où la complexité exponentielle.
            \end{indt}
            
            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Implémentation de l'algorithme de Quine}}
                On peut représenter les clauses par des listes de littéraux et les FNC par des listes de clauses.
                
                \begin{lstlisting}[language=Caml, xleftmargin=80pt]
type litteral =
    | Var of string
    | NVar of string

type clause = litteral list
type fnc = clause list

let rec quine (f : fnc) : bool =
    match f with
    | [] -> true
    | _ when List.mem [] f -> false
    | (Var x :: _) :: _ | (NVar x :: _) :: _ ->
        if quine (List.map (List.filter (fun l -> l <> NVar x))
           (List.filter (fun c -> not (List.mem (Var x) c)) f)
        ) then true
        else quine (List.map (List.filter (fun l -> l <> Var x))
            (List.filter (fun c -> not (List.mem (NVar x) c)) f)
        )
    | _ -> failwith "Impossible"\end{lstlisting}
            \end{indt}
            
            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Optimisations}}
                \begin{indt}{On peut utiliser plusieurs techniques afin de rendre cet algo plus efficace :}
                    $-$ Propagation des clauses unitaire : si une clause ne contient plus qu'un seul littéral, la valeur de ce littéral est imposée. On peut donc effectuer les simplifications associées à cette valeur sans avoir besoin de revenir sur ce choix.
                    
                    Cela donne l'algorithme DPLL (Davis Putnam Logemann Loveland) (H.P)
                    
                    \vspace{12pt}
                    
                    $-$ On peut utiliser des heuristiques pour le choix du littéral, par exemple le littéral le plus fréquent, celui qui apparaît dans une clause la plus courante possible, ou un littéral choisi au hasard.
                    
                    \vspace{12pt}
                    
                    $-$ On peut ajouter des clauses à la formule pour tenir compte des échecs : une valuation partielle correspond à un ensemble de choix.
                    
                    \vspace{12pt}
                    
                    $-$ On peut ``apprendre'' une clause pour ne pas refaire de choix similaire dans un autre appel récursif.
                    
                    Cela donne l'algorithme CDCL (Conflict Driver Clause Learning) (H.P)
                    
                    DPLL et CDCL sont à la base des SAT-solvers modernes.
                \end{indt}
            \end{indt}
        \end{indt}
        
        \vspace{12pt}
        
        \begin{indt}{\subsection{Compléments d'algorithmique}}
            \begin{indt}{\subsubsection{Introduction}}
                L'algorithme de Quine est un cas particulier d'algorithme de recherche par \textit{force brute}. Le principe de la recherche par force brute, ou exploration exhaustive, est de tester toutes les valeurs possibles pour en trouver une qui répond au problème que l'on se pose.
                
                On peut appliquer cette méthode pour résoudre des problèmes de décision (existe-t-il une valeur qui satisfait des contraintes données ?) ou des problèmes d'optimisation (trouver une valeur qui satisfait certaines contraintes tout en maximisant / minimisant une certaine quantité)
                
                \begin{tabular}{|p{200pt}|p{200pt}|}
                    \hline
                    Avantages & Inconvénients
                    \\
                    \hline
                    $-$ Méthode complète : on trouve nécessairement une solution (optimale) si elle existe ;
                    
                    $-$ Souplesse : on peut aisément modifier l'algorithme à l'aide d'heuristiques pour le rendre plus efficace dans certains cas ;
                    
                    $-$ Méthode simple : implémentation aisée et simple à débugger ;
                    
                    $-$ On peut trouver toutes les solutions possibles, si c'est ce que l'on cherche.
                    & $-$ Complexité élevée (ex : trouver la clé secrète d'un schéma cryptographique, encodée sur $n$ bits nécessite $2^n$ essais)
                    \\
                    \hline
                \end{tabular}
            \end{indt}
            
            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Modalité d'implémentation}}
                Un algorithme de recherche par force brute s'écrit simplement ainsi :
                
                \begin{pseudocode}
                    \begin{indt}{Pour toute valeur $v$ :}
                        \begin{indt}{Si $v$ satisfait les contraintes :}
                            S'arrêter avec $v$ comme solution
                        \end{indt}
                    \end{indt}
                    
                    \'Echec de la recherche.
                \end{pseudocode}
                
                Version ``toutes les solutions'' :
                
                \begin{pseudocode}
                    $S \leftarrow \varnothing$
                    
                    \begin{indt}{Pour toute valeur $v$ :}
                        \begin{indt}{Si $v$ satisfait les contraintes :}
                            $S \leftarrow S \cup \set v$
                        \end{indt}
                    \end{indt}
                    
                    Renvoyer $S$
                \end{pseudocode}
                
                \vspace{12pt}
                
                Pour l'implémentation d'un tel algorithme, le paradigme de programmation et la manière dont on parcourt les valeurs contraignent la façon dont on écrit le code.
                
                \vspace{12pt}
                
                Pour une implémentation récursive, on peut manipuler l'ensemble des valeurs à traiter en retirant une à chaque appel récursif (coûteux en espace), ou, si l'on dispose d'une manière d'énumérer les valeurs en choisissant la valeur qui suit une valeur donnée, on peut partir d'une valeur initiale et faire un appel récursif sur la suivante jusqu'à exhaustion des valeurs (ex : listes chaînées, ou parcourt des indices d'un tableau par une fonction récursive).
                
                Si on dispose d'une telle manière d'énumérer les valeurs, on peut facilement traduire l'algorithme récursif en boucle \texttt{while} (tant que l'on n'a pas trouver de solution et que l'on n'a pas parcouru toutes les valeurs, passer à la valeur suivante) ou une boucle \texttt{for} (pour $i$ de 1 au nombre de valeurs, tester la valeur n°$i$).
                
                \vspace{12pt}
                
                Exemple : on veut savoir si $x$ apparaît dans $t$ de taille $n$ :
                
                Boucle \texttt{while} :
                
                \begin{lstlisting}[language=C, xleftmargin=80pt]
bool trouve = false;
int i = -1;
while (i < n - 1 && !trouve) {
    i++;
    trouve = t[i] == x;
}
//test de trouve\end{lstlisting}
                
                Boucle \texttt{for} :
                
                \begin{lstlisting}[language=C, xleftmargin=80pt]
int i;
for (i = 0 ; i < n ; i++) {
    if (t[i] == x)
        break;
}
//test de i\end{lstlisting}
                
                Remarques :
                
                $-$ On peut aussi simplifier la boucle \texttt{while} avec l'usage de \texttt{break}.
                
                $-$ Il n'y a pas d'instruction \texttt{break} en OCaml, mais on peut contrôler l'exécution à l'aide d'une exception :
                
                \begin{lstlisting}[language=Caml, xleftmargin=80pt]
exception Trouve of int
try
    for i = 0 to n - 1 do
        if t.(i) = x then
            raise (Trouve i)
    done;
    raise Not_found
with
| Trouve i -> i\end{lstlisting}
            \end{indt}
            
            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Retour sur trace (\textit{backtracking})}}
                L'algorithme de Quine correspond à une autre manière de parcourir l'ensemble des valeurs : on construit de manière incrémentale des valeurs partielles (valuation d'un sous-ensemble des variables), en passant d'une valeur partielle à une autre en effectuant un choix (choix de la valeur d'une variable) sur lequel on reviendra pour tester d'autres choix si celui-ci ne permet pas de trouver une solution.
                
                On appelle cette méthode le \textit{retour sur trace} (ou \textit{backtracking}).
                
                Le caractère incrémental impose de ne pas pouvoir boucler sur un ensemble de valeurs partielles et peut permettre d'éliminer des choix avant d'avoir construit une valeur complète.
                
                \vspace{12pt}
                
                Pseudo-code :
                
                \begin{pseudocode}
                    \begin{indt}{Recherche($v_{\rm init}$) :}
                        \begin{indt}{Si $v_{\rm init}$ est complète et satisfait les contraintes :}
                            S'arrêter avec $v_{\rm init}$ comme solution
                        \end{indt}
                        
                        \vspace{6pt}
                        
                        \begin{indt}{Si $v_{\rm init}$ est partielle :}
                            \begin{indt}{Pour chaque choix valide à partir de $v_{\rm init}$ :}
                                $v_{\rm next} \leftarrow$ résultat du choix
                                
                                Recherche($v_{\rm next}$)
                            \end{indt}
                        \end{indt}
                    \end{indt}
                \end{pseudocode}
                
                \vspace{12pt}
                
                Exemple : Sudoku
                
                Valeur : remplissage de la grille (pas forcément selon les règles)
                
                Valeur partielle : remplissage partiel de la grille : il peut y avoir des cases vides
                
                $v_{\rm init}$ : problème posé
                
                Choix : écriture d'un chiffre dans une case vide
                
                Choix valide : choix qui respecte les règles du jeu vis-à-vis des chiffres déjà inscrits.
                
                \vspace{12pt}
                
                Avec ces définitions, une valeur complète construite à l'aide d'une succession de choix valides est nécessairement une solution.
            \end{indt}
            
            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Optimisations}}
                $-$ Comme pour l'algorithme DPLL par rapport à l'algorithme de Quine, certains choix peuvent contraindre la complétion des valeurs partielles de telle sorte qu'il n'est pas nécessaire de revenir sur les choix ``imposés'' ;
                
                \vspace{12pt}
                
                $-$ On peut également parcourir qu'un sous-ensemble des valeurs possibles.
                
                C'est un procédé classique en géométrie algorithmique : l'ensemble des valeurs à parcourir est en général construit à partir d'un ensemble de point du plan / de l'espace. Parcourir l'ensemble des points selon une direction permet de ne considérer que certaines valeurs. On appelle cela un algorithme par \textit{droite de balayage}.
                
                \vspace{12pt}
                
                Idée : une droite / un plan perpendiculaire à la direction choisie balaye l'ensemble des points, et à chaque point rencontré, on effectue des opérations visant à construire une solution.
                
                Exemple : retour sur le TP$_{12}$
                
                Problème : étant donné un ensemble de points du plan, trouver une paire de points qui minimise la distance euclidienne entre ces points.
                
                Ensemble des valeurs : l'ensemble des paires de points $\rightarrow$ algorithme force brute en $\mathcal O(n^2)$
                
                Rappel : algorithme ``diviser pour régner'' en $\mathcal O(n\log n)$ vu en TP.
                
                Idée d'algorithme par droite de balayage : on parcourt les points par abscisse croissante en conservant la distance minimale courante $d$.
                
                On note $(x_0, y_0), \ldots, (x_{n - 1}, y_{n - 1})$ les points triés par abscisse.
                
                Si la distance minimale vaut $d$ après le parcourt des $k$ premiers points, il est inutile de considérer les points d'abscisse $< x_k - d$ pour la mise à jour de $d$.
                
                De même, il est inutile de considérer les points d'ordonnée $< y_k - d$ ou $> y_k + d$
                
                \begin{center}
                    \begin{tikzpicture}
                        \draw[->] (0, -.3) -- (6, -.3);
                        \draw[dashed] (3, -1) to (3, 3);
                        
                        \draw (2, .5) rectangle (3, 1.5);
                        \draw (2, 1.5) rectangle (3, 2.5);
                        
                        \draw[<->] (3.2, .5) -- node [right] {$d$} (3.2, 1.5);
                        \draw[<->] (3.2, 1.5) -- node [right] {$d$} (3.2, 2.5);
                        \draw[<->] (2, .3) -- node [below] {$d$} (3, .3);
                    \end{tikzpicture}
                \end{center}
                
                Attention : si les points d'abscisse $< x_k - d$ peuvent être définitivement oubliés, ceux d'abscisse $\ge x_k - d$ doivent être conservés même s'ils sont hors du rectangle dans l'éventualité d'un usage avec $(x_{k + 1}, y_{k + 1}                )$
                
                Remarque :
                le rectangle autour du point courant contient au plus 5 points en plus du point courant.
                
                \begin{center}
                    \begin{tikzpicture}
                        \draw (0, 0) rectangle (1, 1);
                        \draw (0, 1) rectangle (1, 2);
                        
                        \node at (0, 0) {$\bullet$};
                        \node at (1, 0) {$\bullet$};
                        \node at (1, 1) {$\bullet$};
                        \node at (1, 2) {$\bullet$};
                        \node at (0, 2) {$\bullet$};
                        \node at (0, 1) {$\bullet$};
                        
                        \draw[<->] (1.5, 0) -- node [right] {$d$} (1.5, .99);
                        \draw[<->] (1.5, 1.01) -- node [right] {$d$} (1.5, 2);
                        
                        \node (n) at (-2, 1) {$(x, y)$};
                        
                        \draw[->] (n) -- (-.2, 1);
                    \end{tikzpicture}
                \end{center}
                
                S'il y en avait plus, l'un des rectangles de dimension $\dfrac{2d}{3} \cdot \dfrac d 2$ contiendrait deux points.
                
                \begin{center}
                    \begin{tikzpicture}[scale=1]
                        \draw (0, 0) rectangle (2, 3);
                        
                        \draw[dashed] (1, -.5) -- (1, 3.5);
                        \draw[dashed] (-.5, 1) -- (2.5, 1);
                        \draw[dashed] (-.5, 2) -- (2.5, 2);
                        
                        \draw[<->] (2.2, 0) -- node [right] {$\dfrac{2d}{3}$} (2.2, 0.99);
                        \draw[<->] (2.2, 1.01) -- node [right] {$\dfrac{2d}{3}$} (2.2, 1.99);
                        \draw[<->] (2.2, 2.01) -- node [right] {$\dfrac{2d}{3}$} (2.2, 2.99);
                        
                        \draw[<->] (0, -.2) -- node [below] {$\dfrac{d}{2}$} (.99, -.2);
                        \draw[<->] (1.01, -.2) -- node [below] {$\dfrac{d}{2}$} (2, -.2);
                    \end{tikzpicture}
                \end{center}
                
                La distance maximale entre 2 points dans un tel rectangle est :
                    \[
                        \sqrt{\lr{\dfrac{2d}{3}}^2 + \lr{\dfrac d 2}^2}
                        = \sqrt{\dfrac{4d^2}{9} + \dfrac{d^2}{4}}
                        = \sqrt{\dfrac{25}{36}}d
                        = \dfrac 5 6 d
                        < d
                    \]
                impossible.
                
                \vspace{12pt}
                
                On en déduit l'algorithme suivant :
                
                \begin{pseudocode}
                    Trier les points par abscisse croissante, les nommer
                    $(x_0, y_0), \ldots, (x_{n - 1}, y_{n - 1})$
                    
                    $E \leftarrow \set{(x_0, y_0), (x_1, y_1)}$
                    
                    $d \leftarrow \mathrm{dist}((x_0, y_0), (x_1, y_1))$
                    
                    \begin{indt}{Pour $k$ de 2 à $n - 1$ :}
                        Retirer de $E$ les points d'abscisse $< x_k - d\qquad (*)$
                        
                        \begin{indt}{Pour chaque point actif $(x, y)$ tq $y_k - d \le y \le y_k + d$ : $\qquad (**)$}
                            $d \leftarrow \min(d,\ \mathrm{dist}((x_k, y_k), (x, y)))$
                        \end{indt}
                        
                        $E \leftarrow E \cup \set{(x_k, y_k)}$
                    \end{indt}
                    
                    Renvoyer $d$.
                \end{pseudocode}
                
                Complexité :
                
                $-$ $\mathcal O(n \log n)$ pour le tri
                
                $-$ Manipulation de $E$ : cela dépend de la structure de données
                
                $(*)$ inutile de faire un parcourt de $E$ : il suffit de parcourir la liste des points triés en se souvenant du dernier point retiré.
                
                Coût total de cette ligne : coût de $n$ supressions dans $E$.
                
                On aura aussi le coût de $n$ insertions dans $E$
                
                \vspace{12pt}
                
                $(**)$ nécessite une structure organisée selon les ordonnées : on peut choisir pour $E$ une structure d'ABR équilibrée : coût d'une insertion (suppression en $\mathcal O(\log n)$), coût de la recherche des (au plus) 5 éléments en $(**)$ : $\mathcal O(\log n)$ \boxed{\rm Exo}
                
                Au total $\mathcal O(n \log n)$.
            \end{indt}
        \end{indt}
        
    \end{indt}
    
    
    
\end{document}
%--------------------------------------------End
