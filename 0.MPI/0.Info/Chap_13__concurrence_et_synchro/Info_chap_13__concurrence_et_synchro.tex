\documentclass[a4paper, 12pt, twoside]{article}


%------------------------------------------------------------------------
%
% Author                :   Lasercata
% Last modification     :   2022.09.15
%
%------------------------------------------------------------------------


%------ini
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[french]{babel}
%\usepackage[english]{babel}


%------geometry
\usepackage[textheight=700pt, textwidth=500pt]{geometry}


%------color
\usepackage{xcolor}
\definecolor{ff4500}{HTML}{ff4500}
\definecolor{00f}{HTML}{0000ff}
\definecolor{0ff}{HTML}{00ffff}
\definecolor{656565}{HTML}{656565}

\renewcommand{\emph}{\textcolor{ff4500}}
\renewcommand{\em}{\color{ff4500}}

\newcommand{\strong}[1]{\textcolor{ff4500}{\bf #1}}
\newcommand{\st}{\color{ff4500}\bf}


%------Code highlighting
%---listings
\usepackage{listings}

\definecolor{cbg}{HTML}{272822}
\definecolor{cfg}{HTML}{ececec}
\definecolor{ccomment}{HTML}{686c58}
\definecolor{ckw}{HTML}{f92672}
\definecolor{cstring}{HTML}{e6db72}
\definecolor{cstringlight}{HTML}{98980f}
\definecolor{lightwhite}{HTML}{fafafa}

\lstdefinestyle{DarkCodeStyle}{
    backgroundcolor=\color{cbg},
    commentstyle=\itshape\color{ccomment},
    keywordstyle=\color{ckw},
    numberstyle=\tiny\color{cbg},
    stringstyle=\color{cstring},
    basicstyle=\ttfamily\footnotesize\color{cfg},
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    keepspaces=true,
    numbers=left,
    numbersep=5pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=4,
    xleftmargin=\leftskip
}

\lstdefinestyle{LightCodeStyle}{
    backgroundcolor=\color{lightwhite},
    commentstyle=\itshape\color{ccomment},
    keywordstyle=\color{ckw},
    numberstyle=\tiny\color{cbg},
    stringstyle=\color{cstringlight},
    basicstyle=\ttfamily\footnotesize\color{cbg},
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    keepspaces=true,
    numbers=left,
    numbersep=10pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=4,
    frame=L,
    xleftmargin=\leftskip
}

%\lstset{style=DarkCodeStyle}
\lstset{style=LightCodeStyle}
%Usage : \begin{lstlisting}[language=Caml] ... \end{lstlisting}

%---tcolorbox
\usepackage[many]{tcolorbox}
\DeclareTColorBox{pseudocode}{O{black}O{lightwhite}}{
    breakable,
    outer arc=0pt,
    arc=0pt,
    top=0pt,
    toprule=-.5pt,
    right=0pt,
    rightrule=-.5pt,
    bottom=0pt,
    bottomrule=-.5pt,
    colframe=#1,
    colback=#2,
    enlarge left by=10pt,
    width=\linewidth-\leftskip-10pt,
}


%-------make the table of content clickable
\usepackage{hyperref}
\hypersetup{
    colorlinks,
    citecolor=black,
    filecolor=black,
    linkcolor=black,
    urlcolor=black
}
%Uncomment this and comment above for dark mode
% \hypersetup{
%     colorlinks,
%     citecolor=white,
%     filecolor=white,
%     linkcolor=white,
%     urlcolor=white
% }


%------pictures
\usepackage{graphicx}
%\usepackage{wrapfig}

\usepackage{tikz}
%\usetikzlibrary{babel}             %Uncomment this to use circuitikz
%\usetikzlibrary{shapes.geometric}  % To draw triangles in trees
%\usepackage{circuitikz}            %Electrical circuits drawing


%------tabular
%\usepackage{color}
%\usepackage{colortbl}
%\usepackage{multirow}


%------Physics
%---Packages
%\usepackage[version=4]{mhchem} %$\ce{NO4^2-}$

%---Commands
\newcommand{\link}[2]{\mathrm{#1} \! - \! \mathrm{#2}}
\newcommand{\pt}[1]{\cdot 10^{#1}} % Power of ten
\newcommand{\dt}[2][t]{\dfrac{\mathrm d #2}{\mathrm d #1}} % Derivative


%------math
%---Packages
%\usepackage{textcomp}
%\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{mathtools} % For abs
\usepackage{stmaryrd} %for \llbracket and \rrbracket
\usepackage{mathrsfs} %for \mathscr{x} (different from \mathcal{x})

%---Commands
%-Sets
\newcommand{\N}{\mathbb{N}} %set N
\newcommand{\Z}{\mathbb{Z}} %set Z
\newcommand{\Q}{\mathbb{Q}} %set Q
\newcommand{\R}{\mathbb{R}} %set R
\newcommand{\C}{\mathbb{C}} %set C
\newcommand{\U}{\mathbb{U}} %set U
\newcommand{\seg}[2]{\left[ #1\ ;\ #2 \right]}
\newcommand{\nset}[2]{\left\llbracket #1\ ;\ #2 \right\rrbracket}

%-Exponantial / complexs
\newcommand{\e}{\mathrm{e}}
\newcommand{\cj}[1]{\overline{#1}} %overline for the conjugate.

%-Vectors
\newcommand{\vect}{\overrightarrow}
\newcommand{\veco}[3]{\displaystyle \vect{#1}\binom{#2}{#3}} %vector + coord

%-Limits
\newcommand{\lm}[2][{}]{\lim\limits_{\substack{#2 \\ #1}}} %$\lm{x \to a} f$ or $\lm[x < a]{x \to a} f$
\newcommand{\Lm}[3][{}]{\lm[#1]{#2} \left( #3 \right)} %$\Lm{x \to a}{f}$ or $\Lm[x < a]{x \to a}{f}$
\newcommand{\tendsto}[1]{\xrightarrow[#1]{}}

%-Integral
\newcommand{\dint}[4][x]{\displaystyle \int_{#2}^{#3} #4 \mathrm{d} #1} %$\dint{a}{b}{f(x)}$ or $\dint[t]{a}{b}{f(t)}$

%-left right
\newcommand{\lr}[1]{\left( #1 \right)}
\newcommand{\lrb}[1]{\left[ #1 \right]}
\newcommand{\lrbb}[1]{\left\llbracket #1 \right\rrbracket}
\newcommand{\set}[1]{\left\{ #1 \right\}}
\newcommand{\abs}[1]{\left\lvert #1 \right\rvert}
\newcommand{\ceil}[1]{\left\lceil #1 \right\rceil}
\newcommand{\floor}[1]{\left\lfloor #1 \right\rfloor}
\newcommand{\lrangle}[1]{\left\langle #1 \right\rangle}

%-Others
\newcommand{\para}{\ /\!/\ } %//
\newcommand{\ssi}{\ \Leftrightarrow \ }
\newcommand{\eqsys}[2]{\begin{cases} #1 \\ #2 \end{cases}}

\newcommand{\med}[2]{\mathrm{med} \left[ #1\ ;\ #2 \right]}  %$\med{A}{B} -> med[A ; B]$
\newcommand{\Circ}[2]{\mathscr{C}_{#1, #2}}

\renewcommand{\le}{\leqslant}
\renewcommand{\ge}{\geqslant}

\newcommand{\oboxed}[1]{\textcolor{ff4500}{\boxed{\textcolor{black}{#1}}}} %orange boxed


%------commands
%---to quote french text
\newcommand{\simplecit}[1]{\guillemotleft$\;$#1$\;$\guillemotright}
\newcommand{\cit}[1]{\simplecit{\textcolor{656565}{#1}}}
\newcommand{\quo}[1]{\cit{\it #1}}

%---to indent
\newcommand{\ind}[1][20pt]{\advance\leftskip + #1}
\newcommand{\deind}[1][20pt]{\advance\leftskip - #1}

%---to indent a text
\newcommand{\indented}[2][20pt]{\par \ind[#1] #2 \par \deind[#1]}
\newenvironment{indt}[2][20pt]{#2 \par \ind[#1]}{\par \deind} %Titled indented env

%---title
\newcommand{\thetitle}[2]{\begin{center}\textbf{{\LARGE \underline{\emph{#1} :}} {\Large #2}}\end{center}}

%---Maths environments
%-Proofs
\newenvironment{proof}[1][{}]{\begin{indt}{$\square$ #1}}{$\blacksquare$ \end{indt}}

%-Maths parts (proposition, definition, ...)
\newenvironment{mathspart}[1]{\begin{indt}{\boxed{\text{\textbf{#1}}}}}{\end{indt}}
\newenvironment{mathbox}[1]{\boxed{\text{\textbf{#1}}}\begin{pseudocode}}{\end{pseudocode}}
\newenvironment{mathul}[1]{\begin{indt}{\underline{\textbf{#1}}}}{\end{indt}}

\newenvironment{theo}{\begin{mathspart}{Théorème}}{\end{mathspart}}
\newenvironment{Theo}{\begin{mathbox}{Théorème}}{\end{mathbox}}
\newenvironment{theodef}{\begin{mathspart}{Théorème-définition}}{\end{mathspart}}

\newenvironment{prop}{\begin{mathspart}{Proposition}}{\end{mathspart}}
\newenvironment{Prop}{\begin{mathbox}{Proposition}}{\end{mathbox}}
\newenvironment{props}{\begin{mathspart}{Propriétés}}{\end{mathspart}}

\newenvironment{defi}{\begin{mathspart}{Définition}}{\end{mathspart}}
\newenvironment{meth}{\begin{mathspart}{Méthode}}{\end{mathspart}}

\newenvironment{Rq}{\begin{mathul}{Remarque :}}{\end{mathul}}
\newenvironment{Rqs}{\begin{mathul}{Remarques :}}{\end{mathul}}

\newenvironment{Ex}{\begin{mathul}{Exemple :}}{\end{mathul}}
\newenvironment{Exs}{\begin{mathul}{Exemples :}}{\end{mathul}}


%------Sections
% To change section numbering :
% \renewcommand\thesection{\Roman{section}}
% \renewcommand\thesubsection{\arabic{subsection})}
% \renewcommand\thesubsubsection{\textit \alph{subsubsection})}

% To start numbering from 0
% \setcounter{section}{-1}


%------page style
\usepackage{fancyhdr}
\usepackage{lastpage}

\setlength{\headheight}{18pt}
\setlength{\footskip}{50pt}

\pagestyle{fancy}
\fancyhf{}
\fancyhead[LE, RO]{\textit{\textcolor{black}{\today}}}
\fancyhead[RE, LO]{\large{\textsl{\emph{\texttt{\jobname}}}}}

\fancyfoot[RO, LE]{\textit{\texttt{\textcolor{black}{Page \thepage /}\pageref{LastPage}}}} %Change 'black' to 'white' for dark mode
\fancyfoot[LO, RE]{\includegraphics[scale=0.12]{/home/lasercata/Pictures/1.images_profil/logo/mieux/lasercata_logo_fly_fond_blanc.png}}

% For dark mode :
%/home/lasercata/Pictures/1.images_profil/logo/mieux/lasercata_logo_fly.png


%------init lengths
\setlength{\parindent}{0pt} %To avoid using \noindent everywhere.
\setlength{\parskip}{3pt}


%---------------------------------Begin Document
\begin{document}
    
    %For dark mode :
    % \pagecolor{black}
    % \color{white}
    
    \thetitle{Chapitre 13}{Concurrence et synchronisation}
    
    \tableofcontents
    \newpage
    
    
    \begin{indt}{\section{Introduction}}
        \begin{indt}{\subsection{Motivation}}
            \begin{indt}{\subsubsection{Rappel (chap.2, 1.1.1)}}
                Un programme en cours d'exécution dispose d'un espace mémoire dédié organisé comme suit :

                \begin{center}
                    \begin{tabular}{|c|}
                        \hline
                        code
                        \\
                        \hline
                        données
                        \\
                        \hline
                        tas
                        \\
                        $\downarrow$
                        \\
                        \hline
                        $\uparrow$
                        \\
                        stack
                        \\
                        \hline
                    \end{tabular}
                \end{center}

                Le tas (\textit{heap}) est la zone mémoire qui contient les données allouées dynamiquement.

                La pile (\textit{stack}) contient toutes les données liées à la gestion des appels de fonction.

                Dans ce chapitre, un programme en cours d'exécution sera appelé \textit{processus} et le terme \textit{programme} fera référence au code.
            \end{indt}

            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Concurrence}}
                En pratique dans un ordinateur, il y a plusieurs processus actifs simultanément, qui doivent se partager les ressources de la machine (mémoire, entrées/sorties, unité de calcul).

                Le programme de MPI se limite à l'étude de machines ayant une unique unité de calcul.
                En particulier, cela signifie qu'il ne peut pas y avoir plusieurs processus actifs en même temps.

                Pour contourner ce problème, le système met es place une alternance de processus : on exécute quelques instructions d'un processus avant de changer de contexte pour exécuter un autre processus. Si les changements de contexte sont assez rapides, l'utilisateur a l'impression d'une vraie exécution parallèle.

                Problème : les changements de contexte sont lents.
                De plus, deux processus ne sont pas forcément indépendants.

                Exemple : Louis tape ses cours en \LaTeX{}, et doit exécuter un compilateur pour obtenir un document PDF. Il peut alors le visionner à l'aide d'un autre programme qui lit dans la même zone mémoire que celle où le compilateur écrit.
                À chaque mise à jour, le programme de lecture doit rafraîchir l'affichage.
            \end{indt}

            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Non déterminisme et synchronisation}}
                \label{1.1.3}

                L'exécution de processus concurrents est non déterministe car on ne peut pas faire l'hypothèse sur l'ordre d'exécution des instructions et des changements de contextes.
                En effet, le système d'exploitation, \textit{via} un programme appelé \textit{ordonnanceur}, décide es changements de contexte selon des critères variés (horloge, événement provoqués par l'utilisateur, attente de données qui proviennent de la mémoire, \dots)

                Ce non-déterminisme implique la nécessité de synchroniser certains processus.

                \vspace{6pt}
                
                Par exemple, on considère deux processus concurrents qui exécutent le même programme.

                Le code est le suivant :

                \begin{pseudocode}
                    \begin{indt}{Répéter 100 fois :}
                        Lire l'entier $n$ dans le fichier ``\texttt{toto.txt}"

                        Écraser le fichier ``\texttt{toto.txt}" en y écrivant $n + 1$
                    \end{indt}
                \end{pseudocode}

                On suppose qu'initialement, le fichier contient l'entier $0$.
                Quel est le résultat final ?

                C'est une valeur de $\nset{100}{200}$ car un processus peut être interrompu juste après une lecture et l'écriture qui suivra la reprise de son exécution écrasera tous les changements faits par le second processus).
            \end{indt}
        \end{indt}

        \vspace{12pt}
        
        \begin{indt}{\subsection{Définition et objectifs}}
            \begin{indt}{\subsubsection{Fil d'exécution (\textit{thread})}}
                Dans certains cas, un processus peut être amené à effectuer plusieurs tâches, que l'on pourrait vouloir répartir sur plusieurs processus.
                Si les tâches ne sont pas indépendantes, on peut être amené à faire de nombreux changements de contexte qui peuvent être coûteux.

                Il faut de plus un moyen de communication entre ces processus, qui peut être une interruption système (le système d'exploitation sert de messager) ou un partage de mémoire.

                En réalité, un processus peut contenir plusieurs fils d'exécution ou processus légers qui partagent une partie de la mémoire du processus.
                Ces fils d'exécution ont un programme commun mais l'exécutent en des points différents.

                La structure de la mémoire d'un processus devient la suivante :

                \begin{center}
                    \begin{tikzpicture}
                        \node (c) at (0, 0) {code};
                        \node (d) at (0, -1) {données};
                        \node (t) at (0, -2) {tas};

                        \draw[->] (t) to (0, -3);

                        \node (p1) at (-2, -5) {pile};
                        \draw[->] (p1) to (-2, -4);

                        \node (p2) at (0, -5) {pile};
                        \draw[->] (p2) to (0, -4);

                        \node (p3) at (2, -5) {pile};
                        \draw[->] (p3) to (2, -4);

                        \node at (-2, -6) {registres};
                        \node at (0, -6) {registres};
                        \node at (1.8, -5.8) {registres};

                        \draw (-3, .3) rectangle (3, -6.5);
                        \draw (-3, -.5) -- (3, -.5);
                        \draw (-3, -1.5) -- (3, -1.5);
                        \draw (-3, -3.5) -- (3, -3.5);
                        \draw (-3, -5.5) -- (3, -5.5);

                        \draw (-1, -3.5) -- (-1, -6.5);
                        \draw (1, -3.5) -- (1, -6.5);

                        \node (f) at (0, -8) {3 fils};

                        \draw[->] (f) to (-2, -6.7);
                        \draw[->] (f) to (0, -6.7);
                        \draw[->] (f) to (2, -6.7);

                        \node (i) at (2.6, -6.2) [rectangle, draw] {$_{\text{\tiny{IP}}}$};

                        \draw[-latex] (i) to [out=45, in=-45] (3, 0);

                        \node at (6, -6) {IP : instruction pointer};
                    \end{tikzpicture}
                \end{center}

                \vspace{12pt}
                
                Limitations du programme :

                $\bullet$ On étudie les fils d'exécution d'un unique processus ;

                $\bullet$ On se limite uniquement à la norme POSIX ;

                \begin{indt}{$\bullet$ On s'autorise uniquement deux primitives sur les fils d'exécutions :}
                    $-$ \texttt{create} : prend une fonction et des paramètres pour cette fonction et crée un nouveau fil d'exécution pour le processus courant, chargé d'évaluer la fonction sur les paramètres ;

                    $-$ \texttt{join} : prend l'identifiant d'un file d'exécution en paramètre et interrompt le fil courant jusqu'à terminaison du fil passé en argument.
                \end{indt}
            \end{indt}

            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Situation de compétition et atomicité}}
                Un \textit{situation de compétition} (\textit{race condition}) a lieu quand le résultat d'un processus varie selon l'ordre d'exécution de ses fils. L'exemple vu en \ref{1.1.3} (page \pageref{1.1.3}) est une situation de compétition que l'on eput reproduire avec les fils d'un unique processus partageant une variable globale.
                Un fil principal est chargé de créer deux fils secondaires qui exécutent la boucle.
                Il doit attendre la terminaison des fils secondaires (opération \texttt{join}) avant de s'arrêter pour éviter une interruption prématurée du programme.

                Dans un cas comme celui-ci, on peut résoudre le problème en imposant \textit{l'atomicité} du corps de la boucle. Un ensemble d'instructions est \textit{atomique} si le système ne peut pas interrompre leur exécution. Ici, on ne voit pas d'interruption entre la lecture et l'écriture.
            \end{indt}

            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Section critique}}
                Dans l'exemple précédent, l'atomicité est une condition trop forte : on peut interrompre un fil entre la lecture et l'écriture tant que l'autre fil ne lit et n'écrit pas dans la variable.

                On dit que le corps de la boucle est une \textit{section critique} du programme.

                On veut garantir l'exclusion mutuelle pour les secteurs critiques, \textit{i.e} il ne peut y avoir qu'un seul fil qui exécute une section critique à chaque instant.

                Une solution de synchronisation doit aussi garantir le progrès de l'exécution : si un fil souhaite entrer en section critique et si celle-ci est libre, le choix d'un fil entrant en section critique ne doit pas pouvoir être retardé indéfiniment.

                On veut aussi assurer un temps d'attente borné : il doit y avoir une borne sur le nombre de fois que d'autres fils d'exécution entrent en section critique entre le moment où un fil signale qu'il souhaite entrer en section critique et son entrée effective.
            \end{indt}

            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Interblocage (\textit{deadlock}) et famine}}
                Si la synchronisation des fils d'exécution n'est pas effectuée correctement, il peut y avoir plusieurs problèmes, dont :

                $\bullet$ l'interblocage : on dit qu'il y a \textit{interblocage} lorsque plusieurs fils attendent un événement qui ne peut être provoqué que par l'un des fils en attente.

                Exemple classique : le dîner des philosophes.

                Des philosophes sont réunis autour d'une table ronde, et on deux activités : manger et penser.
                Pour manger, un philosophe doit disposer de deux baguettes.
                Les baguettes sont réparties comme suit : il y en a une entre chaque couple de philosophe voisins.

                Si les philosophes exécutent le programme suivant :

                \begin{pseudocode}
                    Prendre la baguette à gauche

                    Prendre la baguette à droite

                    Manger

                    Poser les baguettes

                    Penser
                \end{pseudocode}

                Il peut y avoir unterblocage si chaque philosophe a pris la baguette à sa gauche et attend que son voisin de droite libère l'autre.

                \vspace{6pt}
                
                $\bullet$ La \textit{famine} a lieu lorsqu'un fil d'exécution attend indéfiniment l'accès à une ressource.

                Exemple classique : le problème des producteurs-consommateurs.

                Des producteurs remplissent un buffer que les consommateurs vident.

                Règles : une donnée ne peut être lue qu'une fois, on ne peut pas écraser une donnée qui n'a pas été lue, et une case vide ne peut pas être lue.

                Si l'accès au buffer n'est pas équitable (par exemple une priorité selon les identifiants des fils d'exécution), un fil peut être amené à attendre indéfiniment.

                Par exemple : un producteur très lent, deux consommateurs très rapides : chaque fois que le producteur écrit dans le buffer, le fil consommateur n°1 récupère la donnée et reprend son attente, le fil n°2 n'accède jamais aux données.
            \end{indt}

            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Remarque}}
                Nous allons voir plusieurs outils de synchronisation permettant l'établissement de sections critiques.
                \begin{indt}{Ces outils peuvent être de plusieurs natures :}
                    $\bullet$ Algorithmique : nous verrons deux algorithmes permettant de travailler avec deux fils d'exécution (algorithme de \textsc{Petersen}) ou plus (algorithme de la boulangerie de \textsc{Lamport})

                    Ces algorithmes nécessitent une attente active des fils d'exécution : ils bouclent en ne faisant rien en attendant la réalisation d'une condition.

                    $\bullet$ Des primitives de programmation directement fournies par le système (mutex et sémaphore) qui permettent l'interruption d'un fil en attendant la réalisation d'une condition plutôt qu'une attente active.
                \end{indt}
            \end{indt}
        \end{indt}

        \vspace{12pt}
        
        \begin{indt}{\subsection{Syntaxe de la manipulation des fils d'exécution}}
            \begin{indt}{\subsubsection{En OCaml}}
                On utilise le module \texttt{Thread}, qui propose les objets suivants :

                $\bullet$ le type \texttt{Thread.t} qui représente les fils d'exécution ;

                $\bullet$ la fonction \texttt{Thread.create : ('a -> 'b) -> 'a -> Thread.t} qui, étant donné une fonction \texttt{f : 'a -> 'b} et un argument \texttt{x : 'a}, crée et renvoie un fil d'exécution pour le processus courant, chargé d'évaluer \texttt{f x}.
                Le résultat de la fonction est ignoré, et en pratique, on utilise des fonctions de type \texttt{'a -> unit} qui font des effets de bord ;

                $\bullet$ la fonction \texttt{Thread.join : Thread.t -> unit} qui prend un fil \texttt p en argument et qui interrompt le fil courant jusqu'à terminaison de \texttt p.

                \vspace{12pt}
                
                Pour compiler un programme utilisant ce module, on exécute une ligne de la forme
                \begin{center}
                    \texttt{ocamlc -I +threads unix.cma threads.cma fichier.ml -o programme}
                \end{center}
            \end{indt}

            \vspace{12pt}
            
            \begin{indt}{\subsubsection{En C}}
                On inclut l'en-tête \texttt{pthread.h}.

                Cela donne accès à :

                $\bullet$  un type \texttt{pthread\_t} qui représente les fils d'exécution ;

                $\bullet$ une fonction de prototype

                \begin{lstlisting}[language=C, xleftmargin=80pt]
int pthread_create(pthread_t* p, const pthread_attr_t* attr, void* (*f)(void*), void* args)\end{lstlisting}

                \begin{indt}{où}
                    $-$ \texttt p est un pointeur permettant de stocker le fil créé ;

                    $-$ \texttt{attr} est H.P et sera toujours \texttt{NULL} ;

                    $-$ \texttt f et \texttt{args} représentent la fonction que le nouveau fil doit exécuter et ses arguments.
                \end{indt}

                \vspace{12pt}
                
                Pourquoi \texttt{void*} ?

                Pas de fonction d'ordre supérieur et pas de polymorphisme mais il est possible d'effectuer du transtypage vers et depuis \texttt{void*}.

                On pourra se contenter de définir une fonction de type \texttt{void* f(void*)} et de la passer directement en argument.
                Si \texttt f n'a aucun argument, \texttt{args} sera \texttt{NULL}.

                L'entier renvoyé est un code d'erreur qui vaut 0 si tout s'est bien passé. On adoptera un style défensif et on vérifiera la valeur de cet entier.

                \vspace{12pt}
                
                $\bullet$ La fonction de prototype

                \begin{lstlisting}[language=C, xleftmargin=80pt]
int pthread_join(pthread_t p, void** res)\end{lstlisting}

                où \texttt p est le fil d'exécution dont le fil courant doit attendre la terminaison, et \texttt{res} est H.P et sera toujours \texttt{NULL} (permet de récupérer le résultat de la fonction \texttt f).

                L'entier en retour a la même signification que dans la fonction \texttt{pthread\_create}.

                \vspace{12pt}
                
                La compilation d'un programme utilisant cette bibliothèque est de la forme :

                \begin{center}
                    \texttt{gcc -lpthread file.c - o prog}
                \end{center}
            \end{indt}
        \end{indt}
    \end{indt}

    \vspace{12pt}
    
    \begin{indt}{\section{Outils algorithmiques de synchronisation}}
        \begin{indt}{\subsection{Algorithme de \textsc{Petersen}}}
            \begin{indt}{\subsubsection{Introduction}}
                Conçut en 1981, cet algorithme permet l'établissement d'une section critique garantissant l'exclusion mutuelle, l'absence de famine et l'absence d'interblocage.

                Cependant, il nécessite une attente active de la part des fils d'exécution et est limité à deux fils concurrents, ce qui en fait un algorithme peu utilisé en pratique.

                Avant de l'étudier, nous allons voir des versions plus simples, mais qui échouent.
            \end{indt}

            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Première tentative}}
                On utilise un booléen associé à chaque fil d'exécution indiquant s'il est en section critique.
                Un fil souhaitant entrer en section critique attend que l'autre n'y soit plus puis met son booléen à jour.
                En sortie de section critique, un fil doit mettre son booléen à jour.

                \textit{cf} \texttt{petersen\_0.c}.

                Problème : si un fil est interrompu entre la fin de son attente active et la mise à jour de son booléen, il n'y a plus forcément exclusion mutuelle.
            \end{indt}

            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Deuxième tentative}}
                Le problème de la première version vient du fait que la mise à jour du booléen est trop tardive. On pourrait plutôt signaler la volonté d'entrer en section critique : le booléen est mis à jour avant l'attente et un fil souhaitant entrer en section critique attend que l'autre fil ne veuille plus y être.

                Problème : si un fil est interrompu entre la mise à jour de son booléen et le début de son attente, on peut atteindre une situation de blocage où les deux booléens valent \texttt{true}.

                \textit{cf} \texttt{petersen\_1.c}
            \end{indt}

            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Troisième tentative}}
                On utilise plutôt une variable indiquant quel fil d'exécution peut entrer en section critique.
                Lorsqu'un fil quitte la section critique, il indique que c'est au tour de l'autre fil.

                \textit{cf} \texttt{petersen\_2.c}.

                Problème : si un fil termine son exécution avant l'autre, lorsque le second fil indique que c'est au tour du fil qui s'est arrêté, son tour ne reviendra jamais, il est donc en situation de famine.
            \end{indt}

            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Algorithme de \textsc{Petersen}}}
                On combine les deux dernières tentatives : un fil peut entrer en section critique si c'est à son tour ou si l'autre fil ne souhaite pas entrer en section critique.

                \textit{cf} \texttt{petersen\_final.c}

                Pseudo code :

                \begin{pseudocode}
                    \texttt{turn} $\leftarrow 0$

                    \texttt{want} $\leftarrow$ \texttt{[false, false]}

                    \begin{indt}{Thread $i$ :}
                        \texttt{want[$i$]} $\leftarrow$ \texttt{true}

                        \texttt{turn} $\leftarrow 1 - i$

                        \begin{indt}{while \texttt{want[$1 - i$] \&\& turn = $1 - i$}}
                            wait
                        \end{indt}

                        \textit{\textcolor{656565}{//Critical section}}

                        \texttt{wait[$i$]} $\leftarrow$ \texttt{false}
                    \end{indt}
                \end{pseudocode}

                \vspace{12pt}
                
                $\bullet$ Proposition : l'algorithme de \textsc{Petersen} garantit l'exclusion mutuelle.

                \begin{proof}
                    Par l'absurde, supposons que les fils 0 et 1 sont en section critique.

                    Sans perte de généralité, on suppose que le fil 0 est entré en section critique en premier.

                    Au moment de l'entrée en section critique du fil 1, on sait que \texttt{want[0]} vaut toujours \texttt{true} donc que \texttt{turn} vaut 1.

                    Ainsi, le fil 1 a du être interrompu entre l'affectation \texttt{turn} $\leftarrow 0$ et la boucle d'attente pour permettre l'entrée en section critique du fil 0 (s'il avait été interrompu avant, l'affectation \texttt{turn} $\leftarrow 0$ empêcherait son entrée en section critique).

                    Lorsque le fil 0 effectue l'affectation \texttt{turn} $\leftarrow 1$, il ne peut plus entrer en section critique car \texttt{want[1]} vaut \texttt{true} : absurde
                \end{proof}

                \vspace{12pt}
                
                $\bullet$ Proposition : l'algorithme de \textsc{Petersen} garantit le progrès de l'exécution et le temps d'attente borné pour les fils d'exécution.

                \begin{proof}
                    Supposons que le fil 0 veuille entrer en section critique.

                    Si le fil 0 est en attente, c'est que \texttt{want[1]} vaut \texttt{true}, et \texttt{turn} vaut 1.

                    Dans ce contexte, le fil 1 peut être dans plusieurs états :

                    $-$ le fil 1 se situe juste après l'affectation \texttt{want[1]} $\leftarrow$ \texttt{true}. Dans ce cas, on a l'affectation \texttt{turn} $\leftarrow 0$, le fil 1 se met en attente (on a aussi \texttt{want[0]} qui vaut \texttt{true}) et le fil 0 peut entrer en section critique ;

                    $-$ le fil 1 se situe à la boucle d'attente entre le moment où le fil 0 effectue l'affectation \texttt{want[0]} $\leftarrow$ \texttt{true} et l'affectation \texttt{turn} $\leftarrow 1$.

                    Dans ce cas, lorsqu'il reprend son exécution, le fil 1 entre en section critique.
                    \begin{indt}{Lorsqu'il sort de section critique, on a \texttt{want[1] = false} et il y a deux possibilités :}
                        (1) le fil 0 reprend son exécution et entre en section critique ;

                        (2) le fil 1 poursuit son exécution et tente à nouveau d'entrer en section critique.

                        \texttt{want[1]} redevient \texttt{true}, mais le fil 1 finira par exécuter l'affectation \texttt{turn} $\leftarrow 0$ et le fil 1 se met en attente et le fil 0 entre en section critique
                    \end{indt}

                    $-$ le fil 1 se situe à la boucle d'attente avant l'affectation \texttt{want[0]} $\leftarrow$ \texttt{true}.

                    Le fil 1 est donc en section critique, et comme avant, ne fera qu'un passage en section critique avant de céder la place au fil 0.

                    Le même raisonnement s'applique au fil 1 par symétrie.

                    On en déduit que l'exécution progresse toujours et qu'un fil d'exécution souhaitant entrer en section critique attendra au plus un passage de l'autre fil en section critique.
                \end{proof}

                \vspace{12pt}
                
                $\bullet$ Remarque : la proposition précédente assure l'absence de famine, donc d'interblocage.
            \end{indt}
        \end{indt}

        \vspace{12pt}
        
        \begin{indt}{\subsection{Algorithme de la boulangerie de \textsc{Lamport}}}
            \begin{indt}{\subsubsection{Introduction}}
                Conçut en en 1974, cet algorithme permet également la mise en place d'une section critique avec les mêmes propriétés.

                Il est aussi basé sur l'attente active, mais permet l'utilisation de plus de 2 fils.

                Il existe des solutions plus efficaces que donc algorithme n'a qu'un intérêt théorique.
            \end{indt}
        \end{indt}
    \end{indt}
    
    
    
\end{document}
%--------------------------------------------End
