\documentclass[a4paper, 12pt, twoside]{article}


%------------------------------------------------------------------------
%
% Author                :   Lasercata
% Last modification     :   2022.09.13
%
%------------------------------------------------------------------------


%------ini
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[french]{babel}
%\usepackage[english]{babel}


%------geometry
\usepackage[textheight=700pt, textwidth=500pt]{geometry}


%------color
\usepackage{xcolor}
\definecolor{ff4500}{HTML}{ff4500}
\definecolor{00f}{HTML}{0000ff}
\definecolor{0ff}{HTML}{00ffff}
\definecolor{656565}{HTML}{656565}

\renewcommand{\emph}{\textcolor{ff4500}}
\renewcommand{\em}{\color{ff4500}}

\newcommand{\strong}[1]{\textcolor{ff4500}{\bf #1}}
\newcommand{\st}{\color{ff4500}\bf}


%------Code highlighting
%---listings
\usepackage{listings}

\definecolor{cbg}{HTML}{272822}
\definecolor{cfg}{HTML}{ececec}
\definecolor{ccomment}{HTML}{686c58}
\definecolor{ckw}{HTML}{f92672}
\definecolor{cstring}{HTML}{e6db72}
\definecolor{cstringlight}{HTML}{98980f}
\definecolor{lightwhite}{HTML}{fafafa}

\lstdefinestyle{DarkCodeStyle}{
    backgroundcolor=\color{cbg},
    commentstyle=\itshape\color{ccomment},
    keywordstyle=\color{ckw},
    numberstyle=\tiny\color{cbg},
    stringstyle=\color{cstring},
    basicstyle=\ttfamily\footnotesize\color{cfg},
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    keepspaces=true,
    numbers=left,
    numbersep=5pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=4,
    xleftmargin=\leftskip
}

\lstdefinestyle{LightCodeStyle}{
    backgroundcolor=\color{lightwhite},
    commentstyle=\itshape\color{ccomment},
    keywordstyle=\color{ckw},
    numberstyle=\tiny\color{cbg},
    stringstyle=\color{cstringlight},
    basicstyle=\ttfamily\footnotesize\color{cbg},
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    keepspaces=true,
    numbers=left,
    numbersep=10pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=4,
    frame=L,
    xleftmargin=\leftskip
}

%\lstset{style=DarkCodeStyle}
\lstset{style=LightCodeStyle}
%Usage : \begin{lstlisting}[language=Caml] ... \end{lstlisting}

%---tcolorbox
\usepackage[many]{tcolorbox}
\DeclareTColorBox{pseudocode}{O{black}O{lightwhite}}{
    breakable,
    outer arc=0pt,
    arc=0pt,
    top=0pt,
    toprule=-.5pt,
    right=0pt,
    rightrule=-.5pt,
    bottom=0pt,
    bottomrule=-.5pt,
    colframe=#1,
    colback=#2,
    enlarge left by=10pt,
    width=\linewidth-\leftskip-10pt,
}


%-------make the table of content clickable
\usepackage{hyperref}
\hypersetup{
    colorlinks,
    citecolor=black,
    filecolor=black,
    linkcolor=black,
    urlcolor=black
}
%Uncomment this and comment above for dark mode
% \hypersetup{
%     colorlinks,
%     citecolor=white,
%     filecolor=white,
%     linkcolor=white,
%     urlcolor=white
% }


%------pictures
\usepackage{graphicx}
%\usepackage{wrapfig}

\usepackage{tikz}
%\usetikzlibrary{babel}             %Uncomment this to use circuitikz
%\usetikzlibrary{shapes.geometric}  % To draw triangles in trees
%\usepackage{circuitikz}            %Electrical circuits drawing


%------tabular
%\usepackage{color}
%\usepackage{colortbl}
%\usepackage{multirow}


%------Physics
%---Packages
%\usepackage[version=4]{mhchem} %$\ce{NO4^2-}$

%---Commands
\newcommand{\link}[2]{\mathrm{#1} \! - \! \mathrm{#2}}
\newcommand{\pt}[1]{\cdot 10^{#1}} % Power of ten
\newcommand{\dt}[2][t]{\dfrac{\mathrm d #2}{\mathrm d #1}} % Derivative


%------math
%---Packages
%\usepackage{textcomp}
%\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{mathtools} % For abs
\usepackage{stmaryrd} %for \llbracket and \rrbracket
\usepackage{mathrsfs} %for \mathscr{x} (different from \mathcal{x})

%---Commands
%-Sets
\newcommand{\N}{\mathbb{N}} %set N
\newcommand{\Z}{\mathbb{Z}} %set Z
\newcommand{\Q}{\mathbb{Q}} %set Q
\newcommand{\R}{\mathbb{R}} %set R
\newcommand{\C}{\mathbb{C}} %set C
\newcommand{\U}{\mathbb{U}} %set U
\newcommand{\seg}[2]{\left[ #1\ ;\ #2 \right]}
\newcommand{\nset}[2]{\left\llbracket #1\ ;\ #2 \right\rrbracket}

%-Exponantial / complexs
\newcommand{\e}{\mathrm{e}}
\newcommand{\cj}[1]{\overline{#1}} %overline for the conjugate.

%-Vectors
\newcommand{\vect}{\overrightarrow}
\newcommand{\veco}[3]{\displaystyle \vect{#1}\binom{#2}{#3}} %vector + coord

%-Limits
\newcommand{\lm}[2][{}]{\lim\limits_{\substack{#2 \\ #1}}} %$\lm{x \to a} f$ or $\lm[x < a]{x \to a} f$
\newcommand{\Lm}[3][{}]{\lm[#1]{#2} \left( #3 \right)} %$\Lm{x \to a}{f}$ or $\Lm[x < a]{x \to a}{f}$
\newcommand{\tendsto}[1]{\xrightarrow[#1]{}}

%-Integral
\newcommand{\dint}[4][x]{\displaystyle \int_{#2}^{#3} #4 \mathrm{d} #1} %$\dint{a}{b}{f(x)}$ or $\dint[t]{a}{b}{f(t)}$

%-left right
\newcommand{\lr}[1]{\left( #1 \right)}
\newcommand{\lrb}[1]{\left[ #1 \right]}
\newcommand{\lrbb}[1]{\left\llbracket #1 \right\rrbracket}
\newcommand{\set}[1]{\left\{ #1 \right\}}
\newcommand{\abs}[1]{\left\lvert #1 \right\rvert}
\newcommand{\ceil}[1]{\left\lceil #1 \right\rceil}
\newcommand{\floor}[1]{\left\lfloor #1 \right\rfloor}
\newcommand{\lrangle}[1]{\left\langle #1 \right\rangle}

%-Others
\newcommand{\para}{\ /\!/\ } %//
\newcommand{\ssi}{\ \Leftrightarrow \ }
\newcommand{\eqsys}[2]{\begin{cases} #1 \\ #2 \end{cases}}

\newcommand{\med}[2]{\mathrm{med} \left[ #1\ ;\ #2 \right]}  %$\med{A}{B} -> med[A ; B]$
\newcommand{\Circ}[2]{\mathscr{C}_{#1, #2}}

\renewcommand{\le}{\leqslant}
\renewcommand{\ge}{\geqslant}

\newcommand{\oboxed}[1]{\textcolor{ff4500}{\boxed{\textcolor{black}{#1}}}} %orange boxed


%------commands
%---to quote french text
\newcommand{\simplecit}[1]{\guillemotleft$\;$#1$\;$\guillemotright}
\newcommand{\cit}[1]{\simplecit{\textcolor{656565}{#1}}}
\newcommand{\quo}[1]{\cit{\it #1}}

%---to indent
\newcommand{\ind}[1][20pt]{\advance\leftskip + #1}
\newcommand{\deind}[1][20pt]{\advance\leftskip - #1}

%---to indent a text
\newcommand{\indented}[2][20pt]{\par \ind[#1] #2 \par \deind[#1]}
\newenvironment{indt}[2][20pt]{#2 \par \ind[#1]}{\par \deind} %Titled indented env

%---title
\newcommand{\thetitle}[2]{\begin{center}\textbf{{\LARGE \underline{\emph{#1} :}} {\Large #2}}\end{center}}

%---Maths environments
%-Proofs
\newenvironment{proof}[1][{}]{\begin{indt}{$\square$ #1}}{$\blacksquare$ \end{indt}}

%-Maths parts (proposition, definition, ...)
\newenvironment{mathspart}[1]{\begin{indt}{\boxed{\text{\textbf{#1}}}}}{\end{indt}}
\newenvironment{mathbox}[1]{\boxed{\text{\textbf{#1}}}\begin{pseudocode}}{\end{pseudocode}}
\newenvironment{mathul}[1]{\begin{indt}{\underline{\textbf{#1}}}}{\end{indt}}

\newenvironment{theo}{\begin{mathspart}{Théorème}}{\end{mathspart}}
\newenvironment{Theo}{\begin{mathbox}{Théorème}}{\end{mathbox}}
\newenvironment{theodef}{\begin{mathspart}{Théorème-définition}}{\end{mathspart}}

\newenvironment{prop}{\begin{mathspart}{Proposition}}{\end{mathspart}}
\newenvironment{Prop}{\begin{mathbox}{Proposition}}{\end{mathbox}}
\newenvironment{props}{\begin{mathspart}{Propriétés}}{\end{mathspart}}

\newenvironment{defi}{\begin{mathspart}{Définition}}{\end{mathspart}}
\newenvironment{meth}{\begin{mathspart}{Méthode}}{\end{mathspart}}

\newenvironment{Rq}{\begin{mathul}{Remarque :}}{\end{mathul}}
\newenvironment{Rqs}{\begin{mathul}{Remarques :}}{\end{mathul}}

\newenvironment{Ex}{\begin{mathul}{Exemple :}}{\end{mathul}}
\newenvironment{Exs}{\begin{mathul}{Exemples :}}{\end{mathul}}


%------Sections
% To change section numbering :
% \renewcommand\thesection{\Roman{section}}
% \renewcommand\thesubsection{\arabic{subsection})}
% \renewcommand\thesubsubsection{\textit \alph{subsubsection})}

% To start numbering from 0
% \setcounter{section}{-1}


%------page style
\usepackage{fancyhdr}
\usepackage{lastpage}

\setlength{\headheight}{18pt}
\setlength{\footskip}{50pt}

\pagestyle{fancy}
\fancyhf{}
\fancyhead[LE, RO]{\textit{\textcolor{black}{\today}}}
\fancyhead[RE, LO]{\large{\textsl{\emph{\texttt{\jobname}}}}}

\fancyfoot[RO, LE]{\textit{\texttt{\textcolor{black}{Page \thepage /}\pageref{LastPage}}}} %Change 'black' to 'white' for dark mode
\fancyfoot[LO, RE]{\includegraphics[scale=0.12]{/home/lasercata/Pictures/1.images_profil/logo/mieux/lasercata_logo_fly_fond_blanc.png}}

% For dark mode :
%/home/lasercata/Pictures/1.images_profil/logo/mieux/lasercata_logo_fly.png


%------init lengths
\setlength{\parindent}{0pt} %To avoid using \noindent everywhere.
\setlength{\parskip}{3pt}


%---------------------------------Begin Document
\begin{document}
    
    %For dark mode :
    % \pagecolor{black}
    % \color{white}
    
    \thetitle{Chapitre 13}{Concurrence et synchronisation}
    
    \tableofcontents
    \newpage
    
    
    \begin{indt}{\section{Introduction}}
        \begin{indt}{\subsection{Motivation}}
            \begin{indt}{\subsubsection{Rappel (chap.2, 1.1.1)}}
                Un programme en cours d'exécution dispose d'un espace mémoire dédié organisé comme suit :

                \begin{center}
                    \begin{tabular}{|c|}
                        \hline
                        code
                        \\
                        \hline
                        données
                        \\
                        \hline
                        tas
                        \\
                        $\downarrow$
                        \\
                        \hline
                        $\uparrow$
                        \\
                        stack
                        \\
                        \hline
                    \end{tabular}
                \end{center}

                Le tas (\textit{heap}) est la zone mémoire qui contient les données allouées dynamiquement.

                La pile (\textit{stack}) contient toutes les données liées à la gestion des appels de fonction.

                Dans ce chapitre, un programme en cours d'exécution sera appelé \textit{processus} et le terme \textit{programme} fera référence au code.
            \end{indt}

            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Concurrence}}
                En pratique dans un ordinateur, il y a plusieurs processus actifs simultanément, qui doivent se partager les ressources de la machine (mémoire, entrées/sorties, unité de calcul).

                Le programme de MPI se limite à l'étude de machines ayant une unique unité de calcul.
                En particulier, cela signifie qu'il ne peut pas y avoir plusieurs processus actifs en même temps.

                Pour contourner ce problème, le système met es place une alternance de processus : on exécute quelques instructions d'un processus avant de changer de contexte pour exécuter un autre processus. Si les changements de contexte sont assez rapides, l'utilisateur a l'impression d'une vraie exécution parallèle.

                Problème : les changements de contexte sont lents.
                De plus, deux processus ne sont pas forcément indépendants.

                Exemple : Louis tape ses cours en \LaTeX{}, et doit exécuter un compilateur pour obtenir un document PDF. Il peut alors le visionner à l'aide d'un autre programme qui lit dans la même zone mémoire que celle où le compilateur écrit.
                À chaque mise à jour, le programme de lecture doit rafraîchir l'affichage.
            \end{indt}

            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Non déterminisme et synchronisation}}
                \label{1.1.3}

                L'exécution de processus concurrents est non déterministe car on ne peut pas faire l'hypothèse sur l'ordre d'exécution des instructions et des changements de contextes.
                En effet, le système d'exploitation, \textit{via} un programme appelé \textit{ordonnanceur}, décide es changements de contexte selon des critères variés (horloge, événement provoqués par l'utilisateur, attente de données qui proviennent de la mémoire, \dots)

                Ce non-déterminisme implique la nécessité de synchroniser certains processus.

                \vspace{6pt}
                
                Par exemple, on considère deux processus concurrents qui exécutent le même programme.

                Le code est le suivant :

                \begin{pseudocode}
                    \begin{indt}{Répéter 100 fois :}
                        Lire l'entier $n$ dans le fichier ``\texttt{toto.txt}"

                        Écraser le fichier ``\texttt{toto.txt}" en y écrivant $n + 1$
                    \end{indt}
                \end{pseudocode}

                On suppose qu'initialement, le fichier contient l'entier $0$.
                Quel est le résultat final ?

                C'est une valeur de $\nset{100}{200}$ car un processus peut être interrompu juste après une lecture et l'écriture qui suivra la reprise de son exécution écrasera tous les changements faits par le second processus).
            \end{indt}
        \end{indt}

        \vspace{12pt}
        
        \begin{indt}{\subsection{Définition et objectifs}}
            \begin{indt}{\subsubsection{Fil d'exécution (\textit{thread})}}
                Dans certains cas, un processus peut être amené à effectuer plusieurs tâches, que l'on pourrait vouloir répartir sur plusieurs processus.
                Si les tâches ne sont pas indépendantes, on peut être amené à faire de nombreux changements de contexte qui peuvent être coûteux.

                Il faut de plus un moyen de communication entre ces processus, qui peut être une interruption système (le système d'exploitation sert de messager) ou un partage de mémoire.

                En réalité, un processus peut contenir plusieurs fils d'exécution ou processus légers qui partagent une partie de la mémoire du processus.
                Ces fils d'exécution ont un programme commun mais l'exécutent en des points différents.

                La structure de la mémoire d'un processus devient la suivante :

                \begin{center}
                    \begin{tikzpicture}
                        \node (c) at (0, 0) {code};
                        \node (d) at (0, -1) {données};
                        \node (t) at (0, -2) {tas};

                        \draw[->] (t) to (0, -3);

                        \node (p1) at (-2, -5) {pile};
                        \draw[->] (p1) to (-2, -4);

                        \node (p2) at (0, -5) {pile};
                        \draw[->] (p2) to (0, -4);

                        \node (p3) at (2, -5) {pile};
                        \draw[->] (p3) to (2, -4);

                        \node at (-2, -6) {registres};
                        \node at (0, -6) {registres};
                        \node at (1.8, -5.8) {registres};

                        \draw (-3, .3) rectangle (3, -6.5);
                        \draw (-3, -.5) -- (3, -.5);
                        \draw (-3, -1.5) -- (3, -1.5);
                        \draw (-3, -3.5) -- (3, -3.5);
                        \draw (-3, -5.5) -- (3, -5.5);

                        \draw (-1, -3.5) -- (-1, -6.5);
                        \draw (1, -3.5) -- (1, -6.5);

                        \node (f) at (0, -8) {3 fils};

                        \draw[->] (f) to (-2, -6.7);
                        \draw[->] (f) to (0, -6.7);
                        \draw[->] (f) to (2, -6.7);

                        \node (i) at (2.6, -6.2) [rectangle, draw] {$_{\text{\tiny{IP}}}$};

                        \draw[-latex] (i) to [out=45, in=-45] (3, 0);

                        \node at (6, -6) {IP : instruction pointer};
                    \end{tikzpicture}
                \end{center}

                \vspace{12pt}
                
                Limitations du programme :

                $\bullet$ On étudie les fils d'exécution d'un unique processus ;

                $\bullet$ On se limite uniquement à la norme POSIX ;

                \begin{indt}{$\bullet$ On s'autorise uniquement deux primitives sur les fils d'exécutions :}
                    $-$ \texttt{create} : prend une fonction et des paramètres pour cette fonction et crée un nouveau fil d'exécution pour le processus courant, chargé d'évaluer la fonction sur les paramètres ;

                    $-$ \texttt{join} : prend l'identifiant d'un file d'exécution en paramètre et interrompt le fil courant jusqu'à terminaison du fil passé en argument.
                \end{indt}
            \end{indt}

            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Situation de compétition et atomicité}}
                Un \textit{situation de compétition} (\textit{race condition}) a lieu quand le résultat d'un processus varie selon l'ordre d'exécution de ses fils. L'exemple vu en \ref{1.1.3} (page \pageref{1.1.3}) est une situation de compétition que l'on eput reproduire avec les fils d'un unique processus partageant une variable globale.
                Un fil principal est chargé de créer deux fils secondaires qui exécutent la boucle.
                Il doit attendre la terminaison des fils secondaires (opération \texttt{join}) avant de s'arrêter pour éviter une interruption prématurée du programme.

                Dans un cas comme celui-ci, on peut résoudre le problème en imposant \textit{l'atomicité} du corps de la boucle. Un ensemble d'instructions est \textit{atomique} si le système ne peut pas interrompre leur exécution. Ici, on ne voit pas d'interruption entre la lecture et l'écriture.
            \end{indt}

            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Section critique}}
                Dans l'exemple précédent, l'atomicité est une condition trop forte : on peut interrompre un fil entre la lecture et l'écriture tant que l'autre fil ne lit et n'écrit pas dans la variable.

                On dit que le corps de la boucle est une \textit{section critique} du programme.

                On veut garantir l'exclusion mutuelle pour les secteurs critiques, \textit{i.e} il ne peut y avoir qu'un seul fil qui exécute une section critique à chaque instant.

                Une solution de synchronisation doit aussi garantir le progrès de l'exécution : si un fil souhaite entrer en section critique et si celle-ci est libre, le choix d'un fil entrant en section critique ne doit pas pouvoir être retardé indéfiniment.

                On veut aussi assurer un temps d'attente borné : il doit y avoir une borne sur le nombre de fois que d'autres fils d'exécution entrent en section critique entre le moment où un fil signale qu'il souhaite entrer en section critique et son entrée effective.
            \end{indt}

            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Interblocage (\textit{deadlock}) et famine}}
                Si la synchronisation des fils d'exécution n'est pas effectuée correctement, il peut y avoir plusieurs problèmes, dont :

                $\bullet$ l'interblocage : on dit qu'il y a \textit{interblocage} lorsque plusieurs fils attendent un événement qui ne peut être provoqué que par l'un des fils en attente.

                Exemple classique : le dîner des philosophes.

                Des philosophes sont réunis autour d'une table ronde, et on deux activités : manger et penser.
                Pour manger, un philosophe doit disposer de deux baguettes.
                Les baguettes sont réparties comme suit : il y en a une entre chaque couple de philosophe voisins.

                Si les philosophes exécutent le programme suivant :

                \begin{pseudocode}
                    Prendre la baguette à gauche

                    Prendre la baguette à droite

                    Manger

                    Poser les baguettes

                    Penser
                \end{pseudocode}

                Il peut y avoir unterblocage si chaque philosophe a pris la baguette à sa gauche et attend que son voisin de droite libère l'autre.

                \vspace{6pt}
                
                $\bullet$ La \textit{famine} a lieu lorsqu'un fil d'exécution attend indéfiniment l'accès à une ressource.

                Exemple classique : le problème des producteurs-consommateurs.

                Des producteurs remplissent un buffer que les consommateurs vident.

                Règles : une donnée ne peut être lue qu'une fois, on ne peut pas écraser une donnée qui n'a pas été lue, et une case vide ne peut pas être lue.

                Si l'accès au buffer n'est pas équitable (par exemple une priorité selon les identifiants des fils d'exécution), un fil peut être amené à attendre indéfiniment.

                Par exemple : un producteur très lent, deux consommateurs très rapides : chaque fois que le producteur écrit dans le buffer, le fil consommateur n°1 récupère la donnée et reprend son attente, le fil n°2 n'accède jamais aux données.
            \end{indt}

            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Remarque}}
                Nous allons voir plusieurs outils de synchronisation permettant l'établissement de sections critiques.
                \begin{indt}{Ces outils peuvent être de plusieurs natures :}
                    $\bullet$ Algorithmique : nous verrons deux algorithmes permettant de travailler avec deux fils d'exécution (algorithme de \textsc{Petersen}) ou plus (algorithme de la boulangerie de \textsc{Lamport})

                    Ces algorithmes nécessitent une attente active des fils d'exécution : ils bouclent en ne faisant rien en attendant la réalisation d'une condition.

                    $\bullet$ Des primitives de programmation directement fournies par le système (mutex et sémaphore) qui permettent l'interruption d'un fil en attendant la réalisation d'une condition plutôt qu'une attente active.
                \end{indt}
            \end{indt}
        \end{indt}
    \end{indt}
    
    
    
\end{document}
%--------------------------------------------End
