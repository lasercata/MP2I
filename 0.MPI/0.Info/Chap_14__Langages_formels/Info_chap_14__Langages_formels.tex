\documentclass[a4paper, 12pt, twoside]{article}


%------------------------------------------------------------------------
%
% Author                :   Lasercata
% Last modification     :   2022.12.11
%
%------------------------------------------------------------------------


%------ini
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[french]{babel}
%\usepackage[english]{babel}


%------geometry
\usepackage[textheight=700pt, textwidth=500pt]{geometry}


%------color
\usepackage{xcolor}
\definecolor{ff4500}{HTML}{ff4500}
\definecolor{00f}{HTML}{0000ff}
\definecolor{0ff}{HTML}{00ffff}
\definecolor{656565}{HTML}{656565}

%\renewcommand{\emph}{\textcolor{ff4500}}
%\renewcommand{\em}{\color{ff4500}}

\newcommand{\Emph}{\textcolor{ff4500}}

\newcommand{\strong}[1]{\textcolor{ff4500}{\bf #1}}
\newcommand{\st}{\color{ff4500}\bf}


%------Code highlighting
%---listings
\usepackage{listings}

\definecolor{cbg}{HTML}{272822}
\definecolor{cfg}{HTML}{ececec}
\definecolor{ccomment}{HTML}{686c58}
\definecolor{ckw}{HTML}{f92672}
\definecolor{cstring}{HTML}{e6db72}
\definecolor{cstringlight}{HTML}{98980f}
\definecolor{lightwhite}{HTML}{fafafa}

\lstdefinestyle{DarkCodeStyle}{
    backgroundcolor=\color{cbg},
    commentstyle=\itshape\color{ccomment},
    keywordstyle=\color{ckw},
    numberstyle=\tiny\color{cbg},
    stringstyle=\color{cstring},
    basicstyle=\ttfamily\footnotesize\color{cfg},
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    keepspaces=true,
    numbers=left,
    numbersep=5pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=4,
    xleftmargin=\leftskip
}

\lstdefinestyle{LightCodeStyle}{
    backgroundcolor=\color{lightwhite},
    commentstyle=\itshape\color{ccomment},
    keywordstyle=\color{ckw},
    numberstyle=\tiny\color{cbg},
    stringstyle=\color{cstringlight},
    basicstyle=\ttfamily\footnotesize\color{cbg},
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    keepspaces=true,
    numbers=left,
    numbersep=10pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=4,
    frame=L,
    xleftmargin=\leftskip
}

%\lstset{style=DarkCodeStyle}
\lstset{style=LightCodeStyle}
%Usage : \begin{lstlisting}[language=Caml, xleftmargin=xpt] ... \end{lstlisting}


%---Algorithm
\usepackage[linesnumbered,ruled,vlined]{algorithm2e}
\SetKwInput{KwInput}{Input}
\SetKwInput{KwOutput}{Output}

\SetKwProg{Fn}{Function}{:}{}
\SetKw{KwPrint}{Print}

\newcommand\commfont[1]{\textit{\texttt{\textcolor{656565}{#1}}}}
\SetCommentSty{commfont}
\SetProgSty{texttt}
\SetArgSty{textnormal}
\SetFuncArgSty{textnormal}
%\SetProgArgSty{texttt}

%\newenvironment{indalgo}[2][H]{
%    \begin{minipage}{\linewidth-\leftskip-5pt}
%        \begin{algorithm}[#1]
%            \caption{#2}
%}
%{
%        \end{algorithm}
%    \end{minipage}
%}
\newenvironment{indalgo}[2][H]{
    \begin{algoBox}
        \begin{algorithm}[#1]
            \caption{#2}
}
{
        \end{algorithm}
    \end{algoBox}
}


%---tcolorbox
\usepackage[many]{tcolorbox}
\DeclareTColorBox{emphBox}{O{black}O{lightwhite}}{
    breakable,
    outer arc=0pt,
    arc=0pt,
    top=0pt,
    toprule=-.5pt,
    right=0pt,
    rightrule=-.5pt,
    bottom=0pt,
    bottomrule=-.5pt,
    colframe=#1,
    colback=#2,
    enlarge left by=10pt,
    width=\linewidth-\leftskip-10pt,
}

\DeclareTColorBox{algoBox}{O{black}O{lightwhite}}{
    breakable,
    arc=0pt,
    top=0pt,
    toprule=-.5pt,
    right=0pt,
    rightrule=-.5pt,
    bottom=0pt,
    bottomrule=-.5pt,
    left=0pt,
    leftrule=-.5pt,
    colframe=#1,
    colback=#2,
    width=\linewidth-\leftskip-10pt,
}


%-------make the table of content clickable
\usepackage{hyperref}
\hypersetup{
    colorlinks,
    citecolor=black,
    filecolor=black,
    linkcolor=black,
    urlcolor=black
}


%------pictures
\usepackage{graphicx}
%\usepackage{wrapfig}

\usepackage{tikz}
%\usetikzlibrary{babel}             %Uncomment this to use circuitikz
%\usetikzlibrary{shapes.geometric}  % To draw triangles in trees
%\usepackage{circuitikz}            %Electrical circuits drawing
\usetikzlibrary{automata}


%------tabular
%\usepackage{color}
%\usepackage{colortbl}
%\usepackage{multirow}


%------Physics
%---Packages
%\usepackage[version=4]{mhchem} %$\ce{NO4^2-}$

%---Commands
\newcommand{\link}[2]{\mathrm{#1} \! - \! \mathrm{#2}}
\newcommand{\pt}[1]{\cdot 10^{#1}} % Power of ten
\newcommand{\dt}[2][t]{\dfrac{\mathrm d #2}{\mathrm d #1}} % Derivative


%------math
%---Packages
%\usepackage{textcomp}
%\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{mathtools} % For abs
\usepackage{stmaryrd} %for \llbracket and \rrbracket
\usepackage{mathrsfs} %for \mathscr{x} (different from \mathcal{x})

%---Commands
%-Sets
\newcommand{\N}{\mathbb{N}} %set N
\newcommand{\Z}{\mathbb{Z}} %set Z
\newcommand{\Q}{\mathbb{Q}} %set Q
\newcommand{\R}{\mathbb{R}} %set R
\newcommand{\C}{\mathbb{C}} %set C
\newcommand{\U}{\mathbb{U}} %set U
\newcommand{\seg}[2]{\left[ #1\ ;\ #2 \right]}
\newcommand{\nset}[2]{\left\llbracket #1\ ;\ #2 \right\rrbracket}

%-Exponantial / complexs
\newcommand{\e}{\mathrm{e}}
\newcommand{\cj}[1]{\overline{#1}} %overline for the conjugate.

%-Vectors
\newcommand{\vect}{\overrightarrow}
\newcommand{\veco}[3]{\displaystyle \vect{#1}\binom{#2}{#3}} %vector + coord

%-Limits
\newcommand{\lm}[2][{}]{\lim\limits_{\substack{#2 \\ #1}}} %$\lm{x \to a} f$ or $\lm[x < a]{x \to a} f$
\newcommand{\Lm}[3][{}]{\lm[#1]{#2} \left( #3 \right)} %$\Lm{x \to a}{f}$ or $\Lm[x < a]{x \to a}{f}$
\newcommand{\tendsto}[1]{\xrightarrow[#1]{}}

%-Integral
\newcommand{\dint}[4][x]{\displaystyle \int_{#2}^{#3} #4 \mathrm{d} #1} %$\dint{a}{b}{f(x)}$ or $\dint[t]{a}{b}{f(t)}$

%-left right
\newcommand{\lr}[1]{\left( #1 \right)}
\newcommand{\lrb}[1]{\left[ #1 \right]}
\newcommand{\lrbb}[1]{\left\llbracket #1 \right\rrbracket}
\newcommand{\set}[1]{\left\{ #1 \right\}}
\newcommand{\abs}[1]{\left\lvert #1 \right\rvert}
\newcommand{\ceil}[1]{\left\lceil #1 \right\rceil}
\newcommand{\floor}[1]{\left\lfloor #1 \right\rfloor}
\newcommand{\lrangle}[1]{\left\langle #1 \right\rangle}

%-Others
\newcommand{\para}{\ /\!/\ } %//
\newcommand{\ssi}{\ \Leftrightarrow \ }
\newcommand{\eqsys}[2]{\begin{cases} #1 \\ #2 \end{cases}}

\newcommand{\med}[2]{\mathrm{med} \left[ #1\ ;\ #2 \right]}  %$\med{A}{B} -> med[A ; B]$
\newcommand{\Circ}[2]{\mathscr{C}_{#1, #2}}

\renewcommand{\le}{\leqslant}
\renewcommand{\ge}{\geqslant}

\newcommand{\oboxed}[1]{\textcolor{ff4500}{\boxed{\textcolor{black}{#1}}}} %orange boxed


%------commands
%---to quote
\newcommand{\simplecit}[1]{\guillemotleft$\;$#1$\;$\guillemotright}
\newcommand{\cit}[1]{\simplecit{\textcolor{656565}{#1}}}
\newcommand{\quo}[1]{\cit{\it #1}}

%---to indent
\newcommand{\ind}[1][20pt]{\advance\leftskip + #1}
\newcommand{\deind}[1][20pt]{\advance\leftskip - #1}

%---to indent a text
\newcommand{\indented}[2][20pt]{\par \ind[#1] #2 \par \deind[#1]}
\newenvironment{indt}[2][20pt]{#2 \par \ind[#1]}{\par \deind} %Titled indented env

%---title
\newcommand{\thetitle}[2]{\begin{center}\textbf{{\LARGE \underline{\Emph{#1} :}} {\Large #2}}\end{center}}

%---Maths environments
%-Proofs
\newenvironment{proof}[1][{Démonstration :}]{\begin{indt}{$\square$ #1}}{$\blacksquare$ \end{indt}}

%-Maths parts (proposition, definition, ...)
\newenvironment{mathpart}[1]{\begin{indt}{\boxed{\text{\textbf{#1}}}}}{\end{indt}}
\newenvironment{mathbox}[1]{\boxed{\text{\textbf{#1}}}\begin{emphBox}}{\end{emphBox}}
\newenvironment{mathul}[1]{\begin{indt}{\underline{\textbf{#1}}}}{\end{indt}}

\newenvironment{theo}{\begin{mathpart}{Théorème}}{\end{mathpart}}
\newenvironment{Theo}{\begin{mathbox}{Théorème}}{\end{mathbox}}

\newenvironment{prop}{\begin{mathpart}{Proposition}}{\end{mathpart}}
\newenvironment{Prop}{\begin{mathbox}{Proposition}}{\end{mathbox}}
\newenvironment{props}{\begin{mathpart}{Propriétés}}{\end{mathpart}}

\newenvironment{defi}{\begin{mathpart}{Définition}}{\end{mathpart}}
\newenvironment{meth}{\begin{mathpart}{Méthode}}{\end{mathpart}}

\newenvironment{Rq}{\begin{mathul}{Remarque :}}{\end{mathul}}
\newenvironment{Rqs}{\begin{mathul}{Remarques :}}{\end{mathul}}

\newenvironment{Ex}{\begin{mathul}{Exemple :}}{\end{mathul}}
\newenvironment{Exs}{\begin{mathul}{Exemples :}}{\end{mathul}}


%------Sections
% To change section numbering :
% \renewcommand\thesection{\Roman{section}}
% \renewcommand\thesubsection{\arabic{subsection})}
% \renewcommand\thesubsubsection{\textit \alph{subsubsection})}

% To start numbering from 0
% \setcounter{section}{-1}


%------page style
\usepackage{fancyhdr}
\usepackage{lastpage}

\setlength{\headheight}{18pt}
\setlength{\footskip}{50pt}

\pagestyle{fancy}
\fancyhf{}
\fancyhead[LE, RO]{\textit{\textcolor{black}{\today}}}
\fancyhead[RE, LO]{\large{\textsl{\Emph{\texttt{\jobname}}}}}

\fancyfoot[RO, LE]{\textit{\texttt{\textcolor{black}{Page \thepage /}\pageref{LastPage}}}}
\fancyfoot[LO, RE]{\includegraphics[scale=0.12]{/home/lasercata/Pictures/1.images_profil/logo/mieux/lasercata_logo_fly_fond_blanc.png}}


%------init lengths
\setlength{\parindent}{0pt} %To avoid using \noindent everywhere.
\setlength{\parskip}{3pt}

%---------Specific to this file
\newcommand{\Reg}{\mathsf{Reg}}
\newcommand{\Regexp}{\mathsf{Regexp}}
\newcommand{\Rec}[1]{\mathsf{Rec}\!\lr{#1}}


%---------------------------------Begin Document
\begin{document}
    
    \thetitle{Chapitre 14}{Langages formels}
    
    \tableofcontents
    \listofalgorithms
    \newpage
    
    \begin{indt}{\section{Langages réguliers}}
        \begin{indt}{\subsection{Motivation}}
            \begin{indt}{\subsubsection{Introduction}}
                \label{1.1.1}

                On a souvent besoin de mettre en place une analyse de texte, même dans le cadre d'applications qui ne relèvent pas uniquement du traitement de texte.

                \begin{indt}{Par exemple :}
                    $\bullet$ La recherche d'un mot dans un texte (\textit{cf} chap 11) ;

                    $\bullet$ analyser un document structuré afin de traiter de manière appropriée son contenu (exemple : compiler un programme, récupérer des données sérialisées (\textit{cf} chap 11) dans un format particulier (ex : données brutes en CSV, fichiers de configuration en JSON ou en XML)) ;

                    $\bullet$ Reconnaître un encodage et le déchiffrer (exemple : QR-code).
                \end{indt}

                \vspace{12pt}
                
                Quelle que soit l'application, on a besoin d'un formalisme pour décrire la structure du texte et d'algorithmes efficaces capables d'analyser cette structure et d'extraire les données associées.
            \end{indt}

            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Exemple}}
                \label{1.1.2}

                \'Etant donné un fichier binaire, déterminer s'il contient la représentation binaire d'un entier non signé multiple de 3.

                \vspace{6pt}
                
                $\bullet$ Remarque : on n'utilise pas les types d'entiers natifs de C ou OCaml car ils ont une taille fixée qui peut être dépassée par le fichier.

                \vspace{6pt}
                
                Idée : on lit les bits un à un en effectuant les opérations associées modulo 3, en remarquant que
                \[
                    \begin{cases}
                        \lrangle{x 0}_2 = 2\lrangle x _2
                        \\
                        \lrangle{x 1}_2 = 2\lrangle x _2 + 1
                    \end{cases}
                \]

                On utilise cette table :

                \begin{center}
                    \begin{tabular}{|l|c|c|c|}
                        \hline
                        $\lrangle x _2 \mod 3$ & 0 & 1 & 2
                        \\
                        \hline
                        $\lrangle{x 0}_2 \mod 3$ & 0 & 2 & 1
                        \\
                        \hline
                        $\lrangle{x 1}_2 \mod 3$ & 1 & 0 & 2
                        \\
                        \hline
                    \end{tabular}
                \end{center}

                $\bullet$ Algorithme :

                \begin{indalgo}{Exemple}
                    \label{alg:1}

                    $x \gets 0$\;

                    \For{chaque bit $b$ pris dans l'odre}{
                        \If{$b = 0$}{
                            $x \gets 2x \mod 3$\;
                        }
                        \Else{
                            $x \gets 2x + 1 \mod 3$
                        }
                    }

                    \KwRet $x = 0$\;
                \end{indalgo}

                \vspace{12pt}
                
                $\bullet$ Représentation graphique : $x$ ne peut prendre que trois valeurs différentes, appelées états, et on peut représenter les changements de valeur de $x$ dans un graphe orienté dont les sommets sont les états, et les arcs sont étiquetés par le bit qui produit le changement de valeur de l'état source vers l'état cible.

                \begin{center}
                    \begin{tikzpicture}[scale=1.3]
                        \node (0) at (0, 0) [state, initial, initial text={}, accepting] {$0$};
                        \node (1) at (2, 0) [state] {$1$};
                        \node (2) at (4, 0) [state] {$2$};

                        \draw[->] (0) to [out=-20, in=-160] node [below] {$1$} (1);
                        \draw[->] (1) to [out=160, in=20] node [above] {$1$} (0);
                        \draw[->] (1) to [out=-20, in=-160] node [below] {$0$} (2);
                        \draw[->] (2) to [out=160, in=20] node [above] {$0$} (1);

                        \draw[->] (0) to [out=60, in=120, looseness=3] node [above] {$0$} (0);
                        \draw[->] (2) to [out=60, in=120, looseness=3] node [above] {$1$} (2);
                    \end{tikzpicture}
                \end{center}

                On distingue de plus la valeur initiale par une flèche, et la valeur finale atteinte par un double cercle.

                Cette représentation correspond au formalisme des \emph{automates}, que nous verrons en \ref{2} (page \pageref{2}).
            \end{indt}
        \end{indt}

        \vspace{12pt}
        
        \begin{indt}{\subsection{Langages}}
            \begin{indt}{\subsubsection{Définition (\textit{alphabet})}}
                Un \emph{alphabet} est un ensemble fini non vide, dont les éléments sont appelés lettres ou symboles.

                Notation usuelle : $\Sigma$.
            \end{indt}

            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Définition (\textit{mot})}}
                Soit $\Sigma$ un alphabet.

                Un \emph{mot} sur $\Sigma$ est une suite finie de symboles $u = u_1 \cdots u_n$, potentiellement vide.

                Si $n = 0$, on note $u = \varepsilon$.

                On note $\abs u = n$ la \emph{longueur} du mot.
            \end{indt}

            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Définition (\textit{concaténation})}}
                Soit $\Sigma$ un alphabet, et $u, v$ deux mots sur $\Sigma$.

                On appelle \emph{concaténation} de $u$ et $v$ le mot
                \[
                    uv =
                    \begin{cases}
                        v & \text{si}\ u = \varepsilon
                        \\
                        u & \text{si}\ v = \varepsilon
                        \\
                        u_1 \cdots u_n v_1 \cdots v_p
                        & \text{si}
                        \begin{cases}
                            u = u_1 \cdots u_n
                            \\
                            v = v_1 \cdots v_p
                        \end{cases}
                    \end{cases}
                \]

                \boxed{\rm Exo}

                $\bullet$ $\abs{uv} = \abs u + \abs v$

                $\bullet$ La concaténation est une loi de composition interne associative et d'élément neutre $\varepsilon$ sur l'ensemble des mots sur $\Sigma$.
            \end{indt}

            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Définition (\textit{préfixe, suffixe, facteur, sous-mot})}}
                Soit $\Sigma$ un alphabet, et $u, v$ deux mots sur $\Sigma$

                \vspace{6pt}
                
                $\bullet$ $v$ est un \emph{préfixe} de $u$ ssi $\exists w$ mot tel que $u = vw$

                $\bullet$ $v$ est un \emph{suffixe} de $u$ ssi $\exists w$ mot tel que $u = wv$

                $\bullet$ $v$ est un \emph{facteur} de $u$ ssi $\exists x, y$ mots tels que $u = xvy$

                $\bullet$ $v$ est un \emph{sous-mot} de $u$ ssi $\exists i_1 < i_2 < \cdots < i_k$ tels que si $u = u_1 \cdots u_n$, alors $v = u_{i_1} \cdots u_{i_k}$

                \vspace{12pt}
                
                Exemple : si $u = abc$, $v = ac$ est un sous-mot de $u$, mais pas un facteur.
            \end{indt}

            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Langages}}
                $\bullet$ Définition (\textit{langage}) : un \emph{langage} sur un alphabet $\Sigma$ est un ensemble de mots sur $\Sigma$.

                \vspace{12pt}
                
                \begin{indt}{$\bullet$ Exemples :}
                    $-$ l'ensemble de tous les mots, noté $\Sigma^*$ (\textit{cf} \ref{1.3}, page \pageref{1.3}) ;

                    $-$ l'ensemble des écritures binaires des multiples de 3 ($\Sigma = \set{0, 1}$) ;

                    $-$ $\Sigma$ (si on voit les lettres comme des mots de longueur 1) ;

                    $-$ l'ensemble des code sources OCaml de programmes qui ne terminent pas.
                \end{indt}

                \vspace{12pt}
                
                $\bullet$ Problème : étant donné un langage $L$ sur un alphabet $\Sigma$, on veut disposer d'une représentation formelle de $L$ pour pouvoir étudier la question suivante :
                étant donné un mot $u$, a-t-on $u \in L$ ?

                \vspace{6pt}
                
                C'est une question importante car souvent, comme dans les exemples en \ref{1.1.1} (page \pageref{1.1.1}), il faut pouvoir vérifier la structure d'un élément avant d'en extraire des données.

                Malheureusement, on ne peut pas toujours répondre algorithmiquement à cette question. (\textit{cf} chap 16 et la notion de décidabilité et le problème de l'arrêt), mais on peut y répondre pour une classe restreinte de langages.
            \end{indt}
        \end{indt}

        \vspace{12pt}
        
        \begin{indt}{\subsection{Langages réguliers}}
            \label{1.3}

            \begin{indt}{\subsubsection{Opérations sur les langages}}
                Outre les opérations ensemblistes usuelles (intersection, union, complémentaire), on définit certaines opérations plus spécifiques aux langages.

                \vspace{12pt}
                
                $\bullet$ \textbf{Concaténation} : Soit $\Sigma$ un alphabet, et $L, L'$ deux langages sur $\Sigma$.

                La concaténation de $L$ et $L'$ est le langage
                \[
                    LL' = \set{uv\ |\ (u, v) \in L \times L'}
                \]

                Remarque : $L \varnothing = \varnothing L = \varnothing$.

                \vspace{12pt}
                
                $\bullet$ \textbf{Puissance} : Soit $\Sigma$ un alphabet, $L$ un langage sur $\Sigma$, et $n \in \N$.

                La puissance $n$-ème de $L$ est le langage
                \[
                    L^n =
                    \begin{cases}
                        \set \varepsilon
                        & \text{si}\ n = 0
                        \\
                        LL^{n - 1}
                        & \text{si}\ n > 0
                    \end{cases}
                \]

                \vspace{12pt}
                
                $\bullet$ \textbf{\'Etoile de \textsc{Kleene}} : Soit $\Sigma$ un alphabet, et $L$ un langage sur $\Sigma$.

                L'\emph{étoile de \textsc{Kleene}} de $L$ est le langage
                \[
                    L^* = \bigcup_{n \in \N} L^n
                \]

                \vspace{12pt}
                
                \begin{indt}{$\bullet$ Remarques :}
                    $-$ $\Sigma^*$ est bien l'ensemble de tous les mots : tout mot $u = u_1 \cdots u_n$ est la caractérisation de ses lettres ($\forall i \in \nset{1}{n},\ u_i \in \Sigma$, donc $u = u_1 \cdots u_n \in \Sigma^n \subseteq \Sigma^*$).

                    $-$ On peut aussi définir la puissance $n$-ème d'un mot :
                    \[
                        u^n =
                        \begin{cases}
                            \varepsilon
                            & \text{si}\ n = 0
                            \\
                            u u^{n - 1}
                            & \text{si}\ n > 0
                        \end{cases}
                    \]

                    Attention : ne pas confondre $L^n$ et $\set{u^n\ |\ u \in L}$.

                    $-$ On note aussi
                    \[
                        L^+ = \bigcup_{n \in \N^*} L^n
                    \]

                    \vspace{6pt}
                    
                    \boxed{\rm Exo} $L^+ = L^* \ssi \varepsilon \in L$.
                \end{indt}
            \end{indt}

            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Théorème (\textit{Lemme d'\textsc{Arden}}) (H.P)}}
                \begin{emphBox}
                    Soit $\Sigma$ un alphabet, et $K, L$ deux langages sur $\Sigma$.

                    (1) $K^* L$ est le minimum (pour l'ordre de l'inclusion) des solutions de l'équation
                    \[
                        X = K X \cup L
                    \]
                    d'inconnue un langage $X$.

                    \vspace{6pt}
                    
                    (2) Si $\varepsilon \notin K$, alors $K^* L$ est l'unique solution.
                \end{emphBox}

                \vspace{12pt}
                
                \begin{proof}
                    (1) On a :
                    \[
                        \begin{array}{rcl}
                            K(K^*L)\cup L
                            &=& \displaystyle K\lr{\bigcup_{n \in \N} K^n L} \cup L
                            \vspace{3pt}
                            \\
                            &=& K^+ L \cup K^0 L
                            \vspace{3pt}
                            \\
                            &=&K^* L
                        \end{array}
                    \]
                    Donc $K^*L$ est une solution.

                    Puis soit $X$ une solution. Montrons que $K^* L \subset X$.

                    Soit $u \in K^* L$. Par définition,
                    \[
                        \exists n \in \N,\ \exists k_1, \ldots, k_n \in K,\ \exists l \in L\ |\
                        u = k_1 \cdots k_n l
                    \]

                    On montre par récurrence sur $n$ que $u \in X$ :

                    $\bullet$ $n = 0$ :
                    $u \in L \subset KX\cup L = X$, donc $u \in X$.

                    \vspace{6pt}
                    
                    $\bullet$ Hérédité :
                    si $\forall k_1 \cdots k_n \in K,\ \forall l \in L,\ k_1 \cdots k_n l \in X$, considérons $u = k_1 \cdots k_{n + 1} l$, avec $k_1 \cdots k_{n + 1} \in K$ et $l \in L$.

                    $u = k_1(\underbrace{k_2 \cdots k_{n + 1}l}_{\in X\ \text{par H.R}}) \in KX \subseteq KX \cup L = X$, donc $u \in X$.

                    Finalement, $K^* L \subset X$, et $K^*L$ est bien le minimum des solutions.

                    \vspace{12pt}
                    
                    (2) On suppose $\varepsilon \notin K$. Soit $X$ une solution.

                    On sait par (1) que $K^*L \subseteq X$.

                    Il suffit de montrer que $X \subseteq K^* L$.

                    Soit $u \in X$ dont on note $n$ la longueur.

                    On montre par récurrence que
                    \[
                        \forall k \in \nset 0 n,\ X = \bigcup_{j = 0}^k K^j L \cup K^{k + 1} X
                    \]

                    \vspace{6pt}
                    
                    $\bullet$ $k = 0$ :
                    \[
                        \bigcup_{j = 0}^0 K^j L \cup K^{0 + 1} X = L \cup KX = X
                    \]

                    $\bullet$ Hérédité : Soit $k \in \nset 0 {n - 1} \ |\ X = \displaystyle \bigcup_{j = 0}^k K^j L \cup K^{k + 1} X$

                    \[
                        \begin{array}{rcl}
                            X
                            &=& KX \cup L
                            \\
                            &=& \displaystyle K\lr{\bigcup_{j = 0}^k K^j L \cup K^{k + 1}L} \cup L
                            \\
                            &=& \displaystyle \bigcup_{j = 0}^k K^{j + 1} L \cup K^{k + 1} L \cup L
                            \vspace{3pt}
                            \\
                            &=& \displaystyle \bigcup_{j = 0}^{k + 1} K^J L \cup K^{k + 2} L
                        \end{array}
                    \]

                    En particulier,
                    \[
                        X = \bigcup_{j = 0}^n K^J L \cup K^{n + 1} X
                    \]

                    Or $\forall v \in K^{n + 1}X,\ \abs v \ge n + 1$

                    En effet, $\exists k_1 \cdots k_{n + 1} \in K,\ \exists x \in X\ |\ v = k_1 \cdots k_{n + 1} x$.

                    Or $\forall i \in \nset 1 {n + 1}, k_i \neq \varepsilon$, donc $\abs{k_i} \ge 1$, donc
                    \[
                        \abs v = \sum_{i = 1}^{n + 1} \abs{k_i} + \abs x
                        \ge n + 1 + \abs x \ge n + 1
                    \]

                    Donc, comme $\abs u = n < n + 1$,
                    \[
                        \bigcup_{j = 0}^n K^j L \subseteq \bigcup_{j \in \N} K^J L = K^*L
                    \]
                    Donc $u \in K^* L$, et $X \subseteq K^*L$
                \end{proof}

                \vspace{12pt}
                
                $\bullet$ Contre-exemple au point (2) si $\varepsilon \in K$ : on prend $K = \set \varepsilon$, et $L = \set a$.
                $K^*L = \set a = L$, et tout $X\ |\ a \in X$ est solution ($KX\cup L = X \cup \set a$). Par exemple : $\set a = K^*L$ ou $\set{a, aa}, \set{a, aa, aaa}$.
            \end{indt}

            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Langage régulier}}
                La classe des \emph{langages réguliers}, aussi appelés \emph{langages rationnels}, est la famille des langages que l'on peut construire à partir de langages de base ($\varnothing$, $\set \varepsilon$, $\set a\ \forall a \in \Sigma$) et des opérations dites \emph{régulières} : union, concaténation et étoile de \textsc{Kleene}. L'ensemble $\Reg(\Sigma)$ des langages réguliers sur l'alphabet $\Sigma$ est définit inductivement par :
                \[
                    \dfrac{}{\varnothing \in \Reg(\Sigma)}
                    \qquad
                    \dfrac{a \in \Sigma}{\set a \in \Reg(\Sigma)}
                    \qquad
                    \dfrac{L \in \Reg(\Sigma)}{L^* \in \Reg(\Sigma)}
                \]

                \[
                    \dfrac{L \in \Reg(\Sigma)\ L' \in \Reg(\Sigma)}{L \cup L' \in \Reg(\Sigma)}
                    \qquad
                    \dfrac{L \in \Reg(\Sigma)\ L' \in \Reg(\Sigma)}{LL' \in \Reg(\Sigma)}
                \]

                \vspace{12pt}
                
                $\bullet$ Remarque : $\set \varepsilon \in \Reg(\Sigma)$ car $\set \varepsilon = \varnothing^0 = \displaystyle \bigcup_{n \in \N} \varnothing^n = \varnothing^*$

                $\Sigma \in \Reg(\Sigma)$ car, en notant $\Sigma = \set{a_1 \cdots a_n}$, on a :
                \[
                    \Sigma = \bigcup_{k = 1}^n \set{a_k}
                \]
                Donc une récurrence sur $n = \abs \Sigma$ conclut.

                De même, tout langage fini est régulier (\boxed{\rm Exo}).

                \vspace{6pt}
                
                Il manque encore un formalisme pour décrire les langages réguliers.
            \end{indt}

            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Expressions régulières}}
                Soit $\Sigma$ un alphabet, et $S = \set{(, ), |, *, \varnothing, \varepsilon}$ un ensemble de symboles supposé disjoint de $\Sigma$.

                L'ensemble $\Regexp(\Sigma)$ des \emph{expressions régulières} sur $\Sigma$, aussi appelées \emph{expressions rationnelles}, est l'ensemble des mots sur $\Sigma \cup S$ défini inductivement par
                \[
                    \dfrac{}{\varnothing \in \Regexp(\Sigma)}
                    \qquad
                    \dfrac{}{\varepsilon \in \Regexp(\Sigma)}
                    \qquad
                    \dfrac{a \in \Sigma}{a \in \Regexp(\Sigma)}
                \]
                \[
                    \dfrac{e \in \Regexp(\Sigma)\ f \in \Regexp(\Sigma)}{(e | f) \in \Regexp(\Sigma)}
                    \qquad
                    \dfrac{e \in \Regexp(\Sigma)\ f \in \Regexp(\Sigma)}{(ef) \in \Regexp(\Sigma)}
                \]
                \[
                    \dfrac{e \in \Regexp(\Sigma)}{(e^*) \in \Regexp(\Sigma)}
                \]

                Remarques :

                $\bullet$ $|$ est parfois noté $+$.

                $\bullet$ On se passe de certaines parenthèses avec les règles de priorité :
                \[
                    * > \text{concaténation} > |
                \]

                Par exemple, $\lr{\lr{a\lr{b^*}} | b}$ s'écrit $a b^* | b$.
            \end{indt}

            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Définition (\textit{langage dénoté par une expression régulière})}}
                Soit $\Sigma$ un alphabet.

                Le \emph{langage dénoté par une expression régulière} $e \in \Regexp(\Sigma)$ est le langage $\mathcal L(e)$ défini inductivement par :
                \[
                    \mathcal L(\varnothing) = \varnothing
                    \qquad
                    \mathcal L(\varepsilon) = \set \varepsilon
                    \qquad
                    \forall a \in \Sigma,\ \mathcal L(a) = \set a
                \]
                \[
                    \mathcal L(e | f) = \mathcal L(e) \cup \mathcal L(f)
                    \qquad
                    \mathcal L(ef) = \mathcal L(e) \mathcal L(f)
                    \qquad
                    \mathcal L(e^*) = \mathcal L(e)^*
                \]

                \vspace{6pt}
                
                Exemple :

                $L_1 = \set \varepsilon = \mathcal L(\varnothing^*)$

                $L_2 = \Sigma = \mathcal L(a_1 | a_2 | \cdots | a_n)$ en notant $\Sigma = \set{a_k\ |\ k \in \nset 1 n}$

                \[
                    \begin{array}{rcl}
                        L_3 &=& \set{u \in \Sigma^*\ |\ \abs u \equiv 1\ [2]}
                            \vspace{6pt}
                        \\
                            &=& \displaystyle \bigcup_{n \in \N} \set{u \in \Sigma^*\ |\ \abs u = 2n + 1}
                            \vspace{6pt}
                        \\
                            &=& \displaystyle \lr{\bigcup_{n \in \N} \set{u \in \Sigma^*\ |\ \abs u = 2n}}\Sigma
                            \vspace{6pt}
                        \\
                            &=& \mathcal L\!\lr{(\Sigma\Sigma)^* \Sigma}
                    \end{array}
                \]

                $L_4 = \set{u \in \Sigma^*\ |\ a\ \text{préfixe de $u$ et $b$ suffixe de $u$}} = \mathcal L(a\Sigma^* b)$

                $L_5 = \set{u \in \Sigma^*\ |\ ab\ \text{est facteur de $u$}} = \mathcal L(\Sigma^* ab \Sigma^*)$
            \end{indt}

            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Proposition}}
                \begin{emphBox}
                    Soit $\Sigma$ un alphabet, et $L$ un langage sur $\Sigma$.

                    Alors :
                    \[
                        L\ \text{est régulier}\ \ssi \exists e \in \Regexp(\Sigma)\ |\ L = \mathcal L(e)
                    \]
                \end{emphBox}

                \vspace{12pt}
                
                \begin{proof}
                    \boxed{\Leftarrow} \boxed{\rm Exo}
                    (par induction sur $e$)

                    \vspace{12pt}
                    
                    \boxed{\Rightarrow} par induction sur une dérivation de $L \in \Reg(\Sigma)$, en faisant une disjonction de cas selon la dernière règle utilisée.

                    \vspace{6pt}
                    
                    $\bullet$ $\dfrac{}{\varnothing \in \Reg(\Sigma)}$ : alors $L = \varnothing = \mathcal L(\varnothing)$

                    \vspace{6pt}
                    
                    $\bullet$ $\dfrac{a \in \Sigma}{\set a \in \Reg(\Sigma)}$ : alors $L = \set a = \mathcal L(a)$

                    \vspace{6pt}
                    
                    $\bullet$ $\dfrac{L_1 \in \Reg(\Sigma)\ L_2 \in \Reg(\Sigma)}{L_1 \cup L_2 \in \Reg(\Sigma)}$ : alors $L = L_1 \cup L_2$, et par H.I :
                    \[
                        \exists e_1, e_2 \in \Regexp(\Sigma)\
                        \begin{array}{|l}
                            L_1 = \mathcal L(e_1)
                            \\
                            L_2 = \mathcal L(e_2)
                        \end{array}
                    \]
                    D'où $L = L_1 \cup L_2 = \mathcal L(e_1) \cup \mathcal L(e_2)$

                    \vspace{6pt}
                    
                    $\bullet$ $\dfrac{L_1 \in \Reg(\Sigma)\ L_2 \in \Reg(\Sigma)}{L_1 L_2 \in \Reg(\Sigma)}$ : alors $L = L_1 L_2$, et par H.I :
                    \[
                        \exists e_1, e_2 \in \Regexp(\Sigma)\
                        \begin{array}{|l}
                            L_1 = \mathcal L(e_1)
                            \\
                            L_2 = \mathcal L(e_2)
                        \end{array}
                    \]
                    D'où $L = L_1 L_2 = \mathcal L(e_1) \mathcal L(e_2)$

                    \vspace{6pt}
                    
                    $\bullet$ $\dfrac{L_0 \in \Reg(\Sigma)}{L_0^* \in \Reg(\Sigma)}$ : alors $L = L_0^*$, et par H.I :
                    \[
                        \exists e \in \Regexp(\Sigma)\
                        \begin{array}{|l}
                            L_0 = \mathcal L(e)
                        \end{array}
                    \]
                    D'où $L = L_0^* = \mathcal L(e)$
                \end{proof}

                \vspace{12pt}
                
                Exemple : $L = \set{ab, ac}$

                \[
                    \begin{array}{c}
                        \dfrac{
                            ~\dfrac{
                                ~\dfrac{a \in \Sigma}{\set a \in \Reg(\Sigma)}
                                \ \
                                \dfrac{b \in \Sigma}{\set b \in \Reg(\Sigma)}~
                            }{
                                \set{ab} \in \Reg(\Sigma)
                            }
                            \ \
                            \dfrac{
                                ~\dfrac{a \in \Sigma}{\set a \in \Reg(\Sigma)}
                                \ \
                                \dfrac{c \in \Sigma}{\set c \in \Reg(\Sigma)}~
                            }{
                                \set{ac} \in \Reg(\Sigma)
                            }~
                        }{
                            \set{ab, ac} \in \Reg(\Sigma) %\Reg(\set{a, b c})
                        }
                        \\
                        \\
                        ab | ac
                        \\\\
                        \dfrac{
                            ~\dfrac{
                                a \in \Reg(\Sigma)
                            }{
                                \set a \in \Reg(\Sigma)
                            }
                            \ \
                            \dfrac{
                                ~\dfrac{b \in \Sigma}{\set b \in \Reg(\Sigma)}
                                \ \
                                \dfrac{c \in \Sigma}{\set c \in \Reg(\Sigma)}~
                            }{
                                \set{b, c} \in \Reg(\Sigma)
                            }~
                        }{
                            \set{ab, ac} \in \Reg(\Sigma)
                        }
                        \\
                        \\
                        a(b|c)
                    \end{array}
                \]
            \end{indt}

            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Définition (\textit{équivalence d'expressions régulières})}}
                Soit $\Sigma$ un alphabet, et $e, f \in \Regexp(\Sigma)$.

                Alors $e, f$ sont dits équivalents, noté $e \equiv f$, si et seulement si $\mathcal L(e) = \mathcal L(f)$.
            \end{indt}

            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Proposition}}
                \begin{emphBox}
                    Soit $\Sigma$ un alphabet, et $e \in \Regexp(\Sigma)$.

                    (1) Si $e$ ne contient pas $\varnothing$, alors $\mathcal L(e) \neq \varnothing$

                    (2) La réciproque est fausse

                    (3) Si $\mathcal L(e) \neq \varnothing$, alors $\exists f \in \Regexp(\Sigma)\ |\ e \equiv f$ et $f$ ne contient pas $\varnothing$.
                \end{emphBox}

                \vspace{12pt}
                
                \begin{proof}
                    (1) \boxed{\rm Exo} par induction sur $e$

                    (2) $a | \varnothing$ avec $a \in \Sigma$

                    (3) Par induction sur $e$ :

                    $\bullet$ $e = \varnothing$ : impossible

                    $\bullet$ $e = \Sigma$ ou $e = a$ avec $a \in \Sigma$, $f = e$ convient

                    \begin{indt}{$\bullet$ $e = e_1 | e_2$ : $\mathcal L(e_1) = \varnothing = \mathcal L(e_2)$ est impossible car $\mathcal L(e) = \mathcal L(e_1) \cup \mathcal L(e_2)$}
                        $-$ Si $\mathcal L(e_1) = \varnothing$ et $\mathcal L(e_2) \neq \varnothing$ (l'autre cas est symétrique), $\mathcal L(e) = \mathcal L(e_2)$, et par H.I, $\exists f_2 \in \Regexp(\Sigma)\ |\ f_2$ ne contient pas $\varnothing$ et $f_2 \equiv e_2$.

                        Alors $e \equiv f_2$.

                        \vspace{12pt}
                        
                        $-$ Si $\mathcal L(e_1) \neq \varnothing$ et $\mathcal L(e_2) \neq \varnothing$, par H.I, $\exists f_1, f_2 \in \Regexp(\Sigma)\ |\ f_1, f_2$ ne contiennent pas $\varnothing$, et
                        \[
                            \begin{cases}
                                f_1 \equiv e_1
                                \\
                                f_2 \equiv e_2
                            \end{cases}
                        \]
                        Alors $\mathcal L(e) = \mathcal L(e_1) \cup \mathcal L(e_2) = \mathcal L(f_1) \cup \mathcal L(f_2) = \mathcal L(f_1 | f_2)$
                        et $e \equiv f_1 | f_2$ qui ne contient pas $\varnothing$.
                    \end{indt}

                    \vspace{6pt}
                    
                    $\bullet$ $e = e_1 e_2$ : $\mathcal L(e_1) = \varnothing$ ou $\mathcal L(e_2) = \varnothing$ est impossible car $\mathcal L(e) = \mathcal L(e_1) \mathcal L(e_2)$.

                    De même, on applique l'H.I à $e_1$ et $e_2$ pour obtenir deux expressions régulières dont on prend la concaténation.

                    \vspace{6pt}
                    
                    \begin{indt}{$\bullet$ $e = e_0^*$ :}
                        $-$ Si $\mathcal L(e_0) = \varnothing$, alors $\mathcal L(e) = \set \varepsilon = \mathcal L(\varepsilon)$

                        $-$ Sinon, on applique l'H.I à $e_0$ pour obtenir une expression régulière dont on prend l'étoile de \textsc{Kleene}
                    \end{indt}
                \end{proof}
            \end{indt}

            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Proposition}}
                Soit $\Sigma$ un alphabet, et $e \in \Regexp(\Sigma)$.

                On définit le terme constant de $e$ inductivement par
                \[
                    c(\varnothing) = 0
                    \qquad
                    c(\varepsilon) = 1
                    \qquad
                    c(a) = 0
                \]
                \[
                    c(ef) = \min(c(e), c(f))
                    \qquad
                    c(e|f) = \max(c(e), c(f))
                    \qquad
                    c(e^*) = 1
                \]

                \vspace{6pt}
                
                Alors :
                \begin{emphBox}
                    \[
                        \varepsilon \in \mathcal L(e) \ssi c(e) = 1
                    \]
                \end{emphBox}

                \vspace{12pt}
                
                \begin{proof}
                    \boxed{\rm Exo} par induction sur $e$.
                \end{proof}
            \end{indt}
        \end{indt}

        \vspace{12pt}
        
        \begin{indt}{\subsection{Expressions régulières étendues}}
            \begin{indt}{\subsubsection{Définition (\textit{expressions régulières étendues})}}
                Soit $\Sigma$ un alphabet.

                On étend la définition des expressions régulières en ajoutant deux symboles $\cap$ et $\setminus$ à $S$ et en ajoutant les règles d'inférence suivantes :
                \[
                    \dfrac{e \in \Regexp(\Sigma)\ f \in \Regexp(\Sigma)}{e \cap f \in \Regexp(\Sigma)}
                    \qquad
                    \dfrac{e \in \Regexp(\Sigma)\ f \in \Regexp(\Sigma)}{(e \setminus f) \in \Regexp(\Sigma)}
                \]

                Les langages dénotés sont
                \[
                    \begin{array}{l}
                        \mathcal L(e \cap f) = \mathcal L(e) \cap \mathcal L(f)
                        \\
                        \mathcal L(e\setminus f) = \mathcal L(e) \setminus \mathcal L(f)
                    \end{array}
                \]

                Nous verrons que les expressions régulières étendues dénotent les mêmes langages que les expressions régulières.
            \end{indt}

            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Application}}
                Les expressions régulières (étendues) sont liées aux expressions régulières de la norme POSIX, utilisées par exemple dans la commande \texttt{grep}.

                Exemple :
                \begin{center}
                    \texttt{find | grep -E '.*/d[ms][1/]*\textbackslash .(pdf|tex)\$' | grep 'corrigé'}
                \end{center}
                trouve les fichiers dont le nom contient \texttt{dm} ou \texttt{ds}, d'extension \texttt{.pdf} ou \texttt{.tex}, et dont le nom contient \texttt{corrigé}.
            \end{indt}

            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Définition (\textit{langages des préfixes / suffixes / facteurs})}}
                Soit $L$ un langage sur un alphabet $\Sigma$.

                On défini les langages des préfixes / suffixes de longueur 1 et des facteurs de longueur 2 des mots de $L$ par
                \[
                    \begin{array}{l}
                        P_1(L) = \set{a \in \Sigma\ |\ \exists u \in \Sigma^*\ |\ au \in L}
                        \\
                        S_1(L) = \set{a \in \Sigma\ |\ \exists u \in \Sigma^*\ |\ ua \in L}
                        \\
                        F_2(L) = \set{u \in \Sigma^2\ |\ \exists x, y \in \Sigma^*\ |\ xuy \in L}
                    \end{array}
                \]
            \end{indt}

            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Langages locaux}}
                $\bullet$ \boxed{\rm Exo} pour tout langage $L$ sur un alphabet $\Sigma$,
                \[
                    L \setminus \set \varepsilon
                    \subseteq
                    \lr{P_1(L) \Sigma^* \cap \Sigma^* S_1(L)} \setminus \lr{\Sigma^*\lr{\Sigma^2 \setminus F_2(L)} \Sigma^*}
                \]
                mais cette inclusion peut être stricte.

                \vspace{12pt}
                
                $\bullet$ Définition : Soit $\Sigma$ un alphabet, et $L$ un langage sur $\Sigma$.

                $L$ est \emph{local} si et seulement si
                \[
                    L \setminus \set \varepsilon = \lr{P_1(L) \Sigma^* \cap \Sigma^* S_1(L)} \setminus \lr{\Sigma^*\lr{\Sigma^2 \setminus F_2(L)} \Sigma^*}
                \]

                \vspace{12pt}
                
                \begin{indt}{$\bullet$ Exemples :}
                    $-$ $(ab)^*$ et $(ab)^+$ sont locaux

                    $-$ $P_1 = \set a$, $S_1 = \set b$, et $F_2 = \set{a, b}^2 \setminus \set{ab, ba}$ définissent les langages locaux $\varepsilon$ et $\varnothing$
                \end{indt}

                \vspace{12pt}
                
                $\bullet$ Proposition :
                \begin{emphBox}
                    Tout langage local est dénoté par une expression régulière étendue
                \end{emphBox}

                \vspace{6pt}
                
                \begin{proof}
                    En utilisant la définition et le fait qu'un langage fini est régulier \boxed{\rm Exo}
                \end{proof}

                \vspace{12pt}
                
                $\bullet$ \boxed{\rm Exo} : Donner un algorithme permettant de déterminer $P_1(L)$, $S_1(L)$, $F_2(L)$ pour tout langage régulier.

                Indication : induction sur une expression régulière dénotant $L$.
            \end{indt}

            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Langages linéaires}}
                \label{1.4.5}

                $\bullet$ Définition (\emph{expression régulière linéaire}) : une expression régulière est dite \emph{linéaire} si et seulement si chaque lettre qui la compose n'y apparaît qu'une seule fois.

                \vspace{12pt}
                
                $\bullet$ Exemple : $(ab)^* | cd^*e$ mais pas $(ab^*)|ca$

                \vspace{12pt}
                
                $\bullet$ Définition (\emph{langage linéaire}) : un langage est \emph{linéaire} si et seulement si il est dénoté par une expression régulière linéaire.

                \vspace{12pt}
                
                $\bullet$ Proposition :
                \begin{emphBox}
                    Tout langage linéaire est local.
                \end{emphBox}

                \vspace{6pt}
                
                \begin{proof}
                    $-$ Lemme 1 :
                    \begin{emphBox}
                        \textit{Lemme 1} :
                        Soient $L_1, L_2$ deux langages locaux sur des alphabets disjoints.

                        Alors $L_1 \cup L_2$ est local
                    \end{emphBox}

                    \boxed{\rm Exo}

                    \vspace{6pt}
                    
                    $-$ Lemme 2 :
                    \begin{emphBox}
                        \textit{Lemme 2} :
                        Soient $L_1, L_2$ deux langages locaux sur des alphabets disjoints.

                        Alors $L_1 L_2$ est local.
                    \end{emphBox}

                    \boxed{\rm Exo}

                    Indication : distinguer quatre cas selon que $\varepsilon \in L_1$ ou $\varepsilon \in L_2$.

                    \vspace{12pt}
                    
                    \begin{indt}{$-$ Par induction sur une expression régulière linéaire dénotant le langage}
                        $*$ $\varnothing$ ou $\varepsilon$ : $P_1 = S_1 = F_2 = \varnothing$ conviennent

                        $*$ $a \in \Sigma$ : $P_1 = S_1 = \set a$ et $F_2 = \varnothing$ convient

                        $*$ $e | f$ : par H.I, $\mathcal L(e)$ et $\mathcal L(f)$ sont locaux.

                        De plus, come $e | f$ est linéaire, $e$ et $f$ sont exprimés sur des alphabets disjoints.

                        Donc le lemme 1 conclut.

                        $*$ $ef$ : le même raisonnement avec le lemme 2.

                        $*$ $e^*$ : par H.I, $\mathcal L(e)$ est local, donc
                        \[
                            \mathcal L(e) \setminus \set \varepsilon =
                            \lr{P_1 \Sigma^* \cap \Sigma^* S_1} \setminus \lr{\Sigma^* \lr{\Sigma^2 \setminus F_2} \Sigma^*}
                        \]

                        $P_1(e^*) = P_1(e)$

                        $S_1(e^*) = S_1(e)$

                        $F_2(e^*) = F_2(e) \cup S_1(e) P_1(e)$
                    \end{indt}
                \end{proof}

                \vspace{12pt}
                
                \begin{indt}{$\bullet$ Contre-exemples :}
                    $-$ lemmes 1 et 2 : $L_1 = ab$ et $L_2 = a^*$

                    Si $L_1 \cup L_2$ était local, comme $P_1 = \set a,\ S_1 = \set{a, b},\ F_2 = \set{ab, aa}$, on aurait $aab \in L_1 \cup L_2$ : absurde

                    Si $L_1 L_2$ était local, comme $P_1 = \set a,\ S_1 = \set{a, b},\ \set{ab, ba, aa}$, on aurait $aab \in L_1 L_2$ : absurde

                    \vspace{6pt}
                    
                    $-$ $a(ba)^*$ est local mais non linéaire.
                \end{indt}

                \vspace{12pt}
                
                $\bullet$ Linéarisation : on peut transformer une expression régulière $e$ en expression régulière linéaire $\tilde e$ en numérotant ses lettres (l'alphabet devient $\Sigma \times \nset 1 n$)

                \vspace{12pt}
                
                Exemple : $aa(a | ab)^*b$ devient $a_1a_2(a_3 | a_4b_1)^*b_2$

                C'est une étape importante pour faire le lien entre automates et langages réguliers.

                \boxed{\rm Exo} $\forall u,\ u \in \mathcal L(e) \ssi \exists$ numérotation des lettres de $u$ donnant $\tilde u \in \mathcal L(\tilde e)$
            \end{indt}
        \end{indt}
    \end{indt}

    \vspace{12pt}
    
    \begin{indt}{\section{Automates finis}}
        \label{2}

        \begin{indt}{\subsection{Automates finis déterministes}}
            \begin{indt}{\subsubsection{Introduction}}
                La représentation visuelle de l'algorithme n°\ref{alg:1} (page \pageref{alg:1}) est la representation graphique d'un automate fini déterministe.
                On peut voir un automate comme une machine à états, qui change d'état en fonction des caractères lus sur son entrée. L'entrée est considérée comme valide si l'état final de la machine est approprié.

                Il existe plusieurs notions d'automates, et nous montrerons que toutes celles au programme sont équivalentes.
            \end{indt}

            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Définition (\textit{automate fini déterministe (AFD)})}}
                \label{2.1.2}

                \begin{indt}{Un \emph{automate fini déterministe} est un quintuplet $(\Sigma, Q, q_0, F, \delta)$, où :}
                    $\bullet$ $\Sigma$ est un alphabet ;

                    $\bullet$ $Q$ est un ensemble fini non vide, appelé \emph{ensemble d'états} ;

                    $\bullet$ $q_0 \in Q$ est l'état initial ;

                    $\bullet$ $F \in \mathcal P(Q)$ est l'ensemble des états acceptants / finaux / final / terminaux ;

                    $\bullet$ $\delta : Q \times \Sigma \longrightarrow Q$ est une fonction partielle (\textit{i.e} définie sur une partie de $Q \times \Sigma$) appelée \emph{fonction de transition}.
                \end{indt}

                \vspace{12pt}
                
                \begin{indt}{Représentation graphique :}
                    $\bullet$ Tout état $q \in Q$ est représenté par un cercle ;

                    $\bullet$ L'état initial prend une flèche ;

                    $\bullet$ Les états acceptants sont cerclés deux fois ;

                    $\bullet$ $\forall q, q' \in Q,\ \forall a \in \Sigma\ |\ \delta(q, a) = q'$, on dessine un arc de $q$ à $q'$ étiqueté par $a$.
                \end{indt}

                \vspace{12pt}
                
                Exemple :
                \begin{center}
                    \begin{tikzpicture}
                        \node (q0) at (0, 0) [state, initial, initial text={}] {$q_0$};
                        \node (q1) at (2, 0) [state] {$q_1$};
                        \node (q2) at (4, 0) [state] {$q_2$};
                        \node (q3) at (2, -2) [state, accepting] {$q_3$};

                        \draw[->] (q0) to node [above] {$1$} (q1);
                        \draw[->] (q1) to [out=20, in=160] node [above] {$0$} (q2);
                        \draw[->] (q2) to [out=-160, in=-20] node [below] {$0$} (q1);
                        \draw[->] (q0) to node [below left] {$0$} (q3);
                        \draw[->] (q1) to [out=-70, in=70] node [right] {$1$} (q3);
                        \draw[->] (q3) to [out=110, in=-110] node [left] {$1$} (q1);

                        \draw[->] (q3) to [out=0, in=-50, looseness=3] node [right] {$0$} (q3);
                        \draw[->] (q2) to [out=0, in=-50, looseness=3] node [right] {$1$} (q2);
                    \end{tikzpicture}
                \end{center}

                représente
                \[
                    (\set{0, 1}, \set{q_0, \ldots, q_3}, q_0, \set{q_3}, \delta)
                \]
                où $\delta$ est défini par la table
                \[
                    \begin{array}{c|c|c}
                        & 0 & 1
                        \\
                        \hline
                        q_0 & q_3 & q_1
                        \\
                        \hline
                        q_1 & q_2 & q_3
                        \\
                        \hline
                        q_2 & q_ 1 & q_2
                        \\
                        \hline
                        q_3 & q_3 & q_1
                    \end{array}
                \]
            \end{indt}

            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Modèle de calcul associé}}
                \label{2.1.3}

                $\bullet$ Définition (\emph{transition généralisées}) : Soit $M = (\Sigma, Q, q_0, F, \delta)$ un AFD.

                On généralise la fonction de transition aux mots par :
                \[
                    \begin{cases}
                        \forall q \in Q,\ \delta(q, \varepsilon) = q
                        \\
                        \forall (q, u, a) \in Q \times \Sigma^* \times \Sigma\ |\ (q, a) \in \mathrm{dom}(\delta),\ \delta(q, au) = \delta(\delta(q, a), u)
                    \end{cases}
                \]

                \boxed{\rm Exo} Mq cette définition est équivalente à
                \[
                    \forall (q, u, a) \in Q \times \Sigma^* \times \Sigma,\
                    \delta(q, ua) = \delta(\delta(q, u), a)
                \]
                ou alors
                \[
                    \forall q, q' \in Q,\ \forall u \in \Sigma ^*,\ \delta(q, u) = q'
                \]
                si et seulement si il existe un chemin dans le graphe de l'automate de $q$ à $q'$ tel que la concaténation des étiquettes sur ce chemin vaut $u$.

                \vspace{12pt}
                
                $\bullet$ Définition (\emph{langage reconnu / reconnaissable}) : Soit $M = (\Sigma, Q, q_0, F, \delta)$ un AFD.

                $-$ $u \in \Sigma ^*$ est \emph{accepté} par $M$ ssi $\delta(q_0, u) \in F$

                $-$ Le langage \emph{reconnu} par $M$ est
                \[
                    \mathcal L(M) = \set{u \in \Sigma^*\ |\ u\ \text{accepté par $M$}}
                \]

                $-$ Un langage $L$ sur un alphabet $\Sigma$ est \emph{reconnaissable} ssi il existe un AFD $M$ d'alphabet $\Sigma$ tel que $\mathcal L(M) = L$.

                On note alors $\Rec \Sigma$ l'ensemble des langages reconnaissables sur $\Sigma$.

                \vspace{12pt}
                
                $\bullet$ Exemples :

                $-$ $\set{u \in \set{0, 1}^*\ |\ \lrangle u _2 \equiv 0\ [3]} \in \Rec{\set{0, 1}}$ par \ref{1.1.2} (page \pageref{1.1.2}).

                $-$ On reprend l'AFD vu en \ref{2.1.2} (page \pageref{2.1.2}).
                Pour déterminer $\mathcal L(M)$, on peut utiliser le lemme d'\textsc{Arden}.

                $\forall q \in Q,$ on définit
                \[
                    L_q = \set{u \in \Sigma^*\ |\ \delta(q, u) \in F}
                \]

                On cherche $\mathcal L(M) = L_{q_0}$ sachant :

                \[
                    \begin{cases}
                        L_{q_0} = 0L_{q_3} \cup 1L_{q_1}
                        \\
                        L_{q_1} = 0L_{q_2} \cup 1L_{q_3}
                        \\
                        L_{q_2} = 0L_{q_1} \cup 1L_{q_2}
                        \\
                        L_{q_3} = 0L_{q_3} \cup 1L_{q_1} \cup \set \varepsilon
                    \end{cases}
                \]

                \boxed{\rm Exo} Mq $\mathcal L(M) = (1(01^*0)^*1|0)^*$
            \end{indt}

            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Automate complet}}
                $\bullet$ Définition (\emph{Automate complet}) : un AFD est dit \emph{complet} ssi sa fonction de transition est totale.

                \vspace{12pt}
                
                $\bullet$ Exemple : les automates en \ref{1.1.2} (page \pageref{1.1.2}) et \ref{2.1.2} (page \pageref{2.1.2}).

                \vspace{12pt}
                
                $\bullet$ Complétion : étant donné un AFD $M = (\Sigma, Q, q_0, F, \delta)$ incomplet, on peut construire $M'$ complet reconnaissant $\mathcal L(M)$ en ajoutant un état dit \emph{poubelle / puits}, vers lequel vont toutes les transitions non définies de $\delta$.

                \[
                    M' = (\Sigma, Q \cup \set \Pi, q_0, F, \delta')
                \]
                où $\Pi \notin Q$, et
                \[
                    \forall q \in Q \cup \set \Pi,\ \forall a \in \Sigma,\
                    \delta'(q, a) =
                    \begin{cases}
                        \delta(q, a)
                        & \text{si}\ (q, a) \in \mathrm{dom}(\delta)
                        \\
                        \Pi
                        & \text{sinon}
                    \end{cases}
                \]

                \vspace{12pt}
                
                $\bullet$ Proposition :
                \begin{emphBox}
                    $M'$ est complet, et $\mathcal L(M') = \mathcal L(M)$
                \end{emphBox}

                \vspace{6pt}
                
                \begin{proof}
                    $M'$ est complet par définition.

                    Si $u \in \mathcal L(M)$, on remarque que toutes les transitions suivies dans $M$ lors de la lecture de $u$ sont définies, et ce sont les mêmes dans $M'$, donc $u \in \mathcal L(M')$ (récurrence finie, en notant $u = u_1 \cdots u_n$, et $\forall i \in \nset 1 n,\ q_i = \delta(q_0, u_1 \cdots, u_i)$ \boxed{\rm Exo}).

                    \vspace{6pt}
                    
                    Si $u \in \mathcal L(M')$, on remarque qu'il n'existe pas de transition étiquetée par un préfixe de $u$ menant à l'état $\Pi$ (sinon $\delta'(q_0, u) = \Pi \notin F$) donc toutes ces transitions sont aussi définies dans $M$ et $u \in \mathcal L(M)$.
                \end{proof}

                \vspace{12pt}
                
                $\bullet$ Exemple :

                \begin{center}
                    \begin{tikzpicture}
                        \node (0) at (0, 0) [initial, initial text={}, state] {$q_0$};
                        \node (1) at (2, 0) [state] {$q_1$};
                        \node (2) at (4, 0) [state, accepting] {$q_2$};

                        \draw[->] (0) to node [above] {$a$} (1);

                        \draw[->] (1) to [out=20, in=160] node [above] {$b$} (2);
                        \draw[->] (2) to [out=-160, in=-20] node [below] {$a$} (1);
                    \end{tikzpicture}
                \end{center}

                Devient :
                \begin{center}
                    \begin{tikzpicture}
                        \node (0) at (0, 0) [initial, initial text={}, state] {$q_0$};
                        \node (1) at (2, 0) [state] {$q_1$};
                        \node (2) at (4, 0) [state, accepting] {$q_2$};
                        \node (pi) at (2, -2) [state] {$\Pi$};

                        \draw[->] (0) to node [above] {$a$} (1);
                        \draw[->] (0) to node [below left] {$b$} (pi);
                        \draw[->] (1) to node [right] {$a$} (pi);
                        \draw[->] (2) to node [below right] {$b$} (pi);

                        \draw[->] (1) to [out=20, in=160] node [above] {$b$} (2);
                        \draw[->] (2) to [out=-160, in=-20] node [below] {$a$} (1);

                        \draw[->] (pi) to [out=-45, in=-90, looseness=4] node [below] {$a, b$} (pi);
                    \end{tikzpicture}
                \end{center}
            \end{indt}

            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Automate standard}}
                $\bullet$ Définition : Un AFD est dit \emph{standard} ssi aucune transistion ne mène à l'état initial.

                \vspace{12pt}
                
                $\bullet$ Exemple : l'automate en \ref{2.1.2} (page \pageref{2.1.2}), mais pas celui en \ref{1.1.2} (page \pageref{1.1.2}).

                \vspace{12pt}
                
                $\bullet$ Standardisation : si $M = (\Sigma, Q, q_0, F, \delta)$ est un AFD non standard, on construit un AFD $M'$ standard reconnaissant $\mathcal L(M)$ en ajoutant un nouvel état initial qui ne sert que pour la première transition.

                On définit $M' = (\Sigma, Q \cup \set \iota, \iota, F', \delta')$, où $\iota \notin Q$,
                \[
                    F' =
                    \begin{cases}
                        F
                        & \text{si}\ q_0 \notin F
                        \\
                        F \cup \set \iota
                        & \text{sinon}
                    \end{cases}
                \]
                \[
                    \forall (q, a) \in (Q \cup \set \iota) \times \Sigma,\
                    \delta'(q, a) =
                    \begin{cases}
                        \delta(q, a)
                        & \text{si}\ (q ,a) \in \mathrm{dom}(\delta)
                        \\
                        \delta(q_0, a)
                        & \text{si}\ \iota = q\ \text{et}\ (q_0, a) \in \mathrm{dom}(\delta)
                        \\
                        \text{non définie}
                        & \text{sinon}
                    \end{cases}
                \]

                \boxed{\rm Exo} $M'$ est standard, et $\mathcal L(M') = \mathcal L(M)$.

                \vspace{12pt}
                
                $\bullet$ Exemple :

                \begin{center}
                    \begin{tikzpicture}
                        \node (0) at (0, 0) [initial, initial text={}, state, accepting] {$q_0$};
                        \node (1) at (2, 0) [state] {$q_1$};
                        \node (2) at (4, 0) [state, accepting] {$q_2$};

                        \draw[->] (0) to node [above] {$a$} (1);

                        \draw[->] (1) to [out=20, in=160] node [above] {$b$} (2);
                        \draw[->] (2) to [out=-160, in=-20] node [below] {$a$} (1);

                        \draw[->] (1) to [out=45, in=90, looseness=3] node [above] {$a$} (1);

                        \draw[->] (0) to [out=45, in=90, looseness=3] node [above] {$b$} (0);
                    \end{tikzpicture}
                \end{center}

                Devient :
                \begin{center}
                    \begin{tikzpicture}
                        \node (0) at (0, 0) [state, accepting] {$q_0$};
                        \node (1) at (2, 0) [state] {$q_1$};
                        \node (2) at (4, 0) [state, accepting] {$q_2$};
                        \node (i) at (2, -2) [state, initial, initial text={}, accepting] {$\iota$};

                        \draw[->] (0) to node [above] {$a$} (1);
                        \draw[->] (i) to node [below left] {$b$} (0);
                        \draw[->] (i) to node [right] {$a$} (1);
                        %\draw[->] (i) to node [below right] {$b$} (2);

                        \draw[->] (1) to [out=20, in=160] node [above] {$b$} (2);
                        \draw[->] (2) to [out=-160, in=-20] node [below] {$a$} (1);

                        \draw[->] (0) to [out=45, in=90, looseness=3] node [above] {$b$} (0);
                    \end{tikzpicture}
                \end{center}
            \end{indt}

            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Automate émondé}}
                $\bullet$ Idée : certains états peuvent être inutiles du point de vue du modèle de calcul.

                Par exemple, l'état puits d'un complété n'apporte rien au langage reconnu.
                De même un état qui ne serait pas accessible depuis l'état initial est inutile.

                \vspace{12pt}
                
                \begin{indt}{$\bullet$ Définition (\emph{états accessibles / co-accessibles, utiles}) : Soit $M = (\Sigma, Q, q_0, F, \delta)$ un AFD, et $q \in Q$.}
                    $-$ $q$ est dit \emph{accessible} ssi $\exists u \in \Sigma^*\ |\ \delta(q_0, u) = q$

                    $-$ $q$ est dit \emph{co-accessible} ssi $\exists u \in \Sigma^*\ |\ \delta(q, u) \in F$

                    $-$ $q$ est dit \emph{utile} ssi $q$ est accessible et co-accessible.
                \end{indt}

                \vspace{12pt}
                
                $\bullet$ Remarque : il est possible de déterminer les états accessibles grâce à un parcours depuis l'état initial, les états co-accessibles grâce à un parcours du graphe transposé du graphe de l'automate à partir des états acceptants, et les états utiles grâce à deux parcours.

                \vspace{12pt}
                
                $\bullet$ Définition (\emph{automate émondé}) : Un automate est dit \emph{émondé} ssi tous ses états sont utiles.

                \vspace{12pt}
                
                $\bullet$ \boxed{\rm Exo} Supprimer les états inutiles donne un AFD émondé reconnaissant le même langage.

                \vspace{12pt}
                
                $\bullet$ Remarque : Disposer d'un automate émondé reconnaissant un langage donné n'assure pas d'avoir l'information minimale permettant de caractériser ce langage.

                Exemple :

                \begin{center}
                    \begin{tikzpicture}
                        \node (0) at (0, 0) [state, accepting, initial, initial text={}] {$q_0$};
                        \node (1) at (2, 0) [state, accepting] {$q_1$};

                        \draw[->] (0) to node [above] {$a, b$} (1);
                        \draw[->] (1) to [out=45, in=90, looseness=3] node [above right] {$a, b$} (1);

                        \node at (3.75, 0) {et};

                        \node (0') at (6, 0) [state, accepting, initial, initial text={}] {$q_0$};
                        \draw[->] (0') to [out=45, in=90, looseness=3] node [above right] {$a, b$} (0');
                    \end{tikzpicture}
                \end{center}

                sont deux automates émondés reconnaissant le même langage ($\Sigma^*$, avec $\Sigma = \set{a, b}$)

                \vspace{12pt}
                
                $\bullet$ (H.P) Un automate reconnaissant un langage donné et ayant un nombre minimal d'états est appelé \emph{automate minimal} du langage et on peut montrer que l'automate minimal d'un langage donné est émondé et unique (à isomorphisme près).
            \end{indt}

            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Automate local}}
                \label{2.1.7}

                $\bullet$ Remarque :
                Un langage local est caractérisé par la connaissance des lettres qui peuvent débuter / terminer un mot du langage et des lettres qui peuvent succéder à une lettre donnée dans un mot de langage. En particulier, la connaissance de la dernière lettre lue permet de connaître les lettres qui peuvent suivre, ce qui fait des langages locaux de bon candidats pour l'appartenance à $\Rec \Sigma$.

                \vspace{12pt}
                
                $\bullet$ Exemple : $a(b^* | c)$, $P_1 = \set a$, $S_1 = \set{a, b, c}$, $F_2 = \set{ab, ac, bb}$

                Idée : on associe un état à chaque lettre lue.

                \begin{center}
                    \begin{tikzpicture}
                        \node (ep) at (-2, 0) [state, initial, initial text={}] {$q_\varepsilon$};
                        \node (a) at (0, 0) [state, accepting] {$q_a$};
                        \node (b) at (2, 0) [state, accepting] {$q_b$};
                        \node (c) at (-45 : 2) [state, accepting] {$q_c$};

                        \draw[->] (ep) to node [above] {$a$} (a);
                        \draw[->] (a) to node [above] {$b$} (b);
                        \draw[->] (a) to node [below left] {$c$} (c);

                        \draw[->] (b) to [out=45, in=90, looseness=3] node [above right] {$b$} (b);
                    \end{tikzpicture}
                \end{center}

                \vspace{12pt}
                
                $\bullet$ Définition (\emph{automate local}) : Soit $M = (\Sigma, Q, q_0, F, \delta)$ un AFD.

                $M'$ est dit \emph{local} ssi
                \[
                    \forall a \in \Sigma,\ \exists q \in Q\ |\ \forall q' \in Q,\
                    (q', a) \in \mathrm{dom}(\delta) \Rightarrow \delta(q', a) = q
                \]

                \vspace{12pt}
                
                $\bullet$ Proposition :
                \begin{emphBox}
                    Soit $\Sigma$ un alphabet, et $L$ un langage sur $\Sigma$.

                    \[
                        L\ \text{est local}
                        \ssi
                        \exists M = (\Sigma, Q, q_0, F, \delta)\ \text{un AFD local}\ |\
                        \mathcal L(M) = L
                    \]
                \end{emphBox}

                \vspace{6pt}
                
                \begin{proof}
                    \boxed{\Rightarrow} On sait que
                    \[
                        L \setminus \set \varepsilon = \lr{P_1(L) \Sigma^* \cap \Sigma^*S_1(L)} \setminus \lr{\Sigma^*\lr{\Sigma^2 \setminus F_2(L)} \Sigma^*}
                        \qquad (*)
                \]

                On définit $M = (\Sigma, Q, q_\varepsilon, F, \delta)$, où
                \[
                    Q = \set{q_\varepsilon} \cup \set{q_a\ |\ a \in \Sigma}
                \]
                \[
                    F =
                    \begin{cases}
                        \set{q_a\ |\ a \in S_1(L)}
                        & \text{si}\ \varepsilon \notin L
                        \\
                        \set{q_a\ |\ a \in S_1(L)} \cup \set{q_\varepsilon}
                        & \text{sinon}
                    \end{cases}
                \]
                \[
                    \forall (q ,a) \in Q \times \Sigma,\
                    \delta(q, a) =
                    \begin{cases}
                        q_a
                        & \text{si}\ q = q_\varepsilon\ \text{et}\ a \in P_1(L)
                        \\
                        q_a
                        & \text{si}\ q = q_b\ \text{et}\ ba \in F_2(L)
                        \\
                        \text{non définie}
                        & \text{sinon}
                    \end{cases}
                \]

                Alors $M$ est local (même standard) et $\mathcal L(M) = L$

                On le montre par double inclusion en utilisant l'égalité $(*)$ \boxed{\rm Exo}.

                \vspace{12pt}
                
                \boxed{\Leftarrow} On sait que $L = \mathcal L(M)$ où $M = (\Sigma, Q, q_0, F, \delta)$ est un AFD local.

                \[
                    \forall a \in \Sigma,\ \exists q_a \in Q\ |\ \forall q' \in Q,\
                    (q', a) \in \mathrm{dom}(\delta) \Rightarrow \delta(q', a) = q_a
                \]

                On définit
                \[
                    \begin{array}{l}
                        P_1 = \set{a \in \Sigma\ |\ (q_0, a) \in \mathrm{dom}(\delta)}
                        = \set{a \in \Sigma\ |\ \delta(q_0, a) = q_a}
                        \\
                        S_1 = \set{a \in \Sigma\ |\ q_a \in F}
                        \\
                        F_2 = \set{ab \in \Sigma^2\ |\ (q_a, b) \in \mathrm{dom}(\delta)}
                    \end{array}
                \]

                On vérifie alors que
                \[
                    L \setminus \set \varepsilon
                    = (P_1 \Sigma^* \cap \Sigma^* S_1) \setminus \lr{\Sigma^* \lr{\Sigma^2 \setminus F_2} \Sigma^*}
                \]

                \boxed{\subseteq} Soit $u = u_1 \cdots u_n \in L \setminus \set \varepsilon$.

                $u \in \mathcal L(M)$, donc $\forall i \in \nset 1 n,\ \delta(q_0, u_1 \cdots u_i)$ est bien défini, notons le $q_i$.

                $(q_0, q_i) \in \mathrm{dom}(\delta)$, donc $u_1 \in P_1$.

                $q_{u_n} = \delta(q_0, u_1 \cdots u_n) \in F$, donc $u_n \in S_1$.

                $\forall i \in \nset 1 {n - 1}$,
                \[
                    \begin{array}{rcl}
                        \delta(q_0, u_1 \cdots u_{i + 1})
                        &=& \delta(\delta(q_0, u_1 \cdots u_i), u_{i + 1})
                        \\
                        &=& \delta(q_i, u_{i + 1})
                        \\
                        &=& q_i
                    \end{array}
                \]

                Donc $u_i u_{i + 1} \in F_2$, donc
                \[
                    u \in (P_1 \Sigma^* \cap \Sigma^* S_1) \setminus \lr{\Sigma^* \lr{\Sigma^2 \setminus F_2} \Sigma^*}
                \]

                \vspace{6pt}
                
                \boxed{\supseteq} par récurrence sur la taille du mot \boxed{\rm Exo}.
                \end{proof}
            \end{indt}
        \end{indt}

        \vspace{12pt}
        
        \begin{indt}{\subsection{Automates finis non déterministes (AFND)}}
            \begin{indt}{\subsubsection{Introduction}}
                Il peut être complexe, ou simplement fastidieux, de concevoir un AFD reconnaissant un langage donné.

                \vspace{12pt}
                
                Exemple : digicode : on entre une série de chiffres, et si elle se termine par le code enregistré, la porte se débloque.
                Cela correspond au fonctionnement d'un automate, mais la difficulté vient fu fait que même si le début du code est entré, il faut pouvoir revenir en arrière si la suite est invalide.

                Idée : on compte le nombre de chiffres valides lus consécutivement et on met à jour ce nombre en fonction des chiffres lus.

                Par exemple, pour le code 4242, on peut écrire le programme suivant :

                \begin{lstlisting}[language=Caml, xleftmargin=80pt]
let nb_valides = ref 0 in
while !nb_valides < 4 do
    let n = read_int () in
    match !nb_valides, n with
    | 0, 4 | 1, 2 | 2, 4 | 3, 2 -> incr nb_valides
    | _, 4 -> nb_valides := 1
    | _ -> nb_valides := 0
done;
unlock_door()\end{lstlisting}
                
                En associant un état à chaque valeur possible de \texttt{nb\_valides}, ce code correspond à l'automate

                \begin{center}
                    \begin{tikzpicture}[scale=1.5]
                        \node (0) at (0, 0) [state, initial, initial text={}] {$0$};
                        \node (1) at (2, 0) [state] {$1$};
                        \node (2) at (4, 0) [state] {$2$};
                        \node (3) at (6, 0) [state] {$3$};
                        \node (4) at (8, 0) [state, accepting] {$4$};

                        \draw[->] (0) to node [above] {$4$} (1);
                        \draw[->] (1) to node [above] {$2$} (2);
                        \draw[->] (2) to node [above] {$4$} (3);
                        \draw[->] (3) to node [above] {$2$} (4);

                        \draw[->] (1) to [out=45, in=90, looseness=3] node [above right] {$4$} (1);
                        \draw[->] (0) to [out=-90, in=-135, looseness=3] node [below left] {${0 - 3, 5 - 9}$} (0);
                        \draw[->] (2) to [out=100, in=40, looseness=1] node [above right] {${0 - 3, 5 - 9}$} (0);
                        \draw[->] (1) to [out=-120, in=-40] node [below right] {${0, 1, 3, 5 - 9}$} (0);
                        \draw[->] (3) to [out=-100, in=-50, looseness=.8] node [below right] {${0, 1, 3, 5-9}$} (0);
                        \draw[->] (3) to [out=-135, in=-15] node [below right] {$4$} (1);
                    \end{tikzpicture}
                \end{center}

                Cet automate contient de nombreuses informations ``parasites'', liées uniquement à la gestion des erreurs de l'entrée. On peut simplifier sa présentation en changeant le modèle de calcul et en exploitant le principe de retour sur trace.

                Idée : depuis l'état 0, si on lit un 4, cela peut être le début d'une séquence valide donc on passe dans l'état 1, mais si une erreur survient dans la suite de la séquence, on revient sur ce choix et on décide que la lecture de ce 4 conserve l'état 0.

                Graphiquement, cela simplifie l'automate en :

                \begin{center}
                    \begin{tikzpicture}
                        \node (0) at (0, 0) [state, initial, initial text={}] {$0$};
                        \node (1) at (2, 0) [state] {$1$};
                        \node (2) at (4, 0) [state] {$2$};
                        \node (3) at (6, 0) [state] {$3$};
                        \node (4) at (8, 0) [state, accepting] {$4$};

                        \draw[->] (0) to node [above] {$4$} (1);
                        \draw[->] (1) to node [above] {$2$} (2);
                        \draw[->] (2) to node [above] {$4$} (3);
                        \draw[->] (3) to node [above] {$2$} (4);

                        \draw[->] (0) to [out=-90, in=-135, looseness=4] node [below] {$0 - 9$} (0);
                    \end{tikzpicture}
                \end{center}

                L'algorithme de retour sur trace revient à parcourir ce graphe selon les lettres lues en essayant de passer dans l'état 1 dès que possible et en revenant sur ce choix en cas d'impossibilité.
                Ce type d'automate est appelé \emph{non déterministe} car on peut le voir comme une machine pouvant être dans plusieurs états à la fois (par exemple 0 et 1 après la lecture d'un 4 depuis l'état 0).
                Lorsqu'une transition est impossible, la machine n'est plus dans l'état associé (idée du retour sur trace), et l'objectif est que l'un des états de la machine sont acceptant en fin de lecture.
            \end{indt}

            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Définition (\textit{Automate fini non déterministe})}}
                \begin{indt}{Un \emph{automate fini non déterministe} (AFND) est un quintuplet $M = (\Sigma, Q, I, F, \delta)$}
                    $-$ $\Sigma$ est un alphabet ;

                    $-$ $Q$ est un ensemble fini non vide d'états ;

                    $-$ $I \subseteq Q$ est l'ensemble des états initiaux ;

                    $-$ $F \subseteq Q$ est l'ensemble des états acceptants ;

                    $-$ $\delta : Q \times \Sigma \longrightarrow \mathcal P(Q)$
                \end{indt}

                \vspace{12pt}
                
                Remarque : $\delta$ est totale, mais son image peut être vide pour certains couples.

                \vspace{12pt}
                
                Représentation graphique : comme les AFD, avec un arc $q \overset a \longrightarrow q'$ $\forall (q, q', a) \in Q^2 \times \Sigma\ |\ q' \in \delta(q, a)$.
            \end{indt}

            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Modèle de calcul associé}}
                $\bullet$ Définition (\emph{transition généralisées}) : Soit $M = (\Sigma, Q, I, F, \delta)$ un AFND.

                On généralise $\delta$ aux mots en définissant $\forall q \in Q,\ \delta(q, \varepsilon) = \set q$, et
                \[
                    \forall (q, u, a) \in Q \times \Sigma^* \times \Sigma,\
                    \delta(q, au) = \bigcup_{q' \in \delta(q, a)} \delta(q', u)
                \]

                \boxed{\rm Exo} Montrer que c'est équivalent à :
                \[
                    \forall (q, u, a) \in Q \times \Sigma^* \times \Sigma,\
                    \delta(q, ua) = \bigcup_{q' \in \delta(q, u)} \delta(q', a)
                \]

                \vspace{12pt}
                
                \begin{indt}{$\bullet$ Définition (\emph{langage reconnu}) : Soit $M = (\Sigma, Q, I, F, \delta)$ un AFND.}
                    $-$ $\forall u \in \Sigma^*$, $u$ est accepté par $M$ si et seulement si
                    \[
                        \lr{\bigcup_{q_0 \in I} \delta(q_0, u)} \cap F \neq \varnothing
                    \]

                    $-$ Le langage reconnu par $M$ est
                    \[
                        \mathcal L(M) = \set{u \in \Sigma^*\ |\ M\ \text{acceptable}\ u}
                    \]
                \end{indt}

                \vspace{12pt}
                
                $\bullet$ Proposition :
                \begin{emphBox}
                    Soit $M = (\Sigma, Q, I, F, \delta)$ un AFND, et $u \in \Sigma^*$

                    Alors $u \in \mathcal L(M) \ssi$ il existe un chemin $q_0 \cdots q_n$ dans le graphe de $M$ avec $q_0 \in I,\ q_n \in F$, et la concaténation des étiquettes sur ce chemin est $u$.
                \end{emphBox}

                \vspace{6pt}
                
                \begin{proof}
                    \boxed{\Leftarrow} On montre que $\forall i \in \nset 0 n,\ q_i \in \delta(q_0, u_1 \cdots u_i)$ (on note $u = u_1 \cdots u_i$)

                    $-$ $i = 0$ : $\delta(q_0, u_1 \cdots u_0) = \delta(q_0, \varepsilon) = \set{q_0} \ni q_0$

                    $-$ Hérédité : si $i \in \nset 1 {n - 1}\ |\ q_i \in \delta(q_0, u_1 \cdots u_i)$, alors
                    \[
                        \bigcup_{q \in \delta(q_0, u_1 \cdots u_i)} \delta(q, u_{i + 1}) \supseteq \delta(q_i, u_{i + 1}) \ni q_{i + 1}
                    \]
                    (car $q_i \overset{u_{i + 1}}\longrightarrow q_{i + 1}$)

                    Finalement, $q_n \in F \cap \delta(\underbrace{q_0}_{\in I}, \underbrace{u_1 \cdots u_n}_u)$, donc $u \in \mathcal L(M)$.

                    \vspace{12pt}
                    
                    \boxed{\Rightarrow} $\exists q_0 \in I,\ \exists q_n \in F\ |\ q_n \in \delta(q_0, u)$.

                    On montre qu'il existe, $\forall i \in \nset 0 n$ un chemin $q_i \cdots q_n$ étiqueté par $u_{i + 1} \cdots u_n$ avec $q_i \in \delta(q_0, u_1 \cdots u_i)$.

                    \vspace{6pt}
                    
                    $-$ $i = n$, $q_n \in \delta(q_0, u_1 \cdots u_n)$, et le chemin vide étiqueté par $\varepsilon = u_{n + 1}u_n$.

                    \vspace{6pt}
                    
                    $-$ Hérédité : si $i \in \nset 1 n\ |\ \exists q_i \cdots q_n$ un chemin étiqueté par $u_{i + 1} \cdots u_n$ avec $q_i \in \delta(q_0, u_1 \cdots u_i)$, alors

                    \[
                        q_i \in \delta(q_0, u_1 \cdots u_i) = \bigcup_{q \in \delta(q_0, u_1 \cdots u_{i - 1})} \delta(q, u_i)
                    \]

                    Donc $\exists q_{i - 1} \in \delta(q_0, u_1 \cdots u_{i - 1})\ |\ q_i \in \delta(q_{i - 1}, u_i)$.

                    Le chemin $q_{i - 1}, q_n$ est étiqueté par $u_{i} \cdots u_n$.

                    Finalement, on a construit un chemin $q_0 \cdots q_n$ convenable.
                \end{proof}
            \end{indt}

            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Déterminisation}}
                \label{2.2.4}

                $\bullet$ Théorème :
                \begin{emphBox}
                    Soit $\Sigma$ un alphabet, et $L$ un langage sur $\Sigma$.

                    \[
                        L \in \Rec \Sigma \ssi
                        \exists M = (\Sigma, Q, I, F, \delta)\ \text{un AFND}\ |\ \mathcal L(M) = L
                    \]
                \end{emphBox}

                \vspace{12pt}
                
                \begin{proof}
                    \boxed{\Rightarrow} Si $M = (\Sigma, Q, q_0, F, \delta)$ est un AFD tel que $L = \mathcal L(M)$, on construit $M' = (\Sigma, Q, \set{q_0}, F, \delta')$, où $\forall q \in Q, \forall a \in \Sigma$,
                    \[
                        \delta'(q, a) =
                        \begin{cases}
                            \set{\delta(q, a)}
                            & \text{si}\ (q, a) \in \mathrm{dom}(\delta)
                            \\
                            \varnothing
                            & \text{sinon}
                        \end{cases}
                    \]

                    Les graphes de $M$ est $M'$ sont identiques, donc $L = \mathcal L(M) = \mathcal L(M')$.

                    \vspace{12pt}
                    
                    \boxed{\Leftarrow} On construit l'automate des parties
                    \[
                        M' = (\Sigma, \mathcal P(Q), I, F', \delta')
                    \]
                    où
                    \[
                        \begin{array}{l}
                            F' = \set{E \in \mathcal P(Q) \ |\ E \cap F \neq \varnothing}
                            \\
                            \forall E \in \mathcal P(Q), \forall a \in \Sigma,\
                            \delta'(E, a) = \displaystyle \bigcup_{q \in E} \delta(q, a)
                        \end{array}
                    \]

                    $M'$ est un AFD.

                    On montre par récurrence que
                    \[
                        \forall (n, u) \in \N \times \Sigma^*\ |\ \abs u = n,\
                        \delta'(I, u) = \bigcup_{q_0 \in I} \delta(q_0, u)
                    \]

                    $-$ $n = 0$ : $u = \varepsilon$ est le seul mot possible, et
                    \[
                        \delta'(I, \varepsilon) = I = \bigcup_{q_0 \in I} \set{q_0} = \bigcup_{q_0 \in I} \delta(q_0, \varepsilon)
                    \]

                    $-$ Hérédité : Soit $n \in \N\ |\ \forall u \in \Sigma^*\ |\ n = \abs u,\ \delta'(I, u) = \displaystyle \bigcup_{q_0 \in I} \delta (q_0, u)$.

                    Soit $u \in \Sigma^*\ |\ \abs u = n + 1$. Alors $u$ s'écrit $u = va$ avec $v \in \Sigma^*, a \in \Sigma\ |\ \abs v = n$.

                    \[
                        \begin{array}{rcl}
                            \delta'(I, u)
                            &=& \delta'(I, va)
                            \vspace{3pt}
                            \\
                            &=& \displaystyle \bigcup_{q \in \delta'(I, v)} \delta'(q, a)
                            \vspace{3pt}
                            \\
                            &=& \displaystyle \bigcup_{q_0 \in I} \bigcup_{q \in \delta(q_0, u)} \delta(q, a)
                            \vspace{3pt}
                            \\
                            &=& \displaystyle \bigcup_{q_0 \in I} \delta(q_0, \varepsilon)
                        \end{array}
                    \]

                    Soit $u \in \Sigma^*$.

                    \[
                        \begin{array}{rcl}
                            u \in L
                            &\ssi& u \in \mathcal L(M)
                            \\
                            &\ssi& \displaystyle \bigcup_{q_0 \in I} \delta(q_0, u) \cap F \neq \varnothing
                            \\
                            &\ssi& \delta'(I, u) \cap F \neq \varnothing
                            \\
                            &\ssi& \delta'(I, u) \in F'
                            \\
                            &\ssi& u \in \mathcal L(M')
                        \end{array}
                    \]
                \end{proof}

                \vspace{12pt}
                
                $\bullet$ Remarque : l'automate des parties est complet et possède un nombre d'états exponentiel en le nombre d'états de l'AFND associé. On peut réduire ce nombre d'états en ne considérant que les ensembles d'états de l'AFND qui sont accessibles depuis $I$.
                L'algorithme de déterminisation accessible s'exprime ainsi :

                \vspace{6pt}
                
                \begin{indalgo}{Déterminisation accessible}
                    \label{alg:2}

                    $E \gets \set I$\;

                    \While{$\exists P \in E$ pas encore traité}{
                        $\forall a \in \Sigma$, construire $\delta'(P, a)$ et l'ajouter à $E$\;
                    }
                \end{indalgo}

                \vspace{12pt}
                
                Exemple : $L = (a | b)^*baa$ est reconnu par l'AFND

                \begin{center}
                    \begin{tikzpicture}
                        \node (0) at (0, 0) [state, initial, initial text={}] {$q_0$};
                        \node (1) at (2, 0) [state] {$q_1$};
                        \node (2) at (4, 0) [state] {$q_2$};
                        \node (3) at (6, 0) [state, accepting] {$q_3$};

                        \draw[->] (0) to node [above] {$b$} (1);
                        \draw[->] (1) to node [above] {$a$} (2);
                        \draw[->] (2) to node [above] {$a$} (3);

                        \draw[->] (0) to [out=45, in=90, looseness=3] node [above right] {$a, b$} (0);
                    \end{tikzpicture}
                \end{center}

                \[
                    \begin{array}{lllll}
                        & \set{q_0} & \set{q_0, q_1} & \set{q_0, q_2} & \set{q_0, q_3}
                        \\
                        a & \set{q_0} & \set{q_0, q_2} & \set{q_0, q_3} & \set{q_0}
                        \\
                        b & \set{q_0, q_1} & \set{q_0, q_1} & \set{q_0, q_1} & \set{q_0, q_1}
                    \end{array}
                \]

                L'AFD obtenu est :

                \begin{center}
                    \begin{tikzpicture}[scale=1.5]
                        \node (0) at (0, 0) [state, initial, initial text={}] {$\set{q_0}$};
                        \node (1) at (2, 0) [state] {$\set{q_0, q_1}$};
                        \node (2) at (0, -2) [state, accepting] {$\set{q_0, q_3}$};
                        \node (3) at (2, -2) [state] {$\set{q_0, q_2}$};

                        \draw[->] (0) to node [above] {$b$} (1);
                        \draw[->] (2) to node [left] {$a$} (0);
                        \draw[->] (2) to node [above left] {$b$} (1);
                        \draw[->] (3) to node [below] {$a$} (2);

                        \draw[->] (1) to [out=-110, in=110] node [left] {$a$} (3);
                        \draw[->] (3) to [out=70, in=-70] node [right] {$b$} (1);

                        \draw[->] (1) to [out=45, in=90, looseness=3] node [above right] {$b$} (1);
                        \draw[->] (0) to [out=45, in=90, looseness=3] node [above right] {$a$} (0);
                    \end{tikzpicture}
                \end{center}

                \boxed{\rm Exo} le langage $(a|b)^*a(a|b)^n$ est reconnu par un AFND à $n + 2$ états mais un AFD reconnaissant ce langage a au moins $2^{n + 1}$ états.
            \end{indt}

            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Propriétés de clôture sur $\Rec \Sigma$}}
                $\bullet$ Clôture par complémentation : Soit $L \in \Rec \Sigma$.
                Alors
                \[
                    \Sigma^* \setminus L \in \Rec \Sigma
                \]

                \begin{proof}
                    $\exists M = (\Sigma, Q, q_0, F, \delta)$ un AFD complet tel que $L = \mathcal L(M)$.

                    On considère $M' = (\Sigma, Q, q_0, Q \setminus F, \delta)$.

                    \(
                        \begin{array}{rcll}
                            u \in \mathcal L(M')
                            &\ssi& \delta(q_0, u) \in Q \setminus F
                            \\
                            &\ssi& \delta(q_0, u) \notin F
                            & \text{car}\ \delta(q_0, u)\  \text{existe car $M$ est complet}
                            \\
                            &\ssi& u \notin \mathcal L(M)
                            \\
                            &\ssi& u \in \Sigma^* \setminus L
                        \end{array}
                    \)

                \end{proof}

                \vspace{12pt}
                
                $\bullet$ Clôture par union : Soient $L_1, L_2 \in \Rec \Sigma$.

                Alors :
                \[
                    L_1 \cup L_2 \in \Rec \Sigma
                \]

                \begin{proof}
                    Idée : on lit le mot dans les deux automates en parallèle et on accepte si l'un des deux accepte.

                    \[
                        \forall i \in \set{1, 2},\ \exists M_i = (\Sigma, Q_i, I_i, F_i, \delta_i)\ |\ \mathcal L(M_i) = L_i
                    \]

                    On construit
                    \[
                        M = \lr{\Sigma,\ Q_1 \uplus Q_2,\ I_1 \uplus I_2,\ F_1 \uplus F_2,\ \delta}
                    \]

                    où $\forall q \in Q_1 \uplus Q_2,\ \forall a \in \Sigma,$
                    \[
                        \delta(q, a) =
                        \begin{cases}
                            \delta_1(q, a)
                            & \text{si}\ q \in Q_1
                            \\
                            \delta_2(q, a)
                            & \text{si}\ q \in Q_2
                        \end{cases}
                    \]

                    \boxed{\rm Exo} $\mathcal L(M) = L_1 \cup L_2$
                \end{proof}

                \vspace{12pt}
                
                $\bullet$ Clôture par intersection :
                Soient $L_1, L_2 \in \Rec \Sigma$.

                Alors
                \[
                    L_1 \cap L_2 \in \Rec \Sigma
                \]

                \begin{proof}
                    On a :
                    \[
                        \forall i \in \set{1, 2},\ \exists M_i = (\Sigma, Q_i, I_i, F_i, \delta_i)\ |\ \mathcal L(M_i) = L_i
                    \]

                    On construit l'automate produit $M = (\Sigma, Q_1 \times Q_2,\ I_1 \times I_2,\ F_1 \times F_2,\ \delta)$, où :
                    \[
                        \forall (q_1, q_2) \in Q_1 \times Q_2,\ \forall a \in \Sigma,\ \delta((q_1, q_2), a) = \delta_1(q_1, a) \times \delta_2(q_2, a)
                    \]

                    \boxed{\rm Exo} $\mathcal L(M) = \mathcal L(M_1) \cap \mathcal L(M_2)$
                \end{proof}

                \vspace{12pt}
                
                $\bullet$ Clôture par concaténation : Soient $L_1, L_2 \in \Rec \Sigma$.

                Alors :
                \[
                    L_1 L_2 \in \Rec \Sigma
                \]

                \begin{proof}
                    Idée : on met bout à bout les automates en passant du premier au second de manière déterministe.

                    \[
                        \forall i \in \set{1, 2},\ \exists M_i = (\Sigma, Q_i, q_i, F_i, \delta_i)\ |\ \mathcal L(M_i) = L_i
                    \]

                    On suppose $M_1$ et $M_2$ complets et $M_2$ standard.

                    On construit $M = \lr{\Sigma, Q_1 \cup Q_2 \setminus \set{q_2}, \set{q_1}, F, \delta}$, où :
                    \[
                        F =
                        \begin{cases}
                            F_2
                            & \text{si}\ q_2 \notin F_2
                            \\
                            F_1 \cup F_2 \setminus \set{q_2}
                            & \text{sinon}
                        \end{cases}
                    \]

                    et
                    \[
                        \forall (q, a) \in \lr{Q_1 \cup Q_2 \setminus \set{q_2}} \times \Sigma,\
                        \delta(q, a) =
                        \begin{cases}
                            \set{\delta_1(q, a)}
                            & \text{si}\ q \in Q_1 \setminus F_1
                            \\
                            \set{\delta_2(q, a)}
                            & \text{si}\ q \in Q_2 \setminus \set{q_2}
                            \\
                            \set{\delta_1(q, a), \delta_2(q_2, a)}
                            & \text{sinon}
                        \end{cases}
                    \]

                    \boxed{\rm Exo} $\mathcal L(M) = L_1 L_2$
                \end{proof}
            \end{indt}
        \end{indt}

        \vspace{12pt}
        
        \begin{indt}{\subsection{Transitions spontanées}}
            \begin{indt}{\subsubsection{Introduction}}
                On ajoute de l'indéterminisme aux automates en autorisant un changement d'état sans lire de lettre.

                Ce nouveau type de transition s'appelle \emph{transition spontanée / instantanée}, ou $\varepsilon$-transition, qui correspond à une transition étiquetée par le mot vide.
            \end{indt}

            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Définition (\textit{automate fini non déterministe à transitions spontanées})}}
                \begin{indt}{Un AFND à transitions spontanées ($\varepsilon$-AFND) est un quintuplet $(\Sigma, Q, I, F, \delta)$, où}
                    $-$ $\Sigma$ est un alphabet ;

                    $-$ $Q$ est un ensemble fini non vide d'états ;

                    $-$ $I \subseteq Q$ est l'ensemble des états initiaux ;

                    $-$ $F \subseteq Q$ est l'ensemble des états acceptants ;

                    $-$ $\delta : Q \times (\Sigma \cup \set \varepsilon) \longrightarrow \mathcal P(Q)$ est la fonction de transition.
                \end{indt}
            \end{indt}

            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Modèle de calcul associé}}
                \label{2.3.3}

                $\bullet$ Principe : un $\varepsilon$-AFND fonctionne comme un AFND mais à tout moment dans la lecture du mot il est possible de suivre un nombre quelconque d'$\varepsilon$-transitions.
                Il faut donc déterminer pour chaque état les états accessibles depuis ce dernier \textit{via} des transitions spontanées.
                C'est un problème de graphe simple à résoudre.

                \vspace{12pt}
                
                $\bullet$ Définition (\textit{$\varepsilon$-clôture}) : Soit $M = (\Sigma, Q, I, F, \delta)$ un $\varepsilon$-AFND, et $q \in Q$.

                On appelle \textit{$\varepsilon$-clôture} de $q$ l'ensemble
                \[
                    E(q) = \set{
                        q' \in Q\ |\ \exists n \in \N,\ \exists (q_0, \ldots, q_n) \in Q^{n + 1}\
                        \begin{array}{|l}
                            q_0 = q
                            \\
                            q_n = q'
                            \\
                            \forall i \in \nset 0 {n - 1},\ q_{i + 1} \in \delta(q_i, \varepsilon)
                        \end{array}
                    }
                \]

                \vspace{12pt}
                
                $\bullet$ Définition (\textit{transitions généralisées}) : Soit $M = (\Sigma, Q, I, F, \delta)$ un $\varepsilon$-AFND.

                On généralise $\delta$ aux mots par :
                \[
                    \forall q \in Q,\ \hat \delta(q, \varepsilon) = E(q)
                \]
                \[
                    \forall (q, u, a) \in Q \times \Sigma^* \times \Sigma,\
                    \hat \delta(q, au)
                    = \bigcup_{q' \in E(q)} \bigcup_{q" \in \delta(q', a)} \hat \delta(q", u)
                \]

                \boxed{\rm Exo} Mq c'est équivalent à
                \[
                    \forall (q, u, a) \in Q \times \Sigma^* \times \Sigma,\
                    \hat \delta(q, ua)
                    = \bigcup_{q' \in \hat \delta(q, u)} \bigcup_{q" \in \delta(q', a)} E(q")
                \]

                \vspace{12pt}
                
                $\bullet$ Définition (\textit{langage reconnu}) : Soit $M = (\Sigma, Q, I, F, \delta)$ un $\varepsilon$-AFND.

                $-$ $u \in \Sigma^*$ est accepté par $M$ ssi
                \[
                    \bigcup_{q_0 \in I} \hat \delta(q_0, u) \cap F \neq \varnothing
                \]

                $-$ Le langage reconnu par $M$ est
                \[
                    \mathcal L(M) = \set{u \in \Sigma^*\ |\ M\ \text{accepte}\ u}
                \]

                \vspace{12pt}
                
                $\bullet$ Proposition

                %\begin{emphBox}
                %    Soit $M = (\Sigma, Q, I, F, \delta)$ un $\varepsilon$-AFND, et $u \in \Sigma^*$.

                %    Alors $u \in \mathcal L(M) \ssi \exists q_0 \cdots q_n \in Q\ |\ q_0 \in I, q_n \in F,\ \exists a_1 \cdots a_n \in \Sigma \cup \set \varepsilon\ |\ \forall i \in \nset 0 {n - 1},\ q_i \in \delta(q_i, a_{i + 1})$ et $u = a_1 \cdots a_n$
                %\end{emphBox}
                
                \begin{emphBox}
                    Soit $M = (\Sigma, Q, I, F, \delta)$ un $\varepsilon$-AFND, et $u \in \Sigma^*$.

                    Alors
                    \[
                        \begin{array}{c}
                            u \in \mathcal L(M)
                            \ssi
                            \\
                            \exists q_0, \ldots, q_n \in Q\
                            \begin{array}{|l}
                                q_0 \in I
                                \\
                                q_n \in F
                                \\
                                \exists a_1, \ldots, a_n \in \Sigma \cup \set \varepsilon\
                                \begin{array}{|l}
                                    \forall i \in \nset 0 {n - 1},\ q_{i + 1} \in \delta(q_i, a_{i + 1})
                                    \\
                                    u = a_1 \cdots a_n
                                \end{array}
                            \end{array}
                        \end{array}
                    \]
                \end{emphBox}

                \vspace{12pt}
                
                \begin{proof}
                    \boxed{\Leftarrow} On montre par récurrence que $\forall i \in \nset 0 n,\ q_i \in \hat \delta(q_0, a_1 \cdots a_i)$ :

                    $-$ $i = 0$ : $a_1 \cdots a_i = \varepsilon$ et $q_0 \in E(q_0) = \hat \delta(q_0, \varepsilon)$.

                    \begin{indt}{$-$ Si $\forall j \le i$, la propriété est vraie, deux cas :}
                        $*$ $a_{i + 1} \neq \varepsilon$ : $q_{i + 1} \in \delta(q_i, a_{i + 1})$ et $q_i \in \hat \delta(q_0, a_1 \cdots a_i)$.

                        Or $\hat \delta (q_0, a_1 \cdots a_{i + 1}) = \displaystyle \bigcup_{q \in \hat \delta(q_0, a_1 \cdots a_i)} \bigcup_{q' \in \delta(q, a_{i + 1})} E(q')$.

                        Donc $q_{i + 1} \in E(q_{i + 1}) \subseteq \displaystyle \bigcup_{q \in \delta(q_i, a_{i + 1})} E(q') \subseteq \hat \delta(q_0, a_1 \cdots a_{i + 1})$

                        \vspace{6pt}
                        
                        \begin{indt}{$*$ $a_{i + 1} = \varepsilon$ : deux cas :}
                            $+$ $\forall j \le i,\ a_j = \varepsilon$. Dans ce cas, $q_{i + 1} \in E(q_0) = \hat \delta(q_0, \varepsilon) = \hat \delta(q_0, a_1 \cdots a_{i + 1})$

                            $+$ $\exists j \le i\ |\ a_j \neq \varepsilon$ : on considère $j = \max \set{k \le i\ |\ a_k \neq \varepsilon}$

                            On sait que $a_1 \cdots a_{i+1} = a_1 \cdots a_j$.

                            \[
                                q_{i + 1} \in E(q_j)
                                \subseteq \bigcup_{q' \in \delta(q_{j - 1}, a_j)} E(q')
                                \subseteq \bigcup_{q \in \hat \delta(q_0, a_1 \cdots a_{j - 1})} \bigcup_{q' \in \delta (q, a_j)} E(q')
                                = \hat \delta(q_0, a_1 \cdots a_j)
                            \]
                        \end{indt}
                    \end{indt}

                    \vspace{12pt}
                    
                    \boxed{\rm \Rightarrow} On montre par récurrence sur $n \in \N$ qur $\forall u \in \Sigma^*\ |\ \abs u = n,\ \forall q, q' \in Q$, si $q' \in \hat \delta(q, u)$, alors il exste un chemin $q_0 \cdots q_n$ dont les étiquettes $a_1 \cdots a_n$ vérifient $u = a_1 \cdots a_n$ et $q_0 = q, q_n = q'$.

                    \vspace{6pt}
                    
                    $-$ $n = 0$ : $u = \varepsilon$ et $q' \in E(q)$ donc la définition de l'$\varepsilon$-clôture donne le chemin.

                    \vspace{6pt}
                    
                    $-$ Si la propriété est vraie pour $n \in \N$, soit $u \in \Sigma^*\ |\ \abs u = n + 1$, soit $q, q' \in Q\ |\ q' \in \hat \delta(q, u)$.

                    $\exists v \in \Sigma^*\ |\ \abs v = n,\ \exists a \in \Sigma\ |\ u = av$.

                    $q' \in \hat \delta(q, av) = \displaystyle \bigcup_{q'' \in E(q)} \bigcup_{q''' \in \delta(q'', q)} \hat \delta(q''', v)$

                    Première union : chemin étiqueté par $\varepsilon \cdots \varepsilon$ de $q$ à $q'$

                    Deuxième union : avec transition étiquetée par $a$ de $q''$ à $q'''$

                    $\hat \delta(q'', v)$ : H.R : le chemin étiqueté par $a_1 \cdots a_n$ tel que $a_1 \cdots a_n = v$ de $q'''$ à $q'$.

                    Donc chemin de $q$ à $q'$ étiqueté par $\varepsilon \cdots \varepsilon$ de $a_1 \cdots a_n = av = u$.

                    \vspace{6pt}
                    
                    $-$ Si $u \in \mathcal L(M)$, alors $\exists q_0 \in I, \exists q_n \in F\ |\ q_n \in \hat \delta(q_0, u)$

                    donc la propriété démontrée donne le chemin voulu.
                \end{proof}

                \vspace{12pt}
                
                $\bullet$ Exemple : si $u = u_1 \cdots u_n$,

                $-$ l'AFD

                \begin{center}
                    \begin{tikzpicture}
                        \node (0) at (0, 0) [state, initial, initial text={}] {$q_0$};
                        \node (1) at (2, 0) [state] {$q_1$};
                        \node (d) at (4, 0) {$\cdots$};
                        \node (n) at (6, 0) [state, accepting] {$q_n$};

                        \draw[->] (0) to node [above] {$u_1$} (1);
                        \draw[->] (1) to node [above] {$u_2$} (d);
                        \draw[->] (d) to node [above] {$u_n$} (n);
                    \end{tikzpicture}
                \end{center}

                reconnait $\set u$.

                \vspace{6pt}
                
                $-$ l'$\varepsilon$-AFND

                \begin{center}
                    \begin{tikzpicture}
                        \node (0) at (0, 0) [state, initial, initial text={}] {$q_0$};
                        \node (1) at (2, 0) [state] {$q_1$};
                        \node (d) at (4, 0) {$\cdots$};
                        \node (n) at (6, 0) [state, accepting] {$q_n$};

                        \draw[->] (0) to [out=20, in=160] node [above] {$u_1$} (1);
                        \draw[->] (1) to [out=20, in=160] node [above] {$u_2$} (d);
                        \draw[->] (d) to [out=20, in=160] node [above] {$u_n$} (n);

                        \draw[->] (0) to [out=-20, in=-160] node [below] {$\varepsilon$} (1);
                        \draw[->] (1) to [out=-20, in=-160] node [below] {$\varepsilon$} (d);
                        \draw[->] (d) to [out=-20, in=-160] node [below] {$\varepsilon$} (n);
                    \end{tikzpicture}
                \end{center}

                reconnait $\set{v \in \Sigma^*\ |\ v\ \text{sous-mot de}\ u}$
            \end{indt}

            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Théorème}}
                \begin{emphBox}
                    Soit $\Sigma$ un alphabet, et $L$ un langage sur $\Sigma$.

                    \[
                        L \in \Rec \Sigma
                        \ssi
                        \exists M = (\Sigma, Q, I, F, \delta)\ \text{un $\varepsilon$-AFND}\ |\ \mathcal L(M) = L
                    \]
                \end{emphBox}

                \begin{proof}
                    \boxed{\Rightarrow} par \ref{2.2.4} (page \pageref{2.2.4}), $\exists M = (\Sigma, Q, I, F, \delta)$ un AFND tel que $\mathcal L(M) = L$.

                    On construit l'$\varepsilon$-AFND $M' = (\Sigma, Q, I, F, \delta')$, où
                    \[
                        \forall (q, a) \in Q \times (\Sigma \cup \set \varepsilon),\
                        \delta'(q, a) =
                        \begin{cases}
                            \delta(q, a)
                            & \text{si}\ a \neq \varepsilon
                            \\
                            \varnothing
                            & \text{sinon}
                        \end{cases}
                    \]

                    Les graphes de $M, M'$ sont identiques, donc par \ref{2.3.3} (page \pageref{2.3.3}), $\mathcal L(M') = \mathcal L(M) = L$

                    \vspace{12pt}
                    
                    \boxed{\Leftarrow} On élimine les $\varepsilon$-transitions en construisant l'AFND
                    \[
                        M' = \lr{\Sigma, Q, \bigcup_{q_0 \in I} E(q_0), F, \delta'}
                    \]
                    où $\forall (q, a) \in Q \times \Sigma$,
                    \[
                        \delta'(q, a) = \bigcup_{q' \in \delta(q, a)} E(q')
                    \]

                    Soit $u \in \Sigma^*$. On note $u = u_1 \cdots u_n$.

                    $
                        u \in \mathcal L(M')
                        \ssi \exists q_0 \cdots q_n\ \text{un chemin}\
                        \left|
                        \begin{array}{l}
                            \displaystyle
                            q_0 \in \bigcup_{q \in I} E(q)
                            \vspace{3pt}
                            \\
                            q_n \in F
                            \vspace{3pt}
                            \\
                            \forall i \in \nset 0 {n - 1},\ q_{i+1} \in \delta'(q_i, u_{i + 1})
                        \end{array}
                        \right.
                    $

                    $
                        \ssi
                        \exists q_0 \cdots q_n\ \text{un chemin}
                        \left|
                        \begin{array}{l}
                            \displaystyle
                            q_0 \in \bigcup_{q \in I} E(q)
                            \vspace{3pt}
                            \\
                            q_n \in F
                            \vspace{3pt}
                            \\
                            \displaystyle
                            \forall i \in \nset 0 {n - 1},\ q_{i + 1} \in \bigcup_{q \in \delta(q_i, u_{i + 1})} E(q)
                            \vspace{-6pt}
                        \end{array}
                        \right.
                    $
                    \vspace{6pt}

                    %$\ssi$ il existe un chemin $q_{-n} \cdots q_0 q_1^{(0)} \cdots q_1^{(n_1)} q_2^{(0)} \cdots q_2^{(n_2)} \cdots q_n^{(0)} \cdots q_n^{(m_n)}, \forall i \in \nset 0 {n - 1}, q_{i + 1} \in \delta(q_i, \varepsilon), \forall i \in \nset 1 n,\ q_i^{(0)} \in \delta(q_{i - 1}^{(n_{i - 1})}, u_i),\ \forall j \in \nset 0 {m_i - 1}, \ q_i^{(j + 1)} \in \delta(q_i^{(j)}, \varepsilon)$
                    %et $q_0 \in I$, et $q_n^{m_n} \in F$

                    $
                        \ssi
                        \exists q_{-m} \cdots q_0 q_1^{(0)} \cdots q_1^{(m_1)} q_2^{(0)} \cdots q_2^{(m_2)} \cdots q_n^{(0)} \cdots q_n^{(m_n)}\ \text{un chemin tel que}
                    $
                    \[
                        \left|
                        \begin{array}{l}
                            \forall i \in \nset{-m}{-1},\ q_{i + 1} \in \delta(q_i, \varepsilon)
                            \vspace{3pt}
                            \\
                            \forall i \in \nset 1 n,\ q_i^{(0)} \in \delta(q_{i - 1}^{(m_{i - 1})}, u_i)
                            \vspace{3pt}
                            \\
                            \forall j \in \nset 0 {m_i - 1},\ q_i^{(j + 1)} \in \delta(q_i^{(j)}, \varepsilon)
                            \vspace{3pt}
                            \\
                            q_0 \in I
                            \vspace{0pt}
                            \\
                            q_n^{(m_n)} \in F
                        \end{array}
                        \right.
                    \]

                    $\ssi u \in \mathcal L(M)$
                \end{proof}
            \end{indt}

            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Exemple}}
                \label{2.3.5}

                $\Sigma = \set{a, b}$, et $\forall c \in \Sigma$, on note $L_c = \set{u \in \Sigma^*\ |\ \abs u _c \equiv 1\ [2]}$

                $(L_a L_b)^+$ est reconnu par :

                \begin{center}
                    \begin{tikzpicture}
                        \node (0) at (0, 0) [state, initial, initial text={}] {$q_0$};
                        \node (1) at (2, 0) [state] {$q_1$};
                        \node (2) at (2, -2) [state] {$q_2$};
                        \node (3) at (0, -2) [state, accepting] {$q_3$};

                        \draw[->] (0) to [out=20, in=160] node [above] {$a$} (1);
                        \draw[->] (1) to [out=-160, in=-20] node [below] {$a$} (0);

                        \draw[->] (1) to node [right] {$\varepsilon$} (2);
                        \draw[->] (3) to node [left] {$\varepsilon$} (0);

                        \draw[->] (3) to [out=20, in=160] node [above] {$b$} (2);
                        \draw[->] (2) to [out=-160, in=-20] node [below] {$b$} (3);

                        \draw[->] (2) to [out=-45, in=0, looseness=3] node [below right] {$a$} (2);
                        \draw[->] (3) to [out=-135, in=180, looseness=3] node [below left] {$a$} (3);
                        \node at (6, -1) {$
                            \begin{array}{l}
                                E(q_0) = \set{q_0}
                                \\
                                E(q_1) = \set{q_1, q_2}
                                \\
                                E(q_2) = \set{q_2}
                                \\
                                E(q_3) = \set{q_3, q_0}
                            \end{array}
                        $};
                    \end{tikzpicture}
                \end{center}

                $a(bb)$

                $\rightarrow (ab)b \in \mathcal L(M)$

                \vspace{12pt}
                
                $(L_a L_b)^+$ est donc reconnu par

                \begin{center}
                    \begin{tikzpicture}[scale=1.5]
                        \node (0) at (0, 0) [state, initial, initial text={}] {$q_0$};
                        \node (1) at (2, 0) [state] {$q_1$};
                        \node (2) at (2, -2) [state] {$q_2$};
                        \node (3) at (0, -2) [state, accepting] {$q_3$};

                        \draw[->] (0) to [out=20, in=160] node [above] {$a$} (1);
                        \draw[->] (1) to [out=-160, in=-20] node [below] {$a$} (0);

                        \draw[->] (1) to node [right] {$b$} (2);
                        \draw[->] (3) to node [left] {$a$} (0);

                        \draw[->] (3) to [out=20, in=160] node [above] {$b$} (2);
                        \draw[->] (2) to [out=-160, in=-20] node [below] {$b$} (3);

                        \draw[->] (2) to [out=-45, in=0, looseness=3] node [below right] {$a$} (2);
                        \draw[->] (3) to [out=-135, in=180, looseness=3] node [below left] {$a$} (3);

                        \draw[->] (0) to [out=45, in=90, looseness=3] node [above right] {$b$} (0);
                        \draw[->] (1) to [out=45, in=90, looseness=3] node [above right] {$b$} (1);

                        \draw[->] (0) to [out=-35, in=125] node [above right] {$a$} (2);
                        \draw[->] (2) to [out=145, in=-55] node [below left] {$b$} (0);
                    \end{tikzpicture}
                \end{center}
            \end{indt}

            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Retour aux propriétés de clôture sur $\Rec \Sigma$}}
                \label{2.3.6}
                $\bullet$ Théorème :
                \begin{emphBox}
                    \[
                        \Reg(\Sigma) \subseteq \Rec \Sigma
                    \]
                \end{emphBox}

                \vspace{12pt}
                
                \begin{proof}
                    On procède par induction structurelle sur une expression régulière dénotant le langage en applicant la construction de \textsc{Thompson} :

                    $-$ $\varnothing$ :
                    \begin{center}
                        \begin{tikzpicture}
                            \node (0) at (0, 0) [state, initial, initial text={}] {$q_i$};
                            \node (1) at (2, 0) [state, accepting] {$q_f$};
                        \end{tikzpicture}
                    \end{center}

                    $M_\varnothing = (\Sigma, \set{q_i, q_f}, \set{q_i}, \set{q_f}, \varnothing)$

                    %\vspace{12pt}
                    \newpage
                    
                    $-$ $\varepsilon$ :
                    \begin{center}
                        \begin{tikzpicture}
                            \node (0) at (0, 0) [state, initial, initial text={}] {$q_i$};
                            \node (1) at (2, 0) [state, accepting] {$q_f$};

                            \draw[->] (0) to node [above] {$\varepsilon$} (1);
                        \end{tikzpicture}
                    \end{center}

                    $
                        M_\varepsilon = \lr{
                            \Sigma,
                            \set{q_i, q_f},
                            \set{q_i},
                            \set{q_f},
                            \set{(q_i, \varepsilon) \longmapsto \set{q_f}}
                        }
                    $

                    \vspace{6pt}
                    
                    $-$ $a \in \Sigma$
                    \begin{center}
                        \begin{tikzpicture}
                            \node (0) at (0, 0) [state, initial, initial text={}] {$q_i$};
                            \node (1) at (2, 0) [state, accepting] {$q_f$};

                            \draw[->] (0) to node [above] {$a$} (1);
                        \end{tikzpicture}
                    \end{center}

                    $
                        M_a = \lr{
                            \Sigma,
                            \set{q_i, q_f},
                            \set{q_i},
                            \set{q_f},
                            \set{(q_i, a) \longmapsto \set{q_f}}
                        }
                    $

                    \vspace{12pt}
                    
                    $-$ $e | f$ :

                    \begin{center}
                        \begin{tikzpicture}
                            \node (i) at (0, 0) [state, initial, initial text={}] {$q_i$};
                            \node (f) at (6, 0) [state, accepting] {$q_f$};

                            \node (Me) at (3, 1) [rectangle, draw, rounded corners=5pt] {
                                \tikz{
                                    \node at (0, 0) [circle, draw] {$q_{ie}$};
                                    \node at (1, 0) {$M_e$};
                                    \node at (2, 0) [circle, draw] {$q_{fe}$};
                                }
                            };

                            \node (Mf) at (3, -1) [rectangle, draw, rounded corners=5pt] {
                                \tikz{
                                    \node at (0, 0) [circle, draw] {$q_{if}$};
                                    \node at (1, 0) {$M_f$};
                                    \node at (2, 0) [circle, draw] {$q_{ff}$};
                                }
                            };
                            
                            \draw[->] (i) to [out=45, in=180] node [above left] {$\varepsilon$} (Me);
                            \draw[->] (i) to [out=-45, in=180] node [below left] {$\varepsilon$} (Mf);

                            \draw[->] (Me) to [out=0, in=135] node [above right] {$\varepsilon$} (f);
                            \draw[->] (Mf) to [out=0, in=-135] node [below right] {$\varepsilon$} (f);
                        \end{tikzpicture}
                    \end{center}

                    $
                        M_{e | f}
                        = \lr{
                            \Sigma,\
                            \set{q_i, q_f} \cup Q_e \cup Q_f,\
                            \set {q_i},\
                            \set {q_f},\
                            \delta_e \cup \delta_f \cup
                            \begin{array}{|l}
                                (q_i, \varepsilon) \longmapsto \set{q_{ie}, q_{if}}
                                \\
                                (q_{fe}, \varepsilon) \longmapsto \set{q_f}
                                \\
                                (q_{ff}, \varepsilon) \longmapsto \set{q_f}
                            \end{array}
                        }
                    $

                    $u \in \mathcal L(M_{e | f}) \ssi$

                    il existe un chemin de $q_i$ à $q_f$ dont les étiquettes donnent $u$

                    $\ssi$ il existe un chemin de $q_{ie}$ à $q_{fe}$ dont les étiquettes donnent $u$

                    ou il existe un chemin de $q_{if}$ à $q_{ff}$ dont les étiquettes donnent $u$

                    $\ssi u \in \mathcal L(M_e)$ ou $u \in \mathcal L(M_f)$

                    $\ssi u \in \mathcal L(M_e) \cup \mathcal L(M_f) = \mathcal L(e) \cup \mathcal L(f) = \mathcal L(e|f)$.

                    \vspace{12pt}
                    
                    $-$ $ef$

                    \begin{center}
                        \begin{tikzpicture}
                            \node (i) at (0, 0) [state, initial, initial text={}] {$q_i$};
                            \node (Me) at (3, 0) [rectangle, draw, rounded corners=5pt] {
                                \tikz{
                                    \node at (0, 0) [state] {$q_{ie}$};
                                    \node at (1, 0) {$M_e$};
                                    \node at (2, 0) [state] {$q_{fe}$};
                                }
                            };

                            \node (Mf) at (7.5, 0) [rectangle, draw, rounded corners=5pt] {
                                \tikz{
                                    \node at (0, 0) [state] {$q_{if}$};
                                    \node at (1, 0) {$M_f$};
                                    \node at (2, 0) [state] {$q_{ff}$};
                                }
                            };

                            \node (f) at (10.5, 0) [state, accepting] {$q_f$};

                            \draw[->] (i) to node [above] {$\varepsilon$} (Me);
                            \draw[->] (Me) to node [above] {$\varepsilon$} (Mf);
                            \draw[->] (Mf) to node [above] {$\varepsilon$} (f);
                        \end{tikzpicture}
                    \end{center}

                    $
                        M_{ef} =
                        \lr{
                            \Sigma,\
                            Q_e \cup Q_f \cup \set{q_i, q_f},\
                            \set{q_i},\
                            \set{q_f},\
                            \delta_e \cup \delta_f \cup
                            \begin{array}{|l}
                                (q_i, \varepsilon) \longmapsto \set{q_{ie}}
                                \\
                                (q_{fe}, \varepsilon) \longmapsto \set{q_{if}}
                                \\
                                (q_{ff}, \varepsilon) \longmapsto \set{q_{f}}
                            \end{array}
                        }
                    $

                    \vspace{12pt}
                    
                    $-$ $e^*$ :

                    \begin{center}
                        \begin{tikzpicture}
                            \node (i) at (0, 0) [state, initial, initial text={}] {$q_i$};
                            \node (Me) at (3, 0) [rectangle, draw, rounded corners=5pt] {
                                \tikz{
                                    \node (ie) at (0, 0) [state] {$q_{ie}$};
                                    \node (M) at (1, 0) {$M_e$};
                                    \node (fe) at (2, 0) [state] {$q_{fe}$};

                                    \draw[->] (ie) to [out=-45, in=-135] node [below] {$\varepsilon$} (fe);
                                    \draw[->] (fe) to [out=135, in=45] node [above] {$\varepsilon$} (ie);
                                }
                            };
                            \node (f) at (6, 0) [state, accepting] {$q_f$};

                            \draw[->] (i) to node [above] {$\varepsilon$} (Me);
                            \draw[->] (Me) to node [above] {$\varepsilon$} (f);
                        \end{tikzpicture}
                    \end{center}

                    $
                        M_{e^*} =
                        \lr{
                            \Sigma,\
                            Q_e \cup \set{q_i, q_f},\
                            \set{q_i},\
                            \set{q_f},\
                            \delta_e \cup
                            \begin{array}{|l}
                                (q_i, \varepsilon) \longmapsto \set{q_{ie}}
                                \\
                                (q_{ie}, \varepsilon) \longmapsto \set{q_{fe}}
                                \\
                                (q_{fe}, \varepsilon) \longmapsto \set{q_{ie}, q_{f}}
                            \end{array}
                        }
                    $

                    \vspace{12pt}
                    
                    \boxed{\rm Exo} Comme $M_e$ est standard, $\mathcal L(M_{e^*}) = \mathcal L(e^*)$
                \end{proof}

                \vspace{12pt}
                
                $\bullet$ Exemple : $((a | b)^*)(ba)$

                \begin{center}
                    \begin{tikzpicture}
                        \node (0) at (0, 0) [circle, draw, initial, initial text={}] {};
                        \node (1) at (1, 0) [circle, draw] {};
                        \node (Mab) at (3.7, 0) [rectangle, draw, rounded corners=5pt, label=above:{$M_{a|b}$}] {
                            \tikz{
                                \node (0') at (0, 0) [circle, draw] {};
                                \node (1up) at (1, 1) [circle, draw] {};
                                \node (2up) at (2, 1) [circle, draw] {};
                                \node (1down) at (1, -1) [circle, draw] {};
                                \node (2down) at (2, -1) [circle, draw] {};
                                \node (3') at (3, 0) [circle, draw] {};

                                \draw[->] (0') to node [above left] {$\varepsilon$} (1up);
                                \draw[->] (0') to node [below left] {$\varepsilon$} (1down);

                                \draw[->] (1up) to node [below] {$a$} (2up);
                                \draw[->] (1down) to node [above] {$b$} (2down);

                                \draw[->] (2up) to node [above right] {$\varepsilon$} (3');
                                \draw[->] (2down) to node [below right] {$\varepsilon$} (3');
                            }
                        };
                        
                        \node (2) at (6.4, 0) [circle, draw] {};

                        \node (Mb) at (8, 0) [rectangle, draw, rounded corners=5pt, label=above:{$M_b$}] {
                            \tikz{
                                \node (0') at (0, 0) [circle, draw] {};
                                \node (1') at (1, 0) [circle, draw] {};

                                \draw[->] (0') to node [above] {$b$} (1');
                            }
                        };

                        \node (Ma) at (10.4, 0) [rectangle, draw, rounded corners=5pt, label=above:{$M_a$}] {
                            \tikz{
                                \node (0') at (0, 0) [circle, draw] {};
                                \node (1') at (1, 0) [circle, draw] {};

                                \draw[->] (0') to node [above] {$a$} (1');
                            }
                        };

                        \node (3) at (12, 0) [circle, draw, accepting] {};

                        \draw[->] (0) to node [above] {$\varepsilon$} (1);
                        \draw[->] (1) to node [above] {$\varepsilon$} (Mab);
                        \draw[->] (Mab) to node [above] {$\varepsilon$} (2);
                        \draw[->] (2) to node [above] {$\varepsilon$} (Mb);
                        \draw[->] (Mb) to node [above] {$\varepsilon$} (Ma);
                        \draw[->] (Ma) to node [above] {$\varepsilon$} (3);

                        \draw[->] (1) to (1, -1.5) to [out=-90, in=180] (1.5, -2) to node [below] {$\varepsilon$} (5.9, -2) to [out=0, in=-90] (6.4, -1.5) to (2);
                        \draw[->] (2) to (6.4, 1.5) to [out=90, in=0] (5.9, 2.1) to node [above] {$\varepsilon$} (1.5, 2.1) to [out=180, in=90] (1, 1.5) to (1);
                    \end{tikzpicture}
                \end{center}
            \end{indt}
        \end{indt}

        \vspace{12pt}
        
        \begin{indt}{\subsection{Théorème de \textsc{Kleene}}}
            \label{2.4}

            \begin{indt}{\subsubsection{Introduction}}
                Le théorème de \textsc{Kleene} énonce le fait que les langages réguliers et les automates finis ont la même expressivité : les langages réguliers sont les mêmes langages que les langages reconnaissables.

                \vspace{12pt}
                
                Remarque : le théorème est déjà démontré : la construction de \textsc{Thompson} (\textit{cf} \ref{2.3.6}, page \pageref{2.3.6}) montre que les langages réguliers sont reconnaissables et on a vu qu'il était possible de déterminer le langage reconnu par un AFD à l'aide du lemme d'\textsc{Arden} (\textit{cf} \ref{2.1.3}, page \pageref{2.1.3}).
                Ce langage est construit à l'aide d'opérations régulières, donc il est régulier.

                \vspace{12pt}
                
                Rappel :
                Soit $M = (\Sigma, Q, q_0, F, \delta)$ un AFD.

                $\forall q \in Q$, on définit le système d'équations d'inconnues $L_q$ suivant :
                \[
                    \forall q \in Q,\
                    L_q =
                    \begin{cases}
                        \displaystyle
                        \bigcup_{q' \in Q} \Sigma_{q, q'} L_{q'}
                        & \text{si}\ q \notin F
                        \\
                        \displaystyle
                        \set \varepsilon \cup
                        \bigcup_{q' \in Q} \Sigma_{q, q'} L_{q'}
                        & \text{sinon}
                    \end{cases}
                \]
                où $\Sigma_{q, q'} = \set{a \in \Sigma\ |\ \delta(q, a) = q'}$

                \vspace{6pt}
                
                On remarque que $\forall q \in Q$, $\Sigma_{q, q'}$ ne contient pas le mot vide ($\Sigma_{q, q'} \subseteq \Sigma$), donc le lemme d'\textsc{Arden} permet d'obtenir l'expression de $L_q$ en fonction des $L_{q'},\ \forall q' \in Q \setminus q$.

                Réinjecter cette expression dans les autres équations permet d'obtenir un système avec une équation et une inconnue de moins, que l'on peut résoudre récursivement.

                \vspace{12pt}
                
                Nous allons maintenant voir une autre démonstration du théorème de \textsc{Kleene} , au programme cette fois.
            \end{indt}

            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Théorème (\textsc{Kleene}, sens direct)}}
                \begin{emphBox}
                    Soit $\Sigma$ un alphabet.

                    \[
                        \Reg(\Sigma) \subseteq \Rec \Sigma
                    \]
                \end{emphBox}

                \vspace{6pt}
                
                \begin{proof}
                    Soit $L \in \Reg(\Sigma)$. On a donc
                    \[
                        \exists e \in \Regexp(\Sigma)\ |\ L = \mathcal L(e)
                    \]

                    On construit un automate reconnaissant $L$ grâce à l'algorithme de \textsc{Berry-Sethi} :

                    \vspace{6pt}
                    
                    \begin{indalgo}{\textsc{Berry-Sethi}}
                        \label{alg:3}

                        Linéariser $e$ en une expression régulière $e'$ sur $\Sigma \times \nset 1 n$ (\textit{cf} \ref{1.4.5}, page \pageref{1.4.5})\;

                        Construire l'AFD local $M = (\Sigma \times \nset 1 n, Q, q_0, F, \delta)$ reconnaissant $\mathcal L(e')$ comme en \ref{2.1.7} (page \pageref{2.1.7})
                        (rappel : $\mathcal L(e')$ est local, \textit{cf} \ref{1.4.5})\;

                        Effacer les indices des symboles pour obtenir un AFND $M' = (\Sigma, Q, \set{q_0}, F, \delta')$, où :
                        \[
                            \forall (q, a) \in Q \times \Sigma,\
                            \delta'(q, a) = \set{q' \in Q\ |\ \exists i \in \nset 1 n\ |\ \delta(q, (a, i)) = q'}
                        \]
                    \end{indalgo}

                    \vspace{6pt}
                    
                    $M'$ est appelé l'automate de \textsc{Glushkov} associé à $e$, et on peut, de manière optionnelle, le déterminiser (\textit{cf} \ref{2.2.4}, page \pageref{2.2.4})

                    La correction de l'algorithme s'exprime ainsi :

                    $\mathcal L(M') = \mathcal L(e)$.

                    Soit $u \in \Sigma^*$. On le note $u = u_1 \cdots u_m$.

                    $u \in \mathcal L(M') \ssi \exists$ un chemin $q_0 \overset{u_1}{\longrightarrow} q_1 \overset{u_2}{\longrightarrow} \cdots \overset{u_m}{\longrightarrow} q_m$
                    avec $q_m \in F$ dans le graphe $M'$

                    $\ssi \exists i_1, \ldots, i_m,\ \exists$ un chemin $q_0 \overset{(u_1, i_1)}{\longrightarrow} q_1 \overset{(u_2, i_2)}{\longrightarrow} \cdots \overset{(u_m, i_m)}{\longrightarrow} q_m$
                    avec $q_m \in F$ dans le graphe de $M$.

                    $\ssi \exists i_1, \ldots, i_m\ |\ (u_1, i_1), \ldots, (u_m, i_m) \in \mathcal L(M) = \mathcal L(e')$

                    $\ssi u = u_1 \cdots u_m \in \mathcal L(e)$ (\textit{cf} exo en \ref{1.4.5}, page \pageref{1.4.5})
                \end{proof}
            \end{indt}

            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Exemple}}
                On considère $e = a(ab)^* | b^* a$.

                (1) On linéarise $e$ en $e' = a_1(a_2b_1)^* | b_2^* a_3$

                (2) On détermine
                \[
                    \begin{array}{l}
                        P_1 = \set{a_1, b_2, a_3}
                        \\
                        S_1 = \set{a_1, b_1, a_3}
                        \\
                        F_2 = \set{a_1a_2, a_2b_1, b_1a_2, b_2a_3, b_2b_2}
                    \end{array}
                \]

                D'où l'automate $M$ :
                \begin{center}
                    \begin{tikzpicture}
                        \node (a3) at (0, 0) [state, accepting] {$a_3$};
                        \node (b2) at (2, 0) [state] {$b_2$};
                        \node (ep) at (4, 0) [state, initial above, initial text={}] {$\varepsilon$};
                        \node (a1) at (6, 0) [state, accepting] {$a_1$};
                        \node (a2) at (8, 0) [state] {$a_2$};
                        \node (b1) at (10, 0) [state, accepting] {$b_1$};

                        \draw[->] (b2) to node [above] {$a_3$} (a3);
                        \draw[->] (ep) to node [above] {$b_2$} (b2);
                        \draw[->] (ep) to node [above] {$a_1$} (a1);
                        \draw[->] (a1) to node [above] {$a_2$} (a2);

                        \draw[->] (a2) to [out=20, in=160] node [above] {$b_1$} (b1);
                        \draw[->] (b1) to [out=-160, in=-20] node [below] {$a_2$} (a2);

                        \draw[->] (ep) to [out=-135, in=-45] node [below] {$a_3$} (a3);

                        \draw[->] (b2) to [out=45, in=90, looseness=3] node [above right] {$b_2$} (b2);
                    \end{tikzpicture}
                \end{center}

                \vspace{6pt}
                
                (3) L'automate de \textsc{Glushkov} associé à $e$ est donc

                \begin{center}
                    \begin{tikzpicture}
                        \node (a3) at (0, 0) [state, accepting] {$a_3$};
                        \node (b2) at (2, 0) [state] {$b_2$};
                        \node (ep) at (4, 0) [state, initial above, initial text={}] {$\varepsilon$};
                        \node (a1) at (6, 0) [state, accepting] {$a_1$};
                        \node (a2) at (8, 0) [state] {$a_2$};
                        \node (b1) at (10, 0) [state, accepting] {$b_1$};

                        \draw[->] (b2) to node [above] {$a$} (a3);
                        \draw[->] (ep) to node [above] {$b$} (b2);
                        \draw[->] (ep) to node [above] {$a$} (a1);
                        \draw[->] (a1) to node [above] {$a$} (a2);

                        \draw[->] (a2) to [out=20, in=160] node [above] {$b$} (b1);
                        \draw[->] (b1) to [out=-160, in=-20] node [below] {$a$} (a2);

                        \draw[->] (ep) to [out=-135, in=-45] node [below] {$a$} (a3);

                        \draw[->] (b2) to [out=45, in=90, looseness=3] node [above right] {$b$} (b2);
                    \end{tikzpicture}
                \end{center}

                Que l'on peut déterminiser :
                \[
                    \begin{array}{ccccccc}
                        & \set \varepsilon & \set{a_1, a_3} & \set{b_2} & \set{a_2} & \set{a_3} & \set{b_1}
                        \\
                        a & \set{a_1, a_3} & \set{a_2} & \set{a_3} & \varnothing & \varnothing & \set{a_2}
                        \\
                        b & \set{b_2} & \varnothing & \set{b_2} & \set{b_1} & \varnothing & \varnothing
                    \end{array}
                \]

                \begin{center}
                    \begin{tikzpicture}
                        \node (a3) at (0, 0) [state, accepting] {$\set{a_3}$};
                        \node (b2) at (2, 0) [state] {$\set{b_2}$};
                        \node (ep) at (4, 0) [state, initial above, initial text={}] {$\set \varepsilon$};
                        \node (a1) at (6, 0) [state, accepting] {$\set{a_1, a_3}$};
                        \node (a2) at (8, 0) [state] {$\set{a_2}$};
                        \node (b1) at (10, 0) [state, accepting] {$\set{b_1}$};

                        \draw[->] (b2) to node [above] {$a$} (a3);
                        \draw[->] (ep) to node [above] {$b$} (b2);
                        \draw[->] (ep) to node [above] {$a$} (a1);
                        \draw[->] (a1) to node [above] {$a$} (a2);

                        \draw[->] (a2) to [out=20, in=160] node [above] {$b$} (b1);
                        \draw[->] (b1) to [out=-160, in=-20] node [below] {$a$} (a2);

                        %\draw[->] (ep) to [out=-135, in=-45] node [below] {$a$} (a3);

                        \draw[->] (b2) to [out=45, in=90, looseness=3] node [above right] {$b$} (b2);
                    \end{tikzpicture}
                \end{center}
            \end{indt}

            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Théorème (\textsc{Kleene}, sens réciproque)}}
                \begin{emphBox}
                    Soit $\Sigma$ un alphabet.

                    Alors
                    \[
                        \Rec \Sigma \subseteq \Reg(\Sigma)
                    \]
                \end{emphBox}

                \vspace{6pt}
                
                \begin{proof}
                    Soit $L \in \Rec \Sigma$. Il existe un AFD $M = (\Sigma, Q, q_0, F, \delta)\ |\ \mathcal L(M) = L$.

                    On construit à partir de $M$ une expression régulière $e$ telle que $\mathcal L(e) = \mathcal L(M) = L$, en appliquant l'algorithme de \textsc{Brzozowski} et Mc \textsc{Cluskey} dont le principe est le suivant :

                    \begin{indalgo}{\textsc{Brzozowski} et Mc \textsc{Cluskey}}
                        \label{alg:4}

                        On construit l'automate généralisé
                        \[
                            M' = (\Regexp(\Sigma), Q \cup \set{q_i, q_f}, q_i, \set{q_f}, \delta')
                        \]
                        où
                        $\forall (q, e) \in Q \times \Regexp(\Sigma)$,
                        \[
                            \delta'(q, e) =
                            \begin{cases}
                                q_0
                                & \text{si}\ e = \varepsilon\ \text{et}\ q = q_i
                                \\
                                q_f
                                & \text{si}\ e = \varepsilon\ \text{et}\ q \in F
                                \\
                                \delta(q, a)
                                & \text{si}\ e = a \in \Sigma\ \text{et}\ (q, a) \in \mathrm{dom}(\delta)
                                \\
                                \text{non défini}
                                & \text{sinon}
                            \end{cases}
                        \]

                        \begin{center}
                            \begin{tikzpicture}
                                \node (i) at (0, 0) [state, initial, initial text={}] {$q_i$};
                                \node (M) at (3.1, 0) [rectangle, draw, rounded corners=5pt] {
                                    \tikz{
                                        \node at (0, 0) [state] {$q_0$};
                                        \node at (1, 0) {$M$};
                                        \node at (2.2, 0) [state] {$q \in F$};
                                    }
                                };

                                \node (f) at (6.2, 0) [state, accepting] {$q_f$};

                                \draw[->] (i) to node [above] {$\varepsilon$} (M);
                                \draw[->] (M) to node [above] {$\varepsilon$} (f);
                            \end{tikzpicture}
                        \end{center}
                        %\;
                        \BlankLine

                        \While{$Q \neq \varnothing$}{
                            Éliminer des transitions multiples : si l'automate contient deux transitions $q \overset{e}{\longrightarrow} q'$ et $q \overset f \longrightarrow q'$, on les remplace par $q \overset{e|f}{\longrightarrow} q'$ \;

                            Éliminer un état $q \in Q$ : pour toute transition $p \overset e \longrightarrow q$ et $q \overset f \longrightarrow r$, on ajoute la transition $p \overset{ef} \longrightarrow r$ s'il n'existe pas de transition de $q$ vers lui-même et $p \overset{eg^*f} \longrightarrow r$ s'il existe une transition $q \overset g \longrightarrow q$\;

                            Supprimer $q$ et les transitions associées \;
                        }

                        \BlankLine

                        Après une éventuelle élimination des transitions multiples, l'automate est de la forme
                        \begin{center}
                            \begin{tikzpicture}
                                \node (i) at (0, 0) [state, initial, initial text={}] {$q_i$};
                                \node (f) at (2, 0) [state, accepting] {$q_f$};

                                \draw[->] (i) to node [above] {$e$} (f);
                            \end{tikzpicture}
                        \end{center}

                        L'expression régulière $e$ est le résultat de l'algorithme\;
                    \end{indalgo}

                    \vspace{12pt}
                    
                    La preuve de correction de cet algorithme est H.P. Elle nécessiterait de définir le modèle de calcul associé aux automates généralisés.
                    L'idée de la preuve consiste à remarquer que l'algorithme termine ($\abs Q$ est un variant de boucle), et démontrer l'invariant $\mathcal L(M') = \mathcal L(M)$.

                    Pour cela, on remarque que les transformations conservent le langage de l'automate :

                    $-$ Si
                    \begin{center}
                        \begin{tikzpicture}
                            \node (0) at (0, 0) [state] {$q$};
                            \node (1) at (2, 0) [state] {$q'$};

                            \draw[->] (0) to [out=20, in=160] node [above] {$e$} (1);
                            \draw[->] (0) to [out=-20, in=-160] node [below] {$f$} (1);
                        \end{tikzpicture}
                    \end{center}
                    et si la lecture du mot $u$ depuis $q$ mène à $q'$, c'est que $u \in \mathcal L(e)$ ou $u \in \mathcal L(f)$ donc $u \in \mathcal L(e) \cup \mathcal L(f) = \mathcal L(e | f)$.

                    \vspace{6pt}
                    
                    $-$ Si
                    \begin{center}
                        \begin{tikzpicture}
                            \node (p) at (0, 0) [state] {$p$};
                            \node (q) at (2, 0) [state] {$q$};
                            \node (r) at (4, 0) [state] {$r$};

                            \draw[->] (p) to node [above] {$e$} (q);
                            \draw[->] (q) to node [above] {$f$} (r);
                            \draw[->] (q) to [out=45, in=90, looseness=3] node [above] {$g$} (q);
                        \end{tikzpicture}
                    \end{center}
                    et si la lecture de $u$ mène de $p$ à $r$ \textit{via} $q$, alors en notant $n \in \N$ le nombre de fois que cette lecture passe par la transition
                    \begin{center}
                        \begin{tikzpicture}
                            \node (q) at (0, 0) [state] {$q$};
                            \draw[->] (q) to [out=45, in=90, looseness=3] node [above] {$g$} (q);
                        \end{tikzpicture}
                    \end{center}
                    Alors $\exists (x, y, z) \in \mathcal L(e) \times \mathcal L(g)^n \times \mathcal L(f)\ |\ u = xyz$

                    Donc $\exists n \in \N\ |\ u \in \mathcal L(e) \mathcal L(g)^n \mathcal L(f)$, donc
                    \[
                        u \in \mathcal L(e) \mathcal L(g)^* \mathcal L(f)
                        = \mathcal L(eg^*f)
                    \]

                    \vspace{6pt}
                    
                    Remarque : on obtient un automate de la forme
                    \begin{center}
                        \begin{tikzpicture}
                            \node (i) at (0, 0) [state, initial, initial text={}] {$q_i$};
                            \node (f) at (2, 0) [state, accepting] {$q_f$};

                            \draw[->] (i) to node [above] {$e$} (f);
                        \end{tikzpicture}
                    \end{center}
                    que dans le cas où il existe un chemin de $q_0$ à un état $q \in F$, \textit{i.e} $q_0$ est co-accessible, \textit{i.e} $\mathcal L(M) \neq \varnothing$.

                    Si $\mathcal L(M) = \varnothing$, ce que l'on peut vérifier en faisant un parcours du graphe de $M$ à partir de $q_0$, il est inutile d'appliquer l'algorithme de \textsc{Brzozowski} et Mc \textsc{Cluskey} (algorithme n°\ref{alg:4}, page \pageref{alg:4}) : l'expression régulière $\varnothing$ convient.
                \end{proof}
            \end{indt}

            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Exemple}}
                L'algorithme de \textsc{Brzozowski} et Mc \textsc{Cluskey} (algorithme n°\ref{alg:4}, page \pageref{alg:4}) fonctionne également sur les AFND :

                \begin{center}
                    \begin{tikzpicture}
                        \node (0) at (0, 0) [state, initial, initial text={}] {$q_0$};
                        \node (1) at (1.5, 2) [state] {$q_1$};
                        \node (2) at (4.5, 2) [state] {$q_2$};
                        \node (3) at (6, 0) [state, accepting] {$q_3$};

                        \draw[->] (0) to node [above left] {$a$} (1);
                        \draw[->] (0) to node [below] {$a, b$} (3);
                        \draw[->] (2) to node [above right] {$a$} (3);

                        \draw[->] (1) to [out=20, in=160] node [above] {$b$} (2);
                        \draw[->] (2) to [out=-160, in=-20] node [below] {$b$} (1);

                        \draw[->] (3) to [out=45, in=90, looseness=3] node [above right] {$b$} (3);
                    \end{tikzpicture}
                \end{center}

                $\mathcal L(M) = (a|b|ab(bb)^*a)b^*$

                \vspace{12pt}
                
                (1) On construit l'automate généralisé :
                \begin{center}
                    \begin{tikzpicture}
                        \node (i) at (-2, 0) [state, initial, initial text={}] {$q_i$};
                        \node (0) at (0, 0) [state] {$q_0$};
                        \node (1) at (1.5, 2) [state] {$q_1$};
                        \node (2) at (4.5, 2) [state] {$q_2$};
                        \node (3) at (6, 0) [state] {$q_3$};
                        \node (f) at (8, 0) [state, accepting] {$q_f$};

                        \draw[->] (0) to node [above left] {$a$} (1);
                        \draw[->] (0) to node [below] {$a, b$} (3);
                        \draw[->] (2) to node [above right] {$a$} (3);

                        \draw[->] (1) to [out=20, in=160] node [above] {$b$} (2);
                        \draw[->] (2) to [out=-160, in=-20] node [below] {$b$} (1);

                        \draw[->] (i) to node [above] {$\varepsilon$} (0);
                        \draw[->] (3) to node [above] {$\varepsilon$} (f);

                        \draw[->] (3) to [out=45, in=90, looseness=3] node [above right] {$b$} (3);
                    \end{tikzpicture}
                \end{center}

                \vspace{6pt}
                
                (2) On élimine les transitions multiples de $q_0$ à $q_3$, puis on élimine $q_0$

                \begin{center}
                    \begin{tikzpicture}
                        \node (i) at (0, 0) [state, initial, initial text={}] {$q_i$};
                        \node (1) at (1.5, 1) [state] {$q_1$};
                        \node (2) at (3.5, 1) [state] {$q_2$};
                        \node (3) at (5, 0) [state] {$q_3$};
                        \node (f) at (7, 0) [state, accepting] {$q_f$};

                        \draw[->] (2) to node [above right] {$a$} (3);

                        \draw[->] (1) to [out=20, in=160] node [above] {$b$} (2);
                        \draw[->] (2) to [out=-160, in=-20] node [below] {$b$} (1);

                        \draw[->] (i) to node [above left] {$a$} (1);
                        \draw[->] (3) to node [above] {$\varepsilon$} (f);

                        \draw[->] (3) to [out=45, in=90, looseness=3] node [above right] {$b$} (3);
                        \draw[->] (i) to [out=-10, in=-170] node [below] {$a | b$} (3);
                    \end{tikzpicture}
                \end{center}
                Pas de transition multiples, on élimine $q_1$ :

                \begin{center}
                    \begin{tikzpicture}
                        \node (i) at (0, 0) [state, initial, initial text={}] {$q_i$};
                        \node (2) at (1.5, 1) [state] {$q_2$};
                        \node (3) at (3, 0) [state] {$q_3$};
                        \node (f) at (5, 0) [state, accepting] {$q_f$};

                        \draw[->] (2) to node [above right] {$a$} (3);

                        \draw[->] (i) to node [above left] {$ab$} (2);
                        \draw[->] (3) to node [above] {$\varepsilon$} (f);

                        \draw[->] (3) to [out=45, in=90, looseness=3] node [above right] {$b$} (3);
                        \draw[->] (i) to [out=-10, in=-170] node [below] {$a | b$} (3);
                        \draw[->] (2) to [out=45, in=90, looseness=3] node [above right] {$bb$} (2);
                    \end{tikzpicture}
                \end{center}

                Pas de transitions multiples, on élimine $q_2$ :

                \begin{center}
                    \begin{tikzpicture}
                        \node (i) at (0, 0) [state, initial, initial text={}] {$q_i$};
                        \node (3) at (2.5, 0) [state] {$q_3$};
                        \node (f) at (4.5, 0) [state, accepting] {$q_f$};

                        \draw[->] (i) to [out=20, in=160] node [above] {$ab(bb)^* a$} (3);
                        \draw[->] (3) to node [above] {$\varepsilon$} (f);

                        \draw[->] (3) to [out=45, in=90, looseness=3] node [above right] {$b$} (3);
                        \draw[->] (i) to [out=-20, in=-160] node [below] {$a | b$} (3);
                    \end{tikzpicture}
                \end{center}

                On élimine les transitions multiples entre $q_i$ et $q_3$, puis on élimine $q_3$ :

                \begin{center}
                    \begin{tikzpicture}
                        \node (i) at (-2, 0) [state, initial, initial text={}] {$q_i$};
                        \node (f) at (2, 0) [state, accepting] {$q_f$};

                        \draw[->] (i) to node [above] {$(a|b|ab(bb)^*a)b^*$} (f);
                    \end{tikzpicture}
                \end{center}

                \vspace{6pt}
                
                On conclut que $\mathcal L(M) = (a|b|ab(bb)^*a)b^*$.

                \vspace{12pt}
                
                \begin{indt}{Remarques :}
                    $-$ L'ordre d'élimination a un impact sur l'expression régulière obtenue.

                    \boxed{\rm Exo} en éliminant les sommets dans l'ordre $q_3, q_2, q_1, q_0$, on aurait obtenu
                    \[
                        (a|b)b^* | a(bb)^*bab^*
                    \]

                    \vspace{6pt}
                    
                    $-$ L'automate de \textsc{Glushkov} associé à une expression régulière a toujours un nombre d'états de l'ordre du nombre de symboles dans l'expression régulière (mais le déterminiser peut donner un nombre d'états exponentiel), mais l'expression régulière obtenue par l'algorithme de \textsc{Brzozowski} et Mc \textsc{Cluskey} (algorithme n°\ref{alg:4}, page \pageref{alg:4}) peut être de taille exponentielle en le nombre d'états de l'automate \boxed{\rm Exo}.
                \end{indt}
            \end{indt}
        \end{indt}

        \vspace{12pt}
        
        \begin{indt}{\subsection{Langages non réguliers / non reconnaissables}}
            \begin{indt}{\subsubsection{Premier exemple}}
                \label{2.5.1}
                
                $L = \set{a^n b^n\ |\ n \in \N} \notin \Rec{\set{a, b}}$

                \vspace{12pt}
                
                \begin{proof}
                    Supposons que $L \in \Rec{\set{a, b}}$.

                    Alors $\exists M = \lr{\Sigma, Q, q_0, F, \delta}\ \text{un AFD}\ |\ \mathcal L(M) = M$ et que l'on peut supposer complet.

                    \[
                        \begin{array}{ccccc}
                            \varphi & : & \N & \longrightarrow & Q
                            \\
                                    && n & \longmapsto & \delta(q_0, a^n)
                        \end{array}
                    \]
                    est bien définie (car $M$ complet) et non injective ($Q$ est fini).

                    Donc $\exists n < m\ |\ \varphi(n) = \varphi(m)$

                    Alors
                    \[
                        F \ni \delta(q_0, a^n b^n)
                        = \delta(\delta(q_0, a^n), b^n)
                        = \delta(\delta(q_0, a^m), b^n)
                        = \delta(q_0, a^m b^n)
                    \]
                    Donc $a^m b^n \in L$ : absurde car $n \neq m$.
                \end{proof}
            \end{indt}

            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Second exemple}}
                $L = \set{v \widetilde v w\ |\ v, w \in \set{a, b}^+} \notin \Rec{\set{a, b}}$, où $\widetilde v$ est le miroir du mot $v$.

                \vspace{12pt}
                
                \begin{proof}
                    On suppose $L \in \Rec{\set{a, b}}$.
                    
                    Alors $\exists M = \lr{\Sigma, Q, q_0, F, \delta}\ \text{un AFD complet}\ |\ \mathcal L(M) = L$.
                    
                    \[
                        \begin{array}{ccccc}
                            \varphi & : & \N^* & \longrightarrow & Q
                            \\
                                    && n & \longmapsto & \delta(q_0, (ab)^n)
                        \end{array}
                    \]
                    est non injective, donc $\exists n < m \ |\ \varphi(n) = \varphi(m)$.
                    
                    \[
                        \begin{array}{rcl}
                            F &\ni& \delta(q_0, (ab)^n (ba)^n b)
                            \\
                            &=& \delta(\delta(q_0, (ab)^n), (ba)^n b)
                            \\
                            &=& \delta(\delta(q_0, (ab)^m), (ba)^n b)
                            \\
                            &=& \delta(q_0, (ab)^m (ba)^n b)
                        \end{array}
                    \]
                    
                    donc $(ab)^m (ba)^n b \in L$, donc $\exists v, w \in \set{a, b}^+\ |\ (ab)^m (ba)^n b = w \widetilde v w$.
                    
                    Le motif $v \widetilde v$ avec $v \neq \varepsilon$ impose la répétition de la dernière lettre de $v$.
                    
                    Donc comme l'unique répétition dans $(ab)^m (ba)^n b$ est celle du dernier $b$ de $(ab)^m$, on sait que $v = (ab)^m$, donc
                    \[
                        \abs{v \widetilde v w} \ge 4m + 1
                    \]
                    
                    Or $\abs{(ab)^m (ba)^n b} = 2(n + m) + 1 < 4m + 1$ : absurde.
                \end{proof}
            \end{indt}

            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Théorème (lemme de l'étoile)}}
                \label{2.5.3}

                \begin{emphBox}
                    Soit $\Sigma$ un alphabet, et $L$ un langage sur $\Sigma$.
                    
                    Si $L$ est reconnu par un AFD à $n$ états, alors
                    \[
                        \forall u \in L\ |\ \abs{u} \ge n,\
                        \exists x, y, z \in \Sigma^*\
                        \begin{array}{|l}
                            u = xyz
                            \\
                            \abs{xy} \le n
                            \\
                            y \neq \varepsilon
                            \\
                            xy^*z \subseteq L
                        \end{array}
                    \]
                \end{emphBox}

                \vspace{6pt}
                
                \begin{proof}
                    On note $u = u_1 \cdots u_{\abs u}$, et $M = \lr{\Sigma, Q, q_0, F, \delta}$ un AFD à $n$ états tel que $\mathcal L(M) = L$.

                    \[
                        \begin{array}{ccccc}
                            \varphi & : & \nset 0 n & \longrightarrow & Q
                            \\
                                    && k & \longmapsto & \delta(q_0, u_1 \cdots u_k)
                        \end{array}
                    \]
                    est non injective ($\abs{\nset 0 n} = n + 1 > n = \abs Q$), donc $\exists i, j \in \nset 0 n\ |\ i < j$ et tel que $\delta(q_0, u_1 \cdots u_i) = \delta(q_0, u_1 \cdots u_j)$
                    \begin{center}
                        \begin{tikzpicture}
                            \node (0) at (0, 0) [state, initial, initial text={}] {$q_0$};
                            \node (1) at (2, 0) [state] {$q_1$};
                            \node (d) at (4, 0) {$\cdots$};
                            \node (i) at (6, 0) [state] {$q_i = q_j$};
                            \node (i') at (6, 2) [state] {$q_{i - 1}$};
                            \node (f) at (8, -2) [state, accepting] {$q_{\abs u}$};

                            \draw[->] (0) to node [above] {$u_1$} (1);
                            \draw[->] (1) to node [above] {$u_2$} (d);
                            \draw[->] (d) to node [above] {$u_i$} (i);

                            \draw[->] (i) to [out=-90, in=135] node [left] {$u_{j + 1}$} (6, -2);
                            \draw[->, dashed] (6, -2) to [out=-45, in=180] (f);

                            \draw[->] (i') to node [left] {$u_j$} (i);

                            \draw[->] (i) to node [above] {$u_{i + 1}$} (8, 0);
                            \draw[->, dashed] (8, 0) to [out=0, in=20, looseness=1.5] (i');
                        \end{tikzpicture}
                    \end{center}

                    On note $x = u_1 \cdots u_i,\ y = u_{i + 1} \cdots u_j,\ z = u_{j + 1} \cdots u_{\abs u}$.

                    Alors $u = xyz,\ \abs{xy} = \abs{u_1 \cdots u_j} = j \le n,\ y \neq \varepsilon$ car $i + 1 \le j$.

                    On montre par récurrence que $\forall k \in \N,\ xy^k z \in L$ :

                    \vspace{6pt}
                    
                    $\bullet$ $xy^0z = xz = u_1 \cdots u_i u_{j + 1} \cdots u_{\abs u}$

                    \[
                        \begin{array}{rcl}
                            \delta(q_0, xz)
                            &=& \delta(\delta(q_0, u_1 \cdots u_i), u_{j + 1} \cdots u_{\abs u})
                            \\
                            &=& \delta(\delta(q_0, u_1 \cdots u_j), u_{j + 1} \cdots u_{\abs u})
                            \\
                            &=& \delta(q_0, xyz) \in F
                        \end{array}
                    \]

                    Donc $xy^0 z \in L$.

                    \vspace{6pt}
                    
                    $\bullet$ Hérédité : si $xy^k z \in L$, alors
                    \[
                        \begin{array}{rcl}
                            F \ni \delta(q_0, xy^k z)
                            &=& \delta(\delta(q_0, x), y^kz)
                            \\
                            &=& \delta(\delta(q_0, xy), y^kz)
                            \\
                            &=& \delta(q_0, xy^{k + 1}z)
                        \end{array}
                    \]

                    Donc $xy^{k + 1}z \in L$.
                \end{proof}
            \end{indt}

            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Application}}
                On reprend $L = \set{a^n b^n |\ n \in \N}$

                On suppose $L$ reconnu par un AFD, dont on note $n$ le nombre d'états.

                On considère $u = a^n b^n \in L$.

                Comme $\abs u \ge n$, par le lemme de l'étoile,
                \[
                    \exists x, y, z \in \Sigma^*\
                    \begin{array}{|l}
                        u = xyz
                        \\
                        \abs{xy} \le n
                        \\
                        y \neq \varepsilon
                        \\
                        xy^*z \subseteq L
                    \end{array}
                \]

                Comme $\abs{xy} \le n$ et $xy$ est un préfixe de $u$, on sait que $xy$ est constitué uniquement de $a$.

                Comme de plus $y \neq \varepsilon$,
                \[
                    \exists (n_1, n_2) \in \N \times \N^*\
                    \begin{array}{|l}
                        x = a^{n_1}
                        \\
                        y = a^{n_2}
                        \\
                        z = a^{n - n_1 - n_2}b^n
                    \end{array}
                \]

                $xz \in xy^* z \subseteq L$, mais $xz = a^{n - n_2}b^n$ et $n - n_2 \neq n$ car $n_2 \neq 0$ : absurde.
            \end{indt}

            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Remarque}}
                $\bullet$ Soit $\Sigma$ un alphabet, et $L$ un langage sur $\Sigma$.

                \begin{indt}{Si $L$ est reconnu par une AFD à $n$ états :}
                    $-$ Soit $\set{\abs u \ |\ u \in L} \subseteq \set 0 {n - 1}$, donc $L$ est fini ;

                    $-$ Soit $\exists u \in L\ |\ \abs u \ge n$, donc par le lemme de l'étoile, $L$ est infini, et $\set{\abs v\ |\ v \in L}$ contient tous les termes d'une suite arithmétique ($\abs{xy^kz} = \abs {xz} + k \abs y$)
                \end{indt}

                On peut par exemple s'en servir pour montrer que $L = \set{a^{3^n}\ |\ n \in \N}$ n'est pas reconnaissable.

                \vspace{6pt}
                
                $\bullet$ On peut reformuler le lemme de l'étoile de la manière suivante :

                \begin{emphBox}
                    Soit $\Sigma$ un alphabet, et $L$ un langage sur $\Sigma$.
                    
                    Si $L \in \Rec \Sigma$, alors
                    \[
                        \exists n \in \N\ |\
                        \forall u \in L,\
                        \abs u \ge n \Rightarrow \exists x, y, z \in \Sigma^*\
                        \begin{array}{|l}
                            u = xyz
                            \\
                            \abs{xy} \le n
                            \\
                            y \neq \varepsilon
                            \\
                            xy^*z \subseteq L
                        \end{array}
                    \]
                \end{emphBox}

                \vspace{6pt}
                
                Le lemme de l'étoile n'est pas infaillible : il existe des langages non reconnaissables qui vérifient la conclusion de cette version du lemme.

                \vspace{12pt}
                
                Exemple :

                $L = \set{v \widetilde v w\ |\ v, w \in \set{a, b}^+}$.
                On prend $n = 4$.

                Soit $u \in L\ |\ \abs u \ge 4$.

                $\exists v, w \in \set{a, b}^+\ |\ u = v \widetilde v w$.

                Comme $
                    \begin{cases}
                        v \neq \varepsilon
                        \\
                        w \neq \varepsilon
                    \end{cases},\
                    \exists a, v', b, w'\
                    \begin{array}{|l}
                        v = av'
                        \\
                        w = bw'
                    \end{array}
                $

                Donc $u = av' \widetilde{v'} abw'$.

                $-$ Si $v' = \varepsilon,\ u = aabw'$ et on note $x = aa,\ y = b,\ z = w'$

                $xyz = u,\ \abs{xy} = 3 \le 4, \ y \neq \varepsilon$ et $ \forall k \in \N,\ xy^kz = aab^kw'$ s'écrit $v'' \widetilde{v''} w''$ avec
                \[
                    \begin{cases}
                        v'' = a \neq \varepsilon
                        \\
                        w'' = b^k w' \neq \varepsilon
                    \end{cases}
                \]

                même quand $k = 0$, car $w' \neq \varepsilon$ (sinon $u = aab$ et $\abs u < 4$)

                \vspace{6pt}
                
                $-$ Si $v' \neq \varepsilon$, on prend $x = \varepsilon,\ y = a,\ z = v' \widetilde{v'} a b w'$.

                $xyz = u,\ \abs {xy} = 1 \le 4,\ y \neq \varepsilon$, et $\forall k \in \N,\ xy^kz = a^k v' \widetilde{v'} a b w' \in L$ car :

                $*$ si $k = 0,\ xy^0z = v' \widetilde{v'} \underbrace{abw'}_{\neq \varepsilon} \in L$

                $*$ si $k = 1,\ xyz = u \in L$

                $*$ si $k \ge 2,\ xy^kz = aa \underbrace{a^{k - 2} v' \widetilde {v'} a b w'}_{\neq \varepsilon} \in L$
            \end{indt}

            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Théorème (H.P, autre version du lemme de l'étoile)}}
                \begin{emphBox}
                    Soit $\Sigma$ un langage, et $L$ un langage sur $\Sigma$.
                    
                    Si $L$ est reconnu par un AFD à $n$ états, alors $\forall u \in L\ |\ u$ admet un facteur $v$ vérifiant $\abs v \ge n$, en notant $u = u_1 v u_2$ avec $u_1, u_2 \in \Sigma^*$,
                    \[
                        \exists x, y, z \in \Sigma^*\
                        \begin{array}{|l}
                            u = xyz
                            \\
                            \abs{xy} \le n
                            \\
                            y \neq \varepsilon
                            \\
                            xy^*z \subseteq L
                        \end{array}
                    \]
                \end{emphBox}

                \begin{proof}
                    Comme en \ref{2.5.3} (page \pageref{2.5.3}), en considérant
                    \[
                        \begin{array}{ccccc}
                            \varphi & : & \nset 0 n & \longrightarrow & Q
                            \\
                                    && k & \longmapsto & \delta(\delta(q_0, u_1), v_1 \cdots v_k)
                        \end{array}
                    \]

                    En effet, depuis $\delta(q_0, u_1)$, la lecture des $n$ premières lettres de $v$ construit un cycle que l'on peut itérer ou ignorer avant de lire la fin de $v$, puis $u_2$ afin d'aboutir à un état acceptant.
                \end{proof}
            \end{indt}

            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Application}}
                $L = \set{a^mb^n\ |\ m \ge n} \notin \Rec{\set{a, b}}$

                On suppose $L$ reconnu pat un automate à $n$ états, et on considère $u = a^n b^n$, de facteur $v = b^n\ |\ \abs v \ge n$.

                Alors
                \[
                    \exists x, y, z \in \set{a, b}^*\
                    \begin{array}{|l}
                        v = xyz
                        \\
                        \abs{xy} \le n
                        \\
                        y \neq \varepsilon
                        \\
                        a^nx y^* z \subseteq L
                    \end{array}
                \]

                Comme avant,
                \[
                    \exists (n_1, n_2) \in \N \times \N^*\
                    \begin{array}{|l}
                        x = b^{n_1}
                        \\
                        y = b^{n_2}
                        \\
                        z = b^{n - n_1 - n_2}
                    \end{array}
                \]

                $\underbrace{a^n xy^2z}_{\in L} = a^n b^{n + n_2}$

                Mais $n + n_2 > n$ car $n_2 \neq 0$ : absurde.
            \end{indt}
        \end{indt}
    \end{indt}

    \vspace{12pt}
    
    \begin{indt}{\section{Grammaires non contextuelles}}
        \begin{indt}{\subsection{Définitions}}
            \begin{indt}{\subsubsection{Introduction}}
                Les langages réguliers et leur implémentation sous forme d'automates restent insuffisantes pour certains des besoins exprimés en \ref{1.1.1} (page \pageref{1.1.1}).

                \begin{indt}{Par exemple, dans le cadre de la compilation d'un programme :}
                    $-$ On ne peut pas vérifier si un texte donné est est un programme syntaxiquement correct (vérifier qu'une expression est bien parenthésée est au moins aussi difficile que reconnaître le langage non régulier $\set{a^n b^n\ |\ n \in \N}$) ;

                    $-$ Il est impossible d'analyser la structure du programme : un automate accepte un mot sans fournir d'information sur les propriétés structurelles du mot qui ont mené à son acceptation.
                \end{indt}

                \vspace{12pt}
                
                On a donc besoin d'un outil plus puissant que les automates.
                On peut utiliser les \emph{grammaires}, qui sont séparées en plusieurs catégories, qui vont des \emph{grammaires régulières}, équivalentes au automates, aux \emph{grammaires formelles générales}, qui sont équivalents aux machines de \textsc{Turing} (\textit{cf}, hiérarchie de \textsc{Chamsky}, H.P).
                Le programme de MPI se limite à l'étude des \emph{grammaires non contextuelles}.
            \end{indt}

            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Définition (\textit{grammaire non contextuelle})}}
                \begin{indt}{Une \emph{grammaire non contextuelle} est un quadruplet $G = \lr{\Sigma, V, S, R}$, où :}
                    $-$ $\Sigma$ est un alphabet dont les éléments sont appelés \emph{symboles terminaux} ;

                    $-$ $V$ est un alphabet dont les éléments sont appelés \emph{symboles non terminaux}, ou \emph{variables}.
                    On suppose $\Sigma \cap V = \varnothing$ ;

                    $-$ $S \in V$ est appelé \emph{symbole initial}, ou \emph{axiome} ;

                    $-$ $R \subseteq V \times \lr{\Sigma \cup V}^*$ est l'ensemble des règles de production.
                \end{indt}

                \vspace{12pt}
                
                \begin{indt}{Remarques :}
                    $-$ On écrit en général les symboles non terminaux en capitale, et les symboles terminaux en minuscule ;

                    $-$ Les règles de production $(X, u) \in R$ sont notés $X \rightarrow u$, et on réunit souvent les règles de même membre gauche : si $(X, u_1), (X, u_2), \ldots, (X, u_n) \in R$, on note $X \rightarrow u_1 \ |\ u_2 \ |\ \cdots \ |\ u_n$ ;

                    $-$ Les grammaires non contextuelles sont aussi appelées grammaires \textit{hors contexte} (\textit{context-free grammar} en anglais) ou grammaires \textit{algébriques}.
                    La non contextualité des grammaires algébriques vient de la forme des règles : une règle $uXw \Rightarrow uvw$ rendrait la grammaire contextuelle (H.P).
                \end{indt}
            \end{indt}

            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Exemples}}
                \label{3.1.3}

                $\bullet$ Nous avons déjà vu des grammaires pour la syntaxe des formules logiques (\textit{cf} chapitre 8)

                $-$ Logique propositionnelle : $G = \lr{\Sigma, V, S, R}$, avec

                \[
                    \begin{array}{rcl}
                        \Sigma &=& \set{\neg, \vee, \wedge, \rightarrow, (, ), x, y, z, \ldots}
                        \\
                        V &=& \set S
                        \\
                        R &:& S \rightarrow (S) \ |\ \neg S \ |\ S \vee S \ |\ S \wedge S \ |\ S \rightarrow S \ |\ x \ |\ y \ |\ z \ |\ \cdots
                    \end{array}
                \]

                \vspace{12pt}
                
                $\bullet$ Logique de premier ordre : étant donné une signature $\Sigma'$, on construit $G = \lr{\Sigma, V, S, R}$, où
                \[
                    \begin{array}{rcl}
                        \Sigma &=& \Sigma' \cup \set{(, ), \neg, \vee, \wedge, \rightarrow, x, y, z, \ldots, \forall, \exists}
                        \\
                        V &=& \set{S, T, X}
                        \\
                        R &:& S \rightarrow (S) \ |\ S \vee S \ |\ S \wedge S \ |\ \neg S \ |\ S \rightarrow S \ |\ \forall X\ S \ |\ \exists X \ S \ |\ p(T, \ldots, T)
                        \\
                          && X \rightarrow x \ |\ y \ |\ z \ |\ \cdots
                        \\
                          && T \rightarrow X \ |\ f(T, \ldots, T)
                    \end{array}
                \]

                où $p \in \Sigma'$ est un symbole de prédicat, en respectant son arité, et $f \in \Sigma'$ est un symbole de fonction, en respectant l'arité.

                \vspace{12pt}
                
                $\bullet$ Expressions arithmétiques : $G = \lr{\Sigma, V, S, R}$, où :
                \[
                    \begin{array}{rcl}
                        \Sigma &=& \set{(, ), +, \times, a}
                        \\
                        V &=& \set{S}
                        \\
                        R &:& S \rightarrow (S) \ |\ S + S \ |\ S \times S \ |\ a
                    \end{array}
                \]
            \end{indt}

            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Modèle de calcul associé}}
                $\bullet$  Exemple : on considère une grammaire pout un mini langage de programmation : $G = \lr{\Sigma, V, S, R}$, où :
                \[
                    \begin{array}{rcl}
                        \Sigma &=& \set{x, \mathtt{print}, 0, 1, \ldots, 9, =, +, ;, (, )}
                        \\
                        V &=& \set{S, I, E, X, N, C}
                        \\
                        R
                        &:& S \rightarrow I ; S \ |\ \varepsilon
                        \\
                        && I \rightarrow \mathtt{print}(E) \ |\ X = E
                        \\
                        && E \rightarrow X \ |\ N \ |\ E + E
                        \\
                        && X \rightarrow xN
                        \\
                        && N \rightarrow C \ |\ CN
                        \\
                        && C \rightarrow 0 \ |\ \cdots \ |\ 9
                    \end{array}
                \]
                Le programme $x0 = 42;$ est engendré ainsi :
                    
                \begin{tabular}{ll}
                    $-$ on part de $S$ ;
                    & $S$
                    \\
                    $-$ on applique la règle $S \rightarrow I ; S$
                    & $I ; S$
                    \\
                    $-$ on applique $I \rightarrow X = E$ ;
                    & $X = E ; S$
                    \\
                    $-$ on applique $X \rightarrow xN$ ;
                    & $xN = E ; S$
                    \\
                    $-$ on applique $N \rightarrow C$ ;
                    & $xC = E; S$
                    \\
                    $-$ on applique $C \rightarrow 0$ ;
                    & $x0 = E; S$
                    \\
                    $-$ on applique $E \rightarrow N$ ;
                    & $x0 = N; S$
                    \\
                    $-$ on applique $N \rightarrow CN$ ;
                    & $x0 = CN; S$
                    \\
                    $-$ on applique $C \rightarrow 4$ ;
                    & $x0 = 4N; S$
                    \\
                    $-$ on applique $N \rightarrow C$ puis $C \rightarrow 2$ ;
                    & $x0 = 42; S$
                    \\
                    $-$ on applique $S \rightarrow \varepsilon$.
                    & $x0 = 42;$
                \end{tabular}

                \vspace{6pt}
                
                La succession des règles appliqués est appelée \emph{dérivation} de $x0 = 42;$

                \vspace{12pt}
                
                $\bullet$ Définition (\textit{dérivation immédiate}) : Soit $G = \lr{\Sigma, V, S, R}$ une grammaire non contextuelle.

                $-$ Soit $u = u_1 X u_2 \in \lr{\Sigma \cup V}^* V \lr{\Sigma \cup V}^*$, et $v \in \lr{\Sigma \cup V}^*$.

                On dit que $u$ se \emph{dérive immédiatement} en $v$, noté $u \Rightarrow v$, si et seulement si $\exists X \rightarrow w \in R\ |\ v = u_1 w u_2$.

                \vspace{6pt}
                
                $-$ On note $\Rightarrow^*$ la clôture réflexive et transitive de $\Rightarrow$, \textit{i.e}
                \[
                    u \Rightarrow^* v
                    \ssi
                    \exists n \in \N^*,\ \exists u_0 \cdots u_n \in \lr{\Sigma \cup V}^*\
                    \begin{array}{|l}
                        u_0 = u
                        \\
                        u_n = v
                        \\
                        \forall i \in \nset 0 {n - 1},\ u_i \Rightarrow u_{i + 1}
                    \end{array}
                \]

                Si $u \Rightarrow^* v$, on dit que $u$ \emph{se dérive en} $v$, et toute séquence de dérivations immédiates $u \Rightarrow \cdots \Rightarrow v$ est appelée \emph{dérivation de $v$ depuis $u$}.

                \vspace{12pt}
                
                $\bullet$ Exemple : dans l'exemple précédent :

                $X = E; S \Rightarrow xN = E; S$

                $X = E; S \Rightarrow^* x0 = 4N; S$

                $S \Rightarrow^* x0 = 42;$

                C'est ce type de dérivation qui définit le langage engendré par la grammaire.

                \vspace{12pt}
                
                $\bullet$ Définition (\textit{Langage engendré / non contextuel}) :

                $-$ Soit $G = \lr{\Sigma, V, S, R}$ une grammaire non contextuelle.

                Le langage engendré par $G$ est le langage
                \[
                    \mathcal L(G) = \set{u \in \Sigma^*\ |\ S \Rightarrow^* u}.
                \]

                $-$ Soit $\Sigma$ un alphabet, et $L$ un langage sur $\Sigma$.

                $L$ est dit \emph{non contextuel}, ou \emph{algébrique}, si et seulement si il existe une grammaire non contextuelle $G$ telle que $\mathcal L(G) = L$.
            \end{indt}

            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Théorème}}
                \begin{emphBox}
                    Soit $\Sigma$ un alphabet.
                    
                    $(1)$ $\Reg(\Sigma)$ est inclus dans l'ensemble des langages alébriques sur $\Sigma$
                    
                    $(2)$ Si $\abs \Sigma \ge 2$, alors cette inclusion est stricte.
                \end{emphBox}

                \vspace{6pt}
                
                \begin{proof}
                    $(1)$ Par le théorème de \textsc{Kleene} (\ref{2.4}, page \pageref{2.4}) et l'algorithme de complétion (algorithme \ref{alg:2}, page \pageref{alg:2}), il suffit de montrer que pour tout AFD complet $M = \lr{\Sigma, Q, q_0, D, \delta},\ \mathcal L(M)$ est algébrique.

                    On construit $G = \lr{\Sigma, V, X_{q_0}, R}$, où :
                    \[
                        \begin{array}{rcll}
                            V &=& \set{X_q\ |\ q \in Q}
                            \\
                            R &:& X_q \rightarrow aX_{\delta(q, a)} & \forall q \in Q\ \forall a \in \Sigma
                            \\
                              && X_q \rightarrow \varepsilon & \forall q \in F
                        \end{array}
                    \]

                    On montre par récurrence sur $n \in \N$ que $\forall u \in \Sigma^*$ de taille $n$,
                    \[
                        \forall q, q' \in Q,\ X_q \Rightarrow^* uXq' \ssi \delta(q, u) = q'
                    \]

                    \vspace{6pt}
                    
                    $-$ Initialisation :
                    si $n = 0$, nécessairement $u = \varepsilon$, et
                    \[
                        \begin{array}{rcl}
                            \forall q, q' \in Q,\
                            X_q \Rightarrow^* X_{q'}
                            &\ssi&
                            X_q = X_{q'}
                            \\
                            &\ssi& q = q'
                            \\
                            &\ssi& \delta(q, \varepsilon) = q'
                        \end{array}
                    \]

                    \vspace{6pt}
                    
                    $-$ Hérédité : on suppose la propriété vraie au rang $n \in \N$.

                    Soit $u \in \Sigma^*\ |\ \abs u = n + 1$, soient $q, q' \in Q$.

                    On sait que
                    $
                        \exists (v, a) \in \Sigma^* \times \Sigma\ 
                        \begin{array}{|l}
                            u = va
                            \\
                            \abs v = n
                        \end{array}
                    $

                    \[
                        \begin{array}{rcll}
                            X_q \Rightarrow^* uX_{q'}
                            &\ssi& X_q \Rightarrow^* vaX_{q'}
                            \vspace{6pt}
                            \\
                            &\ssi& \exists q'' \in Q\
                            \begin{array}{|l}
                                X_q \Rightarrow^* vX_{q''}
                                \\
                                X_{q''} \Rightarrow aX_{q'}
                            \end{array}
                            &
                            \text{d'après la forme des règles}
                            \vspace{6pt}
                            \\
                            &\ssi&
                            \multicolumn{2}{c}{
                                \kern-13pt
                                \exists q'' \in Q\
                                \begin{array}{|ll}
                                    \delta(q, v) = q''
                                    & \text{par H.R}
                                    \\
                                    \delta(q'', a) = q'
                                    & \text{par définition des règles}
                                \end{array}
                            }
                            \vspace{6pt}
                            \\
                            &\ssi& \delta(\delta(q, v), a) = q'
                            & \text{car l'automate est complet}
                            \vspace{6pt}
                            \\
                            &\ssi& \delta(q, u) = q'
                        \end{array}
                    \]

                    \vspace{6pt}
                    
                    $\bullet$ On en déduit que $\forall u \in \Sigma^*$,
                    \[
                        \begin{array}{rcl}
                            u \in \mathcal L(M)
                            &\ssi& \delta(q_0, u) \in F
                            \\
                            &\ssi& \exists q_F \in F\ |\ \delta(q_0, u) = q_F
                            \\
                            &\ssi& \exists q_F \in F\ |\ X_{q_0} \Rightarrow^* uX_{q_F}
                            \\
                            &\ssi& X_{q_0} \Rightarrow^* u
                            \\
                            &\ssi& u \in \mathcal L(G)
                        \end{array}
                    \]

                    \vspace{12pt}
                    
                    $(2)$ Si $\abs \Sigma \ge 2,\ \exists a \neq b \in \Sigma$.

                    Il suffit de montrer que $\set{a^n b^n\ |\ n \in \N}$ est algébrique (d'après \ref{2.5.1}, page \pageref{2.5.1}).

                    On considère la grammaire $G = \lr{\Sigma, V, S, R}$, où :
                    \[
                        \begin{array}{rcl}
                            V &=& \set S
                            \\
                            R &:& S \rightarrow aSb \ |\ \varepsilon
                        \end{array}
                    \]

                    On montre par récurrence sur $n \in \N$ que l'unique mot sur $\Sigma$ engendré par une dérivation de longueur $n + 1$ est $a^n b^n$.

                    \vspace{6pt}
                    
                    $-$ Initialisation : si $n = 0$, l'unique dérivation de longueur $1$ produisant un mot sur $\Sigma$ est $S \Rightarrow \varepsilon = a^0 b^0$

                    \vspace{6pt}
                    
                    $-$ Hérédité : on suppose la propriété vraie pour $n$.

                    On considère une dérivation de longueur $n + 2$ : $S \Rightarrow^* u \in \Sigma^*$.

                    Comme $n = 2 \ge 2$, la première dérivation immédiate de cette dérivation est $S \Rightarrow aSb$, donc $u$ s'écrit $avb$ où $v$ est tel que $S \Rightarrow^* v$ par une dérivation de longueur $n + 1$.

                    Par H.R, $v = a^n b^n$, donc $u = a^n b^n b = a^{n + 1} b^{n + 1}$

                    \vspace{12pt}
                    
                    $\bullet$  On a donc $\mathcal L(G) = \set{a^n b^n\ |\ n \in \N}$ car il n'existe pas de dérivation de longueur nulle d'un mot sur $\Sigma$.
                \end{proof}
            \end{indt}

            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Remarques}}
                $\bullet$ Si $\abs \Sigma = 1$, alors tout langage algébrique est régulier (la démonstration nécessite des outils H.P)

                \vspace{6pt}
                
                $\bullet$ Même si les grammaires non contextuelles sont strictement plus expressives que les AFD, elles restent équivalentes aux automates à pile (H.P).
                Ces automates sont des automates munis d'une mémoire binaire sous la forme d'une pile (à chaque transition, on peut empiler ou dépiler un caractère).

                \vspace{6pt}
                
                $\bullet$ Il existe une généralisation de lemme de l'étoile aux grammaires non contextuelles (H.P), qui permet de démontrer que certains langages ne sont pas algébriques.

                Exemple : $\set{a^n b^n c^n\ |\ n \in \N}$
            \end{indt}
        \end{indt}

        \vspace{12pt}
        
        \begin{indt}{\subsection{Ambiguïté}}
            \begin{indt}{\subsubsection{Dérivations multiples}}
                \label{3.2.1}

                $\bullet$ Remarque : étant donné une grammaire et un mot du langage engendré par cette grammaire, ce mot peut admettre plusieurs dérivations distinctes à partir du moment où, dans une dérivation de ce mot, on atteint un mot contenant au moins deux symboles non terminaux.

                \vspace{12pt}
                
                $\bullet$  Exemple : on reprend la grammaire
                \[
                    G = \lr{\set{a, +, \times, (, )},\ \set{S},\ S,\ \set{S \rightarrow a \ |\ S + S \ |\ S \times S \ |\ (S)}}
                \]
                vue en \ref{3.1.3} (page \pageref{3.1.3}), et on considère $u = a \times (a + a)$.

                \vspace{6pt}
                
                On a les dérivations :
                \[
                    S \Rightarrow S \times S
                    \Rightarrow a \times S
                    \Rightarrow a \times (S)
                    \Rightarrow a \times (S + S)
                    \Rightarrow a \times (a + S)
                    \Rightarrow a \times (a + a)
                \]
                et
                \[
                    S
                    \Rightarrow S \times S
                    \Rightarrow S \times (S)
                    \Rightarrow S \times (S + S)
                    \Rightarrow S \times (a + S)
                    \Rightarrow a \times (a + S)
                    \Rightarrow a \times (a + a)
                \]

                \vspace{12pt}
                
                $\bullet$ Remarque : pour éviter d'avoir à faire des choix, on peut définir à l'avance un ordre de traitement des non terminaux par exemple en appliquant une règle à celui qui se trouve le plus à gauche.

                \vspace{12pt}
                
                $\bullet$ Définition (\textit{Dérivation à gauche / droite}) :
                Soit $G = (\Sigma, V, S, R)$ une grammaire non contextuelle.

                $-$ Soit $u = u_1 X u_2 \in \lr{\Sigma \cup V}^* V \lr{\Sigma \cup v}^*$, et $v \in \lr{\Sigma \cup V}^*\ |\ u \Rightarrow v$.

                On dit que $u \Rightarrow v$ est une dérivation immédiate \emph{à gauche} (respectivement \emph{à droite}) si et seulement si $u_1 \in \Sigma^*$ (respectivement $u_2 \in \Sigma^*$), \textit{i.e} $X$ est le non terminal le plus à gauche (respectivement à droite) de $u$.

                \vspace{6pt}
                
                $-$ Soient $u, v \in \lr{\Sigma \cup V}^*\ |\ u \Rightarrow^* v$.

                On dit que $u \Rightarrow^* v$ est une dérivation \emph{à gauche} (respectivement \emph{à droite}) si et seulement si cette dérivation n'est constituée que de dérivations immédiates à gauche (respectivement à droite).

                \vspace{12pt}
                
                $\bullet$ Exemple : dans l'exemple précédant, la première dérivation de $a \times (a + a)$ est une dérivation à gauche et la seconde n'est ni à gauche ni à droite (\textit{cf} dérivation immédiate $S \times (S + S) \Rightarrow S \times (a + S)$).

                \vspace{12pt}
                
                $\bullet$ Proposition : Soit $G = \lr{\Sigma, V, S, R}$ une grammaire non contextuelle, et $u \in \Sigma^*$

                Alors
                \[
                    u \in \mathcal L(G)
                    \ssi
                    \exists \ \text{une dérivation à gauche (resp. à droite)}\
                    S \Rightarrow^* u
                \]

                \vspace{6pt}
                
                \begin{proof}
                    \boxed{\Leftarrow} trivial.

                    \boxed{\Rightarrow} si $u \in \mathcal L(G)$, alors il existe une dérivation $S = u_0 \Rightarrow u_1 \Rightarrow \cdots \Rightarrow u_n = u$.

                    Il suffit de démontrer par récurrence forte sur $n \in \N$ que pour toute dérivation $u_0 \Rightarrow \cdots \Rightarrow u_n$ avec $u_n \in \Sigma^*$, il existe une dérivation à gauche $u_0 \Rightarrow^* u_n$.

                    \vspace{6pt}
                    
                    $-$ Initialisation : si $n = 0$, il n'y a pas de dérivation immédiate, donc on a bien une dérivation à gauche.

                    \vspace{6pt}
                    
                    $-$ Hérédité : on suppose la propriété est vraie $\forall k \le n$.

                    On considère une dérivation $u_0 \Rightarrow \cdots \Rightarrow u_{n + 1}$, avec $u_{n + 1} \in \Sigma^*$.

                    Si ce n'est pas une dérivation à gauche, $\exists i \in \nset 0 n\ |\ u_i \Rightarrow u_{i + 1}$ n'est pas à gauche.

                    On suppose $i$ minimal.

                    Comme $u_i \Rightarrow u_{i + 1}$ n'est pas à gauche,
                    \[
                        \exists x, y, z \in \lr{\Sigma \cup V}^*,\
                        \exists X_1, X_2 \in V\
                        \begin{array}{|l}
                            u_i = x X_1 y X_2 z
                            \\
                            x \in \Sigma^*
                            \\
                            \exists X_2 \rightarrow v \in R\ |\ u_{i + 1} = x X_1 yvz
                        \end{array}
                    \]

                    Comme $u_{n + 1} \in \Sigma^*,\ X_1$ n'y apparaît pas, donc $\exists j > i\ |\ u_k \Rightarrow u_{j + 1}$ élimine $X_1$.

                    Donc
                    \[
                        \exists X_1 \rightarrow w \in R,\
                        \exists t \in \lr{\Sigma \cup V}^*\
                        \begin{array}{|l}
                            u_j = x X_1 t
                            \\
                            u_{j + 1} = x w t
                        \end{array}
                    \]

                     On peut alors construire la dérivation
                     \[
                         u_i = x X_1 y X_2 z
                         \Rightarrow
                         \underbrace{xwy X_2 z}_{= u_i [X_1 := w]}
                         \Rightarrow
                         \underbrace{xwyvz}_{= u_{i + 1} [X_1 := w]}
                         \Rightarrow \cdots
                         \Rightarrow
                         \underbrace{u_j [X_1 := w]}_{= u_{j + 1}}
                     \]

                     En appliquant les règles de la dérivation initiale.

                     On a donc une dérivation
                     \[
                         u_i [X_1 := w]
                         \Rightarrow
                         u_{i + 1} [X_1 := w]
                         \Rightarrow
                         \underbrace{u_{j} [X_1 := w]}_{= u_{j + 1}}
                         \Rightarrow
                          u_{j + 1}
                          \Rightarrow
                          \cdots
                          \Rightarrow
                          u_{n + 1}
                     \]

                     Cette dérivation est de longueur $j - i + n + 1 - (j + 1) = n - i \le n$

                     Comme $u_{n + 1} \in \Sigma^*$, l'hypothèse de récurrence donne une dérivation à gauche $u_i [X_1 := w] \Rightarrow^* u_{n + 1}$.

                     En la concaténant avec la dérivation à gauche $u_0 \Rightarrow \cdots \Rightarrow u_i \Rightarrow u_i [X_1 := w]$ on obtient une dérivation à gauche $u_0 \Rightarrow^* u_{n + 1}$
                \end{proof}
            \end{indt}

            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Arbre d'analyse}}
                $\bullet$ Remarque : cette démonstration montre que l'on peut dans certains cas permuter les règles appliquées dans une dérivation.
                Cela indique que la notion de dérivation n'est pas assez précise pour étudier la structure des mots du langage engendré par une grammaire.
                On utilise alors une structure arborescente pour représenter l'analyse de la structure d'un mot donné effectué lors de la construction d'une dérivation de ce mot.

                \vspace{12pt}
                
                $\bullet$ Définition (\textit{Arbre d'analyse}) :
                Soit $G = \lr{\Sigma, V, R, S}$ une grammaire non contextuelle, et $u \in \mathcal L(G)$.

                \begin{indt}{Un \emph{arbre d'analyse} pour $u$, ou \emph{arbre de dérivation} de $u$, ou \emph{arbre syntaxique} de $u$, est un arbre étiqueté par des éléments de $\set \varepsilon \cup \Sigma \cup V$ tels que :}
                    $-$ La racine est étiquetée par $S$ ;

                    $-$ Les n\oe uds internes sont étiquetés par des éléments de $V$ ;

                    $-$ Les feuilles sont étiquetés par des éléments de $\Sigma \cup \set \varepsilon$ ;

                    $-$ La concaténation des étiquettes des feuilles de gauche à droite donne $u$ ;

                    $-$ Pour chaque n\oe ud interne d'étiquette $X$ et dont les fils sont étiquetés de gauche à droite par $u_1, \ldots, u_n$, $X \rightarrow u_1\ |\ \cdots\ |\ u_n \in R$
                \end{indt}

                \vspace{12pt}
                
                $\bullet$ Exemple : on reprend l'exemple de \ref{3.2.1} (page \pageref{3.2.1}). L'arbre d'analyse de $a \times (a + a)$ est :
                
                \begin{center}
                    \begin{tikzpicture}
                        \node (0) at (0, 0) {$S$}
                            child {node {$S$}
                                child {node {$a$}}
                            }
                            child {node {$\times$}}
                            child {node {$S$}
                                child {node {$($}}
                                child {node {$S$}
                                    child {node {$S$}
                                        child {node {$a$}}
                                    }
                                    child {node {$+$}}
                                    child {node {$S$}
                                        child {node {$a$}}
                                    }
                                }
                                child {node {$)$}}
                            }
                        ;
                    \end{tikzpicture}
                \end{center}

                \vspace{12pt}
                
                $\bullet$ Remarque : un arbre d'analyse définit un ensemble de règles à appliquer pour obtenir un mot, sans donner d'indication sur l'ordre  d'application des règles en dehors des dépendances entre règles induites par la forme du mot et des règles.

                Les parcours de l'arbre d'analyse donnent toutes les dérivations possibles en utilisant l'ensemble des règles associés à l'arbre.

                En particulier, les dérivations à gauche et à droite correspondent aux parcours en profondeur de l'arbre d'analyse, où l'ordre des appels récursifs sur les fils d'un n\oe ud est celui de gauche à droite / droite à gauche.
            \end{indt}

            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Ambiguïté}}
                $\bullet$ Remarque : il existe des grammaires et des mots du langage engendré par ces grammaires tels que le mot admet plusieurs arbres d'analyse, ce qui signifie qu'il y a ambiguïté sur la structure du mot.

                \vspace{12pt}
                
                $\bullet$ Exemple : dans l'exemple de \ref{3.2.1} (page \pageref{3.2.1}), on considère $u = a \times a + a$, qui admet les arbres suivants :
                
                \begin{center}
                    \begin{tikzpicture}
                        \node (0) at (0, 0) {$S$}
                            child {node {$S$}
                                child {node {$a$}}
                            }
                            child {node {$\times$}}
                            child {node {$S$}
                                child {node {$S$}
                                    child {node {$S$}
                                        child {node {$a$}}
                                    }
                                    child {node {$+$}}
                                    child {node {$S$}
                                        child {node {$a$}}
                                    }
                                }
                            }
                        ;

                        \node (1) at (8, 0) {$S$}
                            child {node {$S$}
                                child {node {$S$}
                                    child {node {$S$}
                                        child {node {$a$}}
                                    }
                                    child {node {$\times$}}
                                    child {node {$S$}
                                        child {node {$a$}}
                                    }
                                }
                            }
                            child {node {$+$}}
                            child {node {$S$}
                                child {node {$a$}}
                            }
                        ;
                    \end{tikzpicture}
                \end{center}

                qui correspondent aux parenthésages $a \times (a + a)$ et $(a \times a) + a$.

                Les dérivations à gauche associées sont :
                \[
                    S
                    \Rightarrow S \times S
                    \Rightarrow a \times S
                    \Rightarrow a \times S + S
                    \Rightarrow a \times a + S
                    \Rightarrow a \times a + a
                \]
                \[
                    S
                    \Rightarrow S + S
                    \Rightarrow S \times S + S
                    \Rightarrow a \times S + S
                    \Rightarrow a \times a + S
                    \Rightarrow a \times a + a
                \]

                \vspace{12pt}
                
                $\bullet$ Définition (\textit{grammaire ambiguë}) :
                Soit $G = \lr{\Sigma, V, S, R}$ une grammaire non contextuelle.

                $G$ est dite \emph{ambiguë} si et seulement si $\exists u \in \mathcal L(G)\ |\ u$ admet deux arbres d'analyse distincts, si et seulement si  $\exists u \in \mathcal L(G)\ |\ u$ admet deux dérivations à gauche distinctes.

                \vspace{12pt}
                
                $\bullet$ Exemple classique : le problème "sinon pendant" (\textit{dangling else}), qui survient pour les langages de programmation permettant des instructions conditionnelles sans branche \texttt{else}.

                En considérant l'extrait suivant d'une grammaire simplifiée du langage C :
                \[
                    \begin{array}{rcl}
                        I & \rightarrow & \mathtt{if} (E)\ I \ |\ \mathtt{if} (E)\ I\ \mathtt{else}\ I \ |\ E ; \ |\ \cdots
                        \\
                        E & \rightarrow & x = E \ |\ E < E \ |\ E > E \ |\ \cdots
                    \end{array}
                \]

                On peut dériver l'expression
                \begin{lstlisting}[language=C, xleftmargin=80pt]
if (x > a) if (x < b) x = 42; else x = 0;\end{lstlisting}

                On peut construire deux arbres d'analyse pour cette expression, correspondant aux deux manières d'associer le \texttt{else} à l'un des \texttt{if} :

                \begin{lstlisting}[language=C, xleftmargin=80pt]
if (x > a) {
    if (x < b)
        x = 42;

    else
        x = 0;
}\end{lstlisting}

                \begin{lstlisting}[language=C, xleftmargin=80pt]
if (x > a) {
    if (x < b)
        x = 42;
}
else
    x = 0;\end{lstlisting}

                \vspace{12pt}
                
                Remarque : en C, on utilise une règle externe à la grammaire qui consiste à associer le \texttt{else} au \texttt{if} le plus proche. On est donc dans le premier cas.
            \end{indt}

            \vspace{12pt}
            
            \begin{indt}{\subsubsection{\'Equivalence de grammaires}}
                $\bullet$ Définition : Soient $G_1, G_2$ des grammaires non contextuelles.

                On dit que $G_1$ et $G_2$ sont \emph{faiblement équivalentes} si et seulement si
                \[
                    \mathcal L(G_1) = \mathcal L(G_2)
                \]

                \vspace{12pt}
                
                $\bullet$ Remarque : l'équivalence forte (H.P) tire des conséquences de l'ambiguïté et impose une contrainte supplémentaire de "cohérence" dans les dérivations qu'il est possible d'écrire avec les deux grammaires : une grammaire ambiguë ne peut être fortement équivalente à une grammaire inambiguë.

                \vspace{12pt}
                
                $\bullet$ Exemple : on reprend la grammaire $G$ (ambiguë) de l'exemple en \ref{3.2.1} (page \pageref{3.2.1}).

                On considère $G' = \lr{\set{a, +, \times, (, )},\ \set{S, X, Y},\ S,\ R}$, où :
                \[
                    \begin{array}{rcl}
                        R
                        &=&
                        S \rightarrow S + X \ |\ X
                        \\
                        && X \rightarrow X \times Y \ |\ Y
                        \\
                        && Y \rightarrow (S) \ |\ a
                    \end{array}
                \]

                $G'$ est inambiguë et faiblement équivalente à $G$.

                \vspace{12pt}
                
                $\bullet$ Remarque : il existe des langages algébriques tels que toute grammaire qui engendre le langage est ambiguë. On parle de langage inhéremment / intrinsèquement ambigu (H.P).

                Exemple :

                \[
                    \set{a^i b^j c^k\ |\ i = j\ \text{ou}\ j = k}
                \]
                $a^nb^nc^n$
            \end{indt}
        \end{indt}

        \vspace{12pt}
        
        \begin{indt}{\subsection{Analyse syntaxique}}
            \begin{indt}{\subsubsection{Introduction}}
                On s'intéresse à la question suivante : étant donné une grammaire non contextuelle $G = \lr{\Sigma, V, S, A}$ et un mot $u \in \mathcal L(G)$, comment construire une dérivation $S \Rightarrow^* u$ ?

                Cette question est importante car la construction d'une dérivation $S \Rightarrow^* u$ permet de déterminer un arbre d'analyse de $u$ donc d'étudier la structure de mot $u$ vis à vis de la syntaxe définie par la grammaire.
                C'est pour cela que l'on parle d'analyse syntaxique.
            \end{indt}

            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Remarque}}
                Il existe plusieurs familles d'algorithmes d'analyse syntaxique. Certains peuvent s'appliquer à toutes les grammaires, tandis que d'autres, plus efficaces, ne s'appliquent qu'à certaines grammaires.
                Certains de ces algorithmes procèdent en lisant le mot de gauche à droite, une seule fois, à la manière des automates (d'où le lien avec les automates à pile).

                Parmi ces algorithmes, on distingue les analyseurs LL, qui construisent une dérivation à gauche, et les analyseurs LR, qui construisent une dérivation à droite.

                Ces algorithmes sont H.P, mais nous allons les étudier sur des exemples.

                On dit que les analyseurs LL appliquent une \emph{analyse descendante} : on part de l'axiome $S$ et on construit l'arbre d'analyse depuis la racine en se dirigeant vers les feuilles.

                Inversement, les analyseurs LR appliquent une \emph{analyse ascendante} en partant du mot $u$, donc des feuilles de l'arbre d'analyse et en remontant dans l'arbre jusqu'à la racine.
            \end{indt}

            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Exemple : analyse descendante}}
                On considère un langage de balises simplifié sur l'alphabet $\set{a, b, c}$.

                Les symboles $a$ et $b$ désignent les balises ouvrante et fermante, et le symbole $c$ représente le contenu élémentaire placé entre les balises.
                On peut imbriquer et juxtaposer les expressions arbitrairement tant que le résultat est bien parenthésé.

                On considère la grammaire suivante, d'axiome $S$ :
                \[
                    \begin{array}{rcl}
                        S
                        &\rightarrow& TS \ |\ \varepsilon
                        \\
                        T
                        &\rightarrow& aSb \ |\ c
                    \end{array}
                \]

                On procède à l'analyse du mot $aacbbc$ :

                \vspace{6pt}
                
                $-$ Le mot étant non vide, la première règle est nécessairement $S \rightarrow TS$ ;

                $-$ La première lettre du mot étant $a$, on applique la règle $T \rightarrow aSb$ ;

                $-$ Les premières lettres du mot cible et du mot dérivé étant égales, on observe la deuxième lettre : on doit obtenir  un $a$ depuis le symbole $S$ donc on applique de même les règles $S \rightarrow TS$ puis $T \rightarrow aSb$ ;

                $-$ On observe la troisième lettre : on doit obtenir un un $c$ depuis $S$. De même, on enchaîne les règles $S \rightarrow TS$ et $T \rightarrow c$ ;

                $-$ On observe la quatrième lettre : on doit obtenir un $b$ depuis $S$. Ce n'est possible que si le $b$ a déjà été introduit par l'une des règles précédentes donc on applique la règle $S \rightarrow \varepsilon$ ;

                $-$ Les quatrièmes lettres se correspondent et on applique la même analyse aux cinquièmes lettres : on applique $S \rightarrow \varepsilon$ ;

                $-$ On observe les sixièmes lettres : on doit obtenir un $c$ depuis $S$, ce que l'on fait comme avant en appliquant les règles $S \rightarrow TS$ puis $T \rightarrow c$ ;

                $-$ On a lu tous les caractères du mot cible mais le symbole courant du mot dérivé est $S$. On l'élimine en appliquant la règle $S \rightarrow \varepsilon$ ;

                $-$ Il n'y a plus de symbole non terminal : la dérivation est terminée.

                \vspace{12pt}
                
                $\bullet$ Arbre d'analyse, dérivation :

                \begin{center}
                    \begin{tikzpicture}
                        \node (0) at (0, 0) {$S$}
                            child {node [xshift=-30pt] {$T$}
                                child {node {$a$}}
                                child {node {$S$}
                                    child {node [xshift=-20pt] {$T$}
                                        child {node {$a$}}
                                        child {node {$S$}
                                            child {node {$T$}
                                                child {node {$c$}}
                                            }
                                            child {node {$S$}
                                                child {node {$\varepsilon$}}
                                            }
                                        }
                                        child {node {$b$}}
                                    }
                                    child {node [xshift=20pt] {$S$}
                                        child {node {$\varepsilon$}}
                                    }
                                }
                                child {node {$b$}}
                            }
                            child {node [xshift=30pt] {$S$}
                                child {node {$T$}
                                    child {node {$c$}}
                                }
                                child {node {$S$}
                                    child {node {$\varepsilon$}}
                                }
                            }
                        ;

                        \node (1) at (6, -3) {
                            $
                            \begin{array}{rcl}
                                S
                                &\Rightarrow& TS
                                \\
                                &\Rightarrow& aSbS
                                \\
                                &\Rightarrow& aTSbS
                                \\
                                &\Rightarrow& aaSbSbS
                                \\
                                &\Rightarrow& aaTSbSbS
                                \\
                                &\Rightarrow& aacSbSbS
                                \\
                                &\Rightarrow& aacbSbS
                                \\
                                &\Rightarrow& aacbbS
                                \\
                                &\Rightarrow& aacbbTS
                                \\
                                &\Rightarrow& aacbbcS
                                \\
                                &\Rightarrow& aacbbc
                            \end{array}
                            $
                        };
                    \end{tikzpicture}
                \end{center}
            \end{indt}

            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Remarque}}
                $\bullet$ L'exemple précédent est une version simplifiée d'une analyse LL où la connaissance d'un seul symbole du mot cible permet de déterminer la règle à appliquer au symbole non terminal courant.
                On parle d'analyse LL(1) et il est possible de généraliser cette analyse en analyse LL($k$), où la connaissance de $k$ symboles du mot cible sert à déterminer la règle.

                \vspace{6pt}
                
                Exemple : pour la grammaire
                \[
                    \begin{array}{rcl}
                        S & \rightarrow & X + S \ |\ X
                        \\
                        X & \rightarrow & a | b
                    \end{array}
                \]
                la connaissance d'un seul symbole ne suffit pas puisqu'on ne peut alors distinguer $a$ et $a + b$ : les règles $S \rightarrow X + S$ et $S \rightarrow X$ permettent toutes deux d'obtenir $a$ comme premier symbole.

                Ici, la connaissance de des deux premiers symboles suffit à l'analyse : il ne peut y avoir qu'un $+$ en second symbole.
            \end{indt}

            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Application aux langages de programmation}}
                Un cas d'usage important de l'analyse syntaxique est l'analyse de codes sources écrits dans un langage de programmation, mais en pratique, on ne cherche pas à construire l'arbre  d'analyse du code, mais plutôt à capturer l'essence de la structure du programme, dénuée des constructions purement syntaxique, dans une autre structure arborescente appelée arbre de syntaxe abstraite (AST : \textit{Abstract Syntax Tree}).

                L'obtention d'un AST permet par exemple de travailler sur la structure du code pour l'optimisation sans se préoccuper des aspects syntaxiques, avant de regénérer un code source valide.

                L'inconvénient de l'arbre d'analyse, aussi appelé arbre de syntaxe concrète, vis à vis de cet objectif, est qu'il est "pollué" par les éléments syntaxiques tels que des espaces, des parenthèses, $\ldots$

                \vspace{12pt}
                
                Exemple : on considère le langage de programmation appelé $\lambda$-calcul, dont les constructions élémentaires sont les variables, les fonctions anonymes (\texttt{lambda} en Python, \texttt{fun x -> ...} en OCaml), et l'application de fonction.

                Une grammaire pour ce langage est la suivante :
                \[
                    \begin{array}{rcl}
                        S & \rightarrow & V \ |\ \lambda V \cdot S\ |\ S S \ |\ (S)
                        \\
                        V & \rightarrow & xN
                        \\
                        N & \rightarrow & C \ |\ CN
                        \\
                        C & \rightarrow & 0\ |\ \cdots \ |\ 9
                    \end{array}
                \]

                Un AST pour ce langage est décrit par le type suivant :
                \begin{lstlisting}[language=Caml, xleftmargin=80pt]
type term =
    | Var of int
    | Lambda of int * term
    | App of term * term\end{lstlisting}

                \vspace{6pt}
                
                \begin{indt}{Pour construire l'AST associé à un code source, on procède en deux étapes :}
                    $-$ L'analyse lexicale (\textit{lexing}), qui consiste à découper le mot en entrée en une liste d'unités lexicales atomiques, appelées \emph{lexèmes} (\textit{token}).

                    On profite de cette étape pour éliminer certains symboles inutiles à l'analyse de la structure du programme (séparateurs, commentaires, ...).
                    On peut implémenter cette étape à l'aide d'un automate (modifié pour produire des lexèmes en sortie).

                    \vspace{6pt}
                    
                    Exemple : pour le $\lambda$-calcul, les lexèmes sont décrits par le type suivant :
                    \begin{lstlisting}[language=Caml, xleftmargin=100pt]
type token =
    | Var of int
    | LAMBDA
    | DOT
    | LPAR
    | RPAR
    | EOF\end{lstlisting}

                    On peut effectuer l'analyse lexicale à l'aide de l'automate suivant :

                    %\begin{center}
                    %    \begin{tikzpicture}[scale=1.5]
                    %        \node (0) at (0, 0) [state, initial above, initial text={}] {$q_0$};
                    %        \node (LPAR) at (45: 3) [state] {$q_{\rm LPAR}$};
                    %        \node (RPAR) at (0: 3) [state] {$q_{\rm RPAR}$};
                    %        \node (DOT) at (-45: 3) [state] {$q_{\rm DOT}$};
                    %        \node (l) at (-80: 3) [state] {$q_l$};
                    %        \node (LBD) at (-120: 3) [state] {$q_{\rm LBD}$};
                    %        \node (lb) at (-100: 4) [state] {$q_{\rm lb}$};
                    %        \node (x) at (-160: 3) [state] {$q_x$};
                    %        \node (VAR) at (160: 3) [state] {$q_{\rm VAR}$};
                    %        \node (EOF) at (130: 3) [state, accepting] {$q_{\rm EOF}$};

                    %        \draw[->] (0) to [out=55, in=-145] node [above left] {$($} (LPAR);
                    %        \draw[->] (LPAR) to [out=-125, in=35] node [below, rotate=45] {\tiny{OUT: LPAR}} (0);

                    %        \draw[->] (0) to [out=10, in=170] node [above] {$)$} (RPAR);
                    %        \draw[->] (RPAR) to [out=-170, in=-10] node [below] {\tiny{OUT: RPAR}} (0);

                    %        \draw[->] (0) to [out=-35, in=125] node [above right] {$\cdot$} (DOT);
                    %        \draw[->] (DOT) to [out=145, in=-55] node [below, rotate=-45] {\tiny{OUT: DOT}} (0);

                    %        \draw[->] (0) to node [right] {$l$} (l);
                    %        \draw[->] (l) to node [below right] {$b$} (lb);
                    %        \draw[->] (lb) to node [below left] {$d$} (LBD);
                    %        \draw[->] (LBD) to node [above, rotate=60] {\tiny{OUT: LAMBDA}} (0);

                    %        \draw[->] (0) to node [above left] {$x$} (x);
                    %    \end{tikzpicture}
                    %\end{center}


                    \begin{center}
                        \begin{tikzpicture}[scale=1.5]
                            \node (0) at (0, 0) [state] {$q_0$};
                            \node (LPAR) at (40: 3) [state] {$q_{\rm LPAR}$};
                            \node (RPAR) at (0: 3) [state] {$q_{\rm RPAR}$};
                            \node (DOT) at (320: 3) [state] {$q_{\rm DOT}$};
                            \node (l) at (280: 3) [state] {$q_l$};
                            \node (LBD) at (200: 3) [state] {$q_{\rm LBD}$};
                            \node (lb) at (240: 3) [state] {$q_{\rm lb}$};
                            \node (x) at (160: 3) [state] {$q_x$};
                            \node (VAR) at (120: 3) [state] {$q_{\rm VAR}$};
                            \node (EOF) at (80: 3) [state, accepting] {$q_{\rm EOF}$};

                            %Initial arrow for the initial state.
                            \draw[->] (240: .9) to (0);

                            \draw[->] (0) to [out=50, in=-150] node [above left] {\small{$($}} (LPAR);
                            \draw[->] (LPAR) to [out=-130, in=30] node [below, rotate=40] {\tiny{OUT: LPAR}} (0);

                            \draw[->] (0) to [out=10, in=170] node [above] {\small{$)$}} (RPAR);
                            \draw[->] (RPAR) to [out=-170, in=-10] node [below] {\tiny{OUT: RPAR}} (0);

                            \draw[->] (0) to [out=-30, in=130] node [above right] {$\cdot$} (DOT);
                            \draw[->] (DOT) to [out=150, in=-50] node [below, rotate=-40] {\tiny{OUT: DOT}} (0);

                            \draw[->] (0) to node [right] {$l$} (l);
                            \draw[->] (l) to node [below right] {$b$} (lb);
                            \draw[->] (lb) to node [below left] {$d$} (LBD);
                            \draw[->] (LBD) to node [above, rotate=20] {\tiny{OUT: LAMBDA}} (0);

                            \draw[->] (0) to node [above right] {$x$} (x);
                            \draw[->] (x) to node [above left] {$0 - 9$} (VAR);
                            \draw[->] (VAR) to node [below, rotate=-60] {\tiny{OUT: VAR}} (0);

                            \draw[->] (0) to node [above, rotate=80] {\tiny{OUT: EOF}} (EOF);
                        \end{tikzpicture}
                    \end{center}

                    On doit se souvenir des chiffres lus : on sort du cadre des automates.

                    \vspace{12pt}
                    
                    $-$ L'analyse syntaxique (\textit{parsing}) : on construit l'AST de la manière suivante : on considère l'ensemble des lexèmes comme l'ensemble des symboles terminaux de la grammaire du langage, et on procède à l'analyse syntaxique du "mot" représenté par la liste de lexèmes obtenue par l'analyse lexicale.
                    On écrit un programme traduisant chaque règle de la grammaire en une étape de construction d'un AST : une dérivation complète permet d'obtenir l'AST en sortie.

                    \vspace{6pt}
                    
                    Exemple : pour le $\lambda$-calcul, on considère la grammaire suivante :
                    \[
                        \begin{array}{rcl}
                            S & \rightarrow & T\ \underbar{\rm{EOF}}
                            \\
                            T & \rightarrow & V\ |\ \underbar{\rm LPAR}\ \underbar{\rm LAMBDA}\ V\ \underbar{\rm DOT}\ T\ \underbar{\rm RPAR}\ |\ \underbar{\rm LPAR}\ T\ T\ \underbar{\rm RPAR}
                            \\
                            V & \rightarrow & \underline{\rm VAR}\ n
                        \end{array}
                    \]

                    (On impose l'usage des parenthèses pour simplifier l'analyse).

                    On peut implémenter l'analyse syntaxique de la manière suivante : on écrit des fonctions mutuellement récursives qui prennent en argument une liste de lexèmes correspondant  à l'une des règles de la grammaire.
                    On associe une fonction à chaque symbole non terminal, et cette fonction doit construire une partie de l'AST et renvoyer les lexèmes restants.

                    \begin{lstlisting}[language=Caml, xleftmargin=100pt]
let rec parseS (l : token list) : term =
    match parseT l with
    | t, [EOF] -> t
    | _ -> failwith "Syntax error"

and parseT (l : token list) : term * token list =
    match l with
    | LPAR::LAMBDA::l ->
        begin match parseV l with
        | Var n, l ->
            begin match parseT l with
            | t, RPAR::q -> Lambda(n, t), q
            | _ -> failwith "Syntax error"
            end
        | _ -> failwith "Impossible"
        end
    | LPAR::l ->
        let t1, l = parseT l in
        begin match parseT l with
              | t2, RPAR::q -> App(t1, t2)
              | _ -> failwith "Syntax error"
        end
    | _ -> parseV l

and parseV (l : token list) : term * token list =
    match l with
    | VAR n :: q -> Var n, q
    | _ -> failwith "Syntax error"\end{lstlisting}
                \end{indt}
            \end{indt}
        \end{indt}
    \end{indt}
    
\end{document}
%--------------------------------------------End
