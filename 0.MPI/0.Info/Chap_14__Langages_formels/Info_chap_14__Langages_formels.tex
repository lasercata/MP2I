\documentclass[a4paper, 12pt, twoside]{article}


%------------------------------------------------------------------------
%
% Author                :   Lasercata
% Last modification     :   2022.10.13
%
%------------------------------------------------------------------------


%------ini
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[french]{babel}
%\usepackage[english]{babel}


%------geometry
\usepackage[textheight=700pt, textwidth=500pt]{geometry}


%------color
\usepackage{xcolor}
\definecolor{ff4500}{HTML}{ff4500}
\definecolor{00f}{HTML}{0000ff}
\definecolor{0ff}{HTML}{00ffff}
\definecolor{656565}{HTML}{656565}

%\renewcommand{\emph}{\textcolor{ff4500}}
%\renewcommand{\em}{\color{ff4500}}

\newcommand{\Emph}{\textcolor{ff4500}}

\newcommand{\strong}[1]{\textcolor{ff4500}{\bf #1}}
\newcommand{\st}{\color{ff4500}\bf}


%------Code highlighting
%---listings
\usepackage{listings}

\definecolor{cbg}{HTML}{272822}
\definecolor{cfg}{HTML}{ececec}
\definecolor{ccomment}{HTML}{686c58}
\definecolor{ckw}{HTML}{f92672}
\definecolor{cstring}{HTML}{e6db72}
\definecolor{cstringlight}{HTML}{98980f}
\definecolor{lightwhite}{HTML}{fafafa}

\lstdefinestyle{DarkCodeStyle}{
    backgroundcolor=\color{cbg},
    commentstyle=\itshape\color{ccomment},
    keywordstyle=\color{ckw},
    numberstyle=\tiny\color{cbg},
    stringstyle=\color{cstring},
    basicstyle=\ttfamily\footnotesize\color{cfg},
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    keepspaces=true,
    numbers=left,
    numbersep=5pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=4,
    xleftmargin=\leftskip
}

\lstdefinestyle{LightCodeStyle}{
    backgroundcolor=\color{lightwhite},
    commentstyle=\itshape\color{ccomment},
    keywordstyle=\color{ckw},
    numberstyle=\tiny\color{cbg},
    stringstyle=\color{cstringlight},
    basicstyle=\ttfamily\footnotesize\color{cbg},
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    keepspaces=true,
    numbers=left,
    numbersep=10pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=4,
    frame=L,
    xleftmargin=\leftskip
}

%\lstset{style=DarkCodeStyle}
\lstset{style=LightCodeStyle}
%Usage : \begin{lstlisting}[language=Caml, xleftmargin=xpt] ... \end{lstlisting}


%---Algorithm
\usepackage[linesnumbered,ruled,vlined]{algorithm2e}
\SetKwInput{KwInput}{Input}
\SetKwInput{KwOutput}{Output}

\SetKwProg{Fn}{Function}{:}{}
\SetKw{KwPrint}{Print}

\newcommand\commfont[1]{\textit{\texttt{\textcolor{656565}{#1}}}}
\SetCommentSty{commfont}
\SetProgSty{texttt}
\SetArgSty{textnormal}
\SetFuncArgSty{textnormal}
%\SetProgArgSty{texttt}

\newenvironment{indalgo}[2][H]{
    \begin{minipage}{\linewidth-\leftskip-5pt}
        \begin{algorithm}[#1]
            \caption{#2}
}
{
        \end{algorithm}
    \end{minipage}
}


%---tcolorbox
\usepackage[many]{tcolorbox}
\DeclareTColorBox{emphBox}{O{black}O{lightwhite}}{
    breakable,
    outer arc=0pt,
    arc=0pt,
    top=0pt,
    toprule=-.5pt,
    right=0pt,
    rightrule=-.5pt,
    bottom=0pt,
    bottomrule=-.5pt,
    colframe=#1,
    colback=#2,
    enlarge left by=10pt,
    width=\linewidth-\leftskip-10pt,
}


%-------make the table of content clickable
\usepackage{hyperref}
\hypersetup{
    colorlinks,
    citecolor=black,
    filecolor=black,
    linkcolor=black,
    urlcolor=black
}


%------pictures
\usepackage{graphicx}
%\usepackage{wrapfig}

\usepackage{tikz}
%\usetikzlibrary{babel}             %Uncomment this to use circuitikz
%\usetikzlibrary{shapes.geometric}  % To draw triangles in trees
%\usepackage{circuitikz}            %Electrical circuits drawing
\usetikzlibrary{automata}


%------tabular
%\usepackage{color}
%\usepackage{colortbl}
%\usepackage{multirow}


%------Physics
%---Packages
%\usepackage[version=4]{mhchem} %$\ce{NO4^2-}$

%---Commands
\newcommand{\link}[2]{\mathrm{#1} \! - \! \mathrm{#2}}
\newcommand{\pt}[1]{\cdot 10^{#1}} % Power of ten
\newcommand{\dt}[2][t]{\dfrac{\mathrm d #2}{\mathrm d #1}} % Derivative


%------math
%---Packages
%\usepackage{textcomp}
%\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{mathtools} % For abs
\usepackage{stmaryrd} %for \llbracket and \rrbracket
\usepackage{mathrsfs} %for \mathscr{x} (different from \mathcal{x})

%---Commands
%-Sets
\newcommand{\N}{\mathbb{N}} %set N
\newcommand{\Z}{\mathbb{Z}} %set Z
\newcommand{\Q}{\mathbb{Q}} %set Q
\newcommand{\R}{\mathbb{R}} %set R
\newcommand{\C}{\mathbb{C}} %set C
\newcommand{\U}{\mathbb{U}} %set U
\newcommand{\seg}[2]{\left[ #1\ ;\ #2 \right]}
\newcommand{\nset}[2]{\left\llbracket #1\ ;\ #2 \right\rrbracket}

%-Exponantial / complexs
\newcommand{\e}{\mathrm{e}}
\newcommand{\cj}[1]{\overline{#1}} %overline for the conjugate.

%-Vectors
\newcommand{\vect}{\overrightarrow}
\newcommand{\veco}[3]{\displaystyle \vect{#1}\binom{#2}{#3}} %vector + coord

%-Limits
\newcommand{\lm}[2][{}]{\lim\limits_{\substack{#2 \\ #1}}} %$\lm{x \to a} f$ or $\lm[x < a]{x \to a} f$
\newcommand{\Lm}[3][{}]{\lm[#1]{#2} \left( #3 \right)} %$\Lm{x \to a}{f}$ or $\Lm[x < a]{x \to a}{f}$
\newcommand{\tendsto}[1]{\xrightarrow[#1]{}}

%-Integral
\newcommand{\dint}[4][x]{\displaystyle \int_{#2}^{#3} #4 \mathrm{d} #1} %$\dint{a}{b}{f(x)}$ or $\dint[t]{a}{b}{f(t)}$

%-left right
\newcommand{\lr}[1]{\left( #1 \right)}
\newcommand{\lrb}[1]{\left[ #1 \right]}
\newcommand{\lrbb}[1]{\left\llbracket #1 \right\rrbracket}
\newcommand{\set}[1]{\left\{ #1 \right\}}
\newcommand{\abs}[1]{\left\lvert #1 \right\rvert}
\newcommand{\ceil}[1]{\left\lceil #1 \right\rceil}
\newcommand{\floor}[1]{\left\lfloor #1 \right\rfloor}
\newcommand{\lrangle}[1]{\left\langle #1 \right\rangle}

%-Others
\newcommand{\para}{\ /\!/\ } %//
\newcommand{\ssi}{\ \Leftrightarrow \ }
\newcommand{\eqsys}[2]{\begin{cases} #1 \\ #2 \end{cases}}

\newcommand{\med}[2]{\mathrm{med} \left[ #1\ ;\ #2 \right]}  %$\med{A}{B} -> med[A ; B]$
\newcommand{\Circ}[2]{\mathscr{C}_{#1, #2}}

\renewcommand{\le}{\leqslant}
\renewcommand{\ge}{\geqslant}

\newcommand{\oboxed}[1]{\textcolor{ff4500}{\boxed{\textcolor{black}{#1}}}} %orange boxed


%------commands
%---to quote
\newcommand{\simplecit}[1]{\guillemotleft$\;$#1$\;$\guillemotright}
\newcommand{\cit}[1]{\simplecit{\textcolor{656565}{#1}}}
\newcommand{\quo}[1]{\cit{\it #1}}

%---to indent
\newcommand{\ind}[1][20pt]{\advance\leftskip + #1}
\newcommand{\deind}[1][20pt]{\advance\leftskip - #1}

%---to indent a text
\newcommand{\indented}[2][20pt]{\par \ind[#1] #2 \par \deind[#1]}
\newenvironment{indt}[2][20pt]{#2 \par \ind[#1]}{\par \deind} %Titled indented env

%---title
\newcommand{\thetitle}[2]{\begin{center}\textbf{{\LARGE \underline{\Emph{#1} :}} {\Large #2}}\end{center}}

%---Maths environments
%-Proofs
\newenvironment{proof}[1][{Démonstration :}]{\begin{indt}{$\square$ #1}}{$\blacksquare$ \end{indt}}

%-Maths parts (proposition, definition, ...)
\newenvironment{mathpart}[1]{\begin{indt}{\boxed{\text{\textbf{#1}}}}}{\end{indt}}
\newenvironment{mathbox}[1]{\boxed{\text{\textbf{#1}}}\begin{emphBox}}{\end{emphBox}}
\newenvironment{mathul}[1]{\begin{indt}{\underline{\textbf{#1}}}}{\end{indt}}

\newenvironment{theo}{\begin{mathpart}{Théorème}}{\end{mathpart}}
\newenvironment{Theo}{\begin{mathbox}{Théorème}}{\end{mathbox}}

\newenvironment{prop}{\begin{mathpart}{Proposition}}{\end{mathpart}}
\newenvironment{Prop}{\begin{mathbox}{Proposition}}{\end{mathbox}}
\newenvironment{props}{\begin{mathpart}{Propriétés}}{\end{mathpart}}

\newenvironment{defi}{\begin{mathpart}{Définition}}{\end{mathpart}}
\newenvironment{meth}{\begin{mathpart}{Méthode}}{\end{mathpart}}

\newenvironment{Rq}{\begin{mathul}{Remarque :}}{\end{mathul}}
\newenvironment{Rqs}{\begin{mathul}{Remarques :}}{\end{mathul}}

\newenvironment{Ex}{\begin{mathul}{Exemple :}}{\end{mathul}}
\newenvironment{Exs}{\begin{mathul}{Exemples :}}{\end{mathul}}


%------Sections
% To change section numbering :
% \renewcommand\thesection{\Roman{section}}
% \renewcommand\thesubsection{\arabic{subsection})}
% \renewcommand\thesubsubsection{\textit \alph{subsubsection})}

% To start numbering from 0
% \setcounter{section}{-1}


%------page style
\usepackage{fancyhdr}
\usepackage{lastpage}

\setlength{\headheight}{18pt}
\setlength{\footskip}{50pt}

\pagestyle{fancy}
\fancyhf{}
\fancyhead[LE, RO]{\textit{\textcolor{black}{\today}}}
\fancyhead[RE, LO]{\large{\textsl{\Emph{\texttt{\jobname}}}}}

\fancyfoot[RO, LE]{\textit{\texttt{\textcolor{black}{Page \thepage /}\pageref{LastPage}}}}
\fancyfoot[LO, RE]{\includegraphics[scale=0.12]{/home/lasercata/Pictures/1.images_profil/logo/mieux/lasercata_logo_fly_fond_blanc.png}}


%------init lengths
\setlength{\parindent}{0pt} %To avoid using \noindent everywhere.
\setlength{\parskip}{3pt}

%---------Specific to this file
\newcommand{\Reg}{\mathsf{Reg}}
\newcommand{\Regexp}{\mathsf{Regexp}}
\newcommand{\Rec}[1]{\mathsf{Rec}\!\lr{#1}}


%---------------------------------Begin Document
\begin{document}
    
    \thetitle{Chapitre 14}{Langages formels}
    
    \tableofcontents
    \newpage
    
    \begin{indt}{\section{Langages réguliers}}
        \begin{indt}{\subsection{Motivation}}
            \begin{indt}{\subsubsection{introduction}}
                \label{1.1.1}

                On a souvent besoin de mettre en place une analyse de texte, même dans le cadre d'applications qui ne relèvent pas uniquement du traitement de texte.

                \begin{indt}{Par exemple :}
                    $\bullet$ La recherche d'un mot dans un texte (\textit{cf} chap 11) ;

                    $\bullet$ analyser un document structuré afin de traiter de manière appropriée son contenu (exemple : compiler un programme, récupérer des données sérialisées (\textit{cf} chap 11) dans un format particulier (ex : données brutes en CSV, fichiers de configuration en JSON ou en XML)) ;

                    $\bullet$ Reconnaître un encodage et le déchiffrer (exemple : QR-code).
                \end{indt}

                \vspace{12pt}
                
                Quelle que soit l'application, on a besoin d'un formalisme pour décrire la structure du texte et d'algorithmes efficaces capables d'analyser cette structure et d'extraire les données associées.
            \end{indt}

            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Exemple}}
                \label{1.1.2}

                \'Etant donné un fichier binaire, déterminer s'il contient la représentation binaire d'un entier non signé multiple de 3.

                \vspace{6pt}
                
                $\bullet$ Remarque : on n'utilise pas les types d'entiers natifs de C ou OCaml car ils ont une taille fixée qui peut être dépassée par le fichier.

                \vspace{6pt}
                
                Idée : on lit les bits un à un en effectuant les opérations associées modulo 3, en remarquant que
                \[
                    \begin{cases}
                        \lrangle{x 0}_2 = 2\lrangle x _2
                        \\
                        \lrangle{x 1}_2 = 2\lrangle x _2 + 1
                    \end{cases}
                \]

                On utilise cette table :

                \begin{center}
                    \begin{tabular}{|l|c|c|c|}
                        \hline
                        $\lrangle x _2 \mod 3$ & 0 & 1 & 2
                        \\
                        \hline
                        $\lrangle{x 0}_2 \mod 3$ & 0 & 2 & 1
                        \\
                        \hline
                        $\lrangle{x 1}_2 \mod 3$ & 1 & 0 & 2
                        \\
                        \hline
                    \end{tabular}
                \end{center}

                $\bullet$ Algorithme :

                \begin{indalgo}{}
                    $x \gets 0$\;

                    \For{chaque bit $b$ pris dans l'odre}{
                        \If{$b = 0$}{
                            $x \gets 2x \mod 3$\;
                        }
                        \Else{
                            $x \gets 2x + 1 \mod 3$
                        }
                    }

                    \KwRet $x = 0$\;
                \end{indalgo}

                \vspace{12pt}
                
                $\bullet$ Représentation graphique : $x$ ne peut prendre que trois valeurs différentes, appelées états, et on peut représenter les changements de valeur de $x$ dans un graphe orienté dont les sommets sont les états, et les arcs sont étiquetés par le bit qui produit le changement de valeur de l'état source vers l'état cible.

                \begin{center}
                    \begin{tikzpicture}[scale=1.3]
                        \node (0) at (0, 0) [state, initial, initial text={}, accepting] {$0$};
                        \node (1) at (2, 0) [state] {$1$};
                        \node (2) at (4, 0) [state] {$2$};

                        \draw[->] (0) to [out=-20, in=-160] node [below] {$1$} (1);
                        \draw[->] (1) to [out=160, in=20] node [above] {$1$} (0);
                        \draw[->] (1) to [out=-20, in=-160] node [below] {$0$} (2);
                        \draw[->] (2) to [out=160, in=20] node [above] {$0$} (1);

                        \draw[->] (0) to [out=60, in=120, looseness=3] node [above] {$0$} (0);
                        \draw[->] (2) to [out=60, in=120, looseness=3] node [above] {$1$} (2);
                    \end{tikzpicture}
                \end{center}

                On distingue de plus la valeur initiale par une flèche, et la valeur finale atteinte par un double cercle.

                Cette représentation correspond au formalisme des \emph{automates}, que nous verrons en \ref{2} (page \pageref{2}).
            \end{indt}
        \end{indt}

        \vspace{12pt}
        
        \begin{indt}{\subsection{Langages}}
            \begin{indt}{\subsubsection{Définition (\textit{alphabet})}}
                Un \emph{alphabet} est un ensemble fini non vide, dont les éléments sont appelés lettres ou symboles.

                Notation usuelle : $\Sigma$.
            \end{indt}

            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Définition (\textit{mot})}}
                Soit $\Sigma$ un alphabet.

                Un \emph{mot} sur $\Sigma$ est une suite finie de symboles $u = u_1 \cdots u_n$, potentiellement vide.

                Si $n = 0$, on note $u = \varepsilon$.

                On note $\abs u = n$ la \emph{longueur} du mot.
            \end{indt}

            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Définition (\textit{concaténation})}}
                Soit $\Sigma$ un alphabet, et $u, v$ deux mots sur $\Sigma$.

                On appelle \emph{concaténation} de $u$ et $v$ le mot
                \[
                    uv =
                    \begin{cases}
                        v & \text{si}\ u = \varepsilon
                        \\
                        u & \text{si}\ v = \varepsilon
                        \\
                        u_1 \cdots u_n v_1 \cdots v_p
                        & \text{si}
                        \begin{cases}
                            u = u_1 \cdots u_n
                            \\
                            v = v_1 \cdots v_p
                        \end{cases}
                    \end{cases}
                \]

                \boxed{\rm Exo}

                $\bullet$ $\abs{uv} = \abs u + \abs v$

                $\bullet$ La concaténation est une loi de composition interne associative et d'élément neutre $\varepsilon$ sur l'ensemble des mots sur $\Sigma$.
            \end{indt}

            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Définition (\textit{préfixe, suffixe, facteur, sous-mot})}}
                Soit $\Sigma$ un alphabet, et $u, v$ deux mots sur $\Sigma$

                \vspace{6pt}
                
                $\bullet$ $v$ est un \emph{préfixe} de $u$ ssi $\exists w$ mot tel que $u = vw$

                $\bullet$ $v$ est un \emph{suffixe} de $u$ ssi $\exists w$ mot tel que $u = wv$

                $\bullet$ $v$ est un \emph{facteur} de $u$ ssi $\exists x, y$ mots tels que $u = xvy$

                $\bullet$ $v$ est un \emph{sous-mot} de $u$ ssi $\exists i_1 < i_2 < \cdots < i_k$ tels que si $u = u_1 \cdots u_n$, alors $v = u_{i_1} \cdots u_{i_k}$

                \vspace{12pt}
                
                Exemple : si $u = abc$, $v = ac$ est un sous-mot de $u$, mais pas un facteur.
            \end{indt}

            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Langages}}
                $\bullet$ Définition (\textit{langage}) : un \emph{langage} sur un alphabet $\Sigma$ est un ensemble de mots sur $\Sigma$.

                \vspace{12pt}
                
                \begin{indt}{$\bullet$ Exemples :}
                    $-$ l'ensemble de tous les mots, noté $\Sigma^*$ (\textit{cf} \ref{1.3}, page \pageref{1.3}) ;

                    $-$ l'ensemble des écritures binaires de multiples des 3 ($\Sigma = \set{0, 1}$) ;

                    $-$ $\Sigma$ (si on voit les lettres comme des mots de longueur 1) ;

                    $-$ l'ensemble des code sources OCaml de programmes qui ne terminent pas.
                \end{indt}

                \vspace{12pt}
                
                $\bullet$ Problème : étant donné un langage $L$ sur un alphabet $\Sigma$, on veut disposer d'une représentation formelle de $L$ pour pouvoir étudier la question suivante :
                étant donné un mot $u$, a-t-on $u \in L$ ?

                \vspace{6pt}
                
                C'est une question importante car souvent, comme dans les exemples en \ref{1.1.1} (page \pageref{1.1.1}), il faut pouvoir vérifier la structure d'un élément avant d'en extraire des données.

                Malheureusement, on ne peut pas toujours répondre algorithmiquement à cette question. (\textit{cf} chap 16 et la notion de décidabilité et le problème de l'arêt), mais on peut y répondre pour une classe restreinte de langages.
            \end{indt}
        \end{indt}

        \vspace{12pt}
        
        \begin{indt}{\subsection{Langages réguliers}}
            \label{1.3}

            \begin{indt}{\subsubsection{Opérations sur les langages}}
                Outre les opérations ensemblistes usuelles (intersection, union, complémentaire), on définit certaines opérations plus spécifiques aux langages.

                \vspace{12pt}
                
                $\bullet$ \textbf{Concaténation} : Soit $\Sigma$ un alphabet, et $L, L'$ deux langages sur $\Sigma$.

                La concaténation de $L$ et $L'$ est le langage
                \[
                    LL' = \set{uv\ |\ (u, v) \in L \times L'}
                \]

                Remarque : $L \varnothing = \varnothing L = \varnothing$.

                \vspace{12pt}
                
                $\bullet$ \textbf{Puissance} : Soit $\Sigma$ un alphabet, $L$ un langage sur $\Sigma$, et $n \in \N$.

                La puissance $n$-ème de $L$ est le langage
                \[
                    L^n =
                    \begin{cases}
                        \set \varepsilon
                        & \text{si}\ n = 0
                        \\
                        LL^{n - 1}
                        & \text{si}\ n > 0
                    \end{cases}
                \]

                \vspace{12pt}
                
                $\bullet$ \textbf{\'Etoile de \textsc{Kleene}} : Soit $\Sigma$ un alphabet, et $L$ un langage sur $\Sigma$.

                L'\emph{étoile de \textsc{Kleene}} de $L$ est le langage
                \[
                    L^* = \bigcup_{n \in \N} L^n
                \]

                \vspace{12pt}
                
                \begin{indt}{$\bullet$ Remarques :}
                    $-$ $\Sigma^*$ est bien l'ensemble de tous les mots : tout mot $u = u_1 \cdots u_n$ est la caractérisation de ses lettres ($\forall i \in \nset{1}{n},\ u_i \in \Sigma$, donc $u = u_1 \cdots u_n \in \Sigma^n \subseteq \Sigma^*$).

                    $-$ On peut aussi définir la puissance $n$-ème d'un mot :
                    \[
                        u^n =
                        \begin{cases}
                            \varepsilon
                            & \text{si}\ n = 0
                            \\
                            u u^{n - 1}
                            & \text{si}\ n > 0
                        \end{cases}
                    \]

                    Attention : ne pas confondre $L^n$ et $\set{u^n\ |\ u \in L}$.

                    $-$ On note aussi
                    \[
                        L^+ = \bigcup_{n \in \N^*} L^n
                    \]

                    \vspace{6pt}
                    
                    \boxed{\rm Exo} $L^+ = L^* \ssi \varepsilon \in L$.
                \end{indt}
            \end{indt}

            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Théorème (\textit{Lemme d'\textsc{Arden}}) (H.P)}}
                \begin{emphBox}
                    Soit $\Sigma$ un alphabet, et $K, L$ deux langages sur $\Sigma$.

                    (1) $K^* L$ est le minimum (pour l'ordre de l'inclusion) des solutions de l'équation
                    \[
                        X = K X \cup L
                    \]
                    d'inconnue un langage $X$.

                    \vspace{6pt}
                    
                    (2) Si $\varepsilon \notin K$, alors $K^* L$ est l'unique solution.
                \end{emphBox}

                \vspace{12pt}
                
                \begin{proof}
                    (1) On a :
                    \[
                        \begin{array}{rcl}
                            K(K^*L)\cup L
                            &=& \displaystyle K\lr{\bigcup_{n \in \N} K^n L} \cup L
                            \vspace{3pt}
                            \\
                            &=& K^+ L \cup K^0 L
                            \vspace{3pt}
                            \\
                            &=&K^* L
                        \end{array}
                    \]
                    Donc $K^*L$ est une solution.

                    Puis soit $X$ une solution. Montrons que $K^* L \subset X$.

                    Soit $u \in K^* L$. Par définition,
                    \[
                        \exists n \in \N,\ \exists k_1, \ldots, k_n \in K,\ \exists l \in L\ |\
                        u = k_1 \cdots k_n l
                    \]

                    On montre par récurrence sur $n$ que $u \in X$ :

                    $\bullet$ $n = 0$ :
                    $u \in L \subset KX\cup L = X$, donc $u \in X$.

                    \vspace{6pt}
                    
                    $\bullet$ Héréditée :
                    si $\forall k_1 \cdots k_n \in K,\ \forall l \in L,\ k_1 \cdots k_n l \in X$, considérons $u = k_1 \cdots k_{n + 1} l$, avec $k_1 \cdots k_{n + 1} \in K$ et $l \in L$.

                    $u = k_1(\underbrace{k_2 \cdots k_{n + 1}l}_{\in X\ \text{par H.R}}) \in KX \subseteq KX \cup L = X$, donc $u \in X$.

                    Finalement, $K^* L \subset X$, et $K^*L$ est bien le minimum des solutions.

                    \vspace{12pt}
                    
                    (2) On suppose $\varepsilon \notin K$. Soit $X$ une solution.

                    On sait par (1) que $K^*L \subseteq X$.

                    Il suffit de montrer que $X \subseteq K^* L$.

                    Soit $u \in X$ dont on note $n$ la longueur.

                    On montre par récurrence que
                    \[
                        \forall k \in \nset 0 n,\ X = \bigcup_{j = 0}^k K^j L \cup K^{k + 1} X
                    \]

                    \vspace{6pt}
                    
                    $\bullet$ $k = 0$ :
                    \[
                        \bigcup_{j = 0}^0 K^j L \cup K^{0 + 1} X = L \cup KX = X
                    \]

                    $\bullet$ Héréditée : Soit $k \in \nset 0 {n - 1} \ |\ X = \displaystyle \bigcup_{j = 0}^k K^j L \cup K^{k + 1} X$

                    \[
                        \begin{array}{rcl}
                            X
                            &=& KX \cup L
                            \\
                            &=& \displaystyle K\lr{\bigcup_{j = 0}^k K^j L \cup K^{k + 1}L} \cup L
                            \\
                            &=& \displaystyle \bigcup_{j = 0}^k K^{j + 1} L \cup K^{k + 1} L \cup L
                            \vspace{3pt}
                            \\
                            &=& \displaystyle \bigcup_{j = 0}^{k + 1} K^J L \cup K^{k + 2} L
                        \end{array}
                    \]

                    En particulier,
                    \[
                        X = \bigcup_{j = 0}^n K^J L \cup K^{n + 1} X
                    \]

                    Or $\forall v \in k^{n + 1}X,\ \abs v \ge n + 1$

                    En effet, $\exists k_1 \cdots k_{n + 1} \in K,\ \exists x \in X\ |\ v = k_1 \cdots k_{n + 1} x$.

                    Or $\forall i \in \nset 1 {n + 1}, k_i \neq \varepsilon$, donc $\abs{k_i} \ge 1$, donc
                    \[
                        \abs v = \sum_{i = 1}^{n + 1} \abs{k_i} + \abs x
                        \ge n + 1 + \abs x \ge n + 1
                    \]

                    Donc, comme $\abs u = n < n + 1$,
                    \[
                        \bigcup_{j = 0}^n K^j L \subseteq \cup_{j \in \N} K^J L = K^*L
                    \]
                    Donc $u \in K^* L$, et $X \subseteq K^*L$
                \end{proof}

                \vspace{12pt}
                
                $\bullet$ Contre-exemple au point (2) si $\varepsilon \in K$ : on prend $K = \set \varepsilon$, et $L = \set a$.
                $K^*L = \set a = L$, et tout $X\ |\ a \in X$ est solution ($KX\cup L = X \cup \set a$). Par exemple : $\set a = K^*L$ ou $\set{a, aa}, \set{a, aa, aaa}$.
            \end{indt}

            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Langage régulier}}
                La classe des \emph{langages réguliers}, aussi appelés \emph{langages rationnels}, est la famille des langages que l'on peut construire à partir de langages de base ($\varnothing$, $\set \varepsilon$, $\set a\ \forall a \in \Sigma$) et des opérations dites \emph{régulières} : union, concaténation et étoile de \textsc{Kleene}. L'ensemble $\Reg(\Sigma)$ des langages réguliers sur l'alphabet $\Sigma$ est définit inductivement par :
                \[
                    \dfrac{}{\varnothing \in \Reg(\Sigma)}
                    \qquad
                    \dfrac{a \in \Sigma}{\set a \in \Reg(\Sigma)}
                    \qquad
                    \dfrac{L \in \Reg(\Sigma)}{L^* \in \Reg(\Sigma)}
                \]

                \[
                    \dfrac{L \in \Reg(\Sigma)\ L' \in \Reg(\Sigma)}{L \cup L' \in \Reg(\Sigma)}
                    \qquad
                    \dfrac{L \in \Reg(\Sigma)\ L' \in \Reg(\Sigma)}{LL' \in \Reg(\Sigma)}
                \]

                \vspace{12pt}
                
                $\bullet$ Remarque : $\set \varepsilon \in \Reg(\Sigma)$ car $\set \varepsilon = \varnothing^0 = \displaystyle \bigcup_{n \in \N} \varnothing^n = \varnothing^*$

                $\Sigma \in \Reg(\Sigma)$ car, en notant $\Sigma = \set{a_1 \cdots a_n}$, on a :
                \[
                    \Sigma = \bigcup_{k = 1}^n \set{a_k}
                \]
                Donc une récurrence sur $n = \abs \Sigma$ conclut.

                De même, tout langage fini est régulier (\boxed{\rm Exo}).

                \vspace{6pt}
                
                Il manque encore un formalisme pour décrire les langages réguliers.
            \end{indt}

            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Expressions régulières}}
                Soit $\Sigma$ un alphabet, et $S = \set{(, ), |, *, \varnothing, \varepsilon}$ un ensemble de symboles supposé disjoint de $\Sigma$.

                L'ensemble $\Regexp(\Sigma)$ des \emph{expressions régulières} sur $\Sigma$, aussi appelées \emph{expressions rationnelles}, est l'ensemble des mots sur $\Sigma \cup S$ défini inductivement par
                \[
                    \dfrac{}{\varnothing \in \Regexp(\Sigma)}
                    \qquad
                    \dfrac{}{\Sigma \in \Regexp(\Sigma)}
                    \qquad
                    \dfrac{a \in \Sigma}{a \in \Regexp(\Sigma)}
                \]
                \[
                    \dfrac{e \in \Regexp(\Sigma)\ f \in \Regexp(\Sigma)}{(e | f) \in \Regexp(\Sigma)}
                    \qquad
                    \dfrac{e \in \Regexp(\Sigma)\ f \in \Regexp(\Sigma)}{(ef) \in \Regexp(\Sigma)}
                \]
                \[
                    \dfrac{e \in \Regexp(\Sigma)}{(e^*) \in \Regexp(\Sigma)}
                \]

                Remarques :

                $\bullet$ $|$ est parfois noté $+$.

                $\bullet$ On se passe de certaines parenthèses avec les règles de priorité :
                \[
                    * > \text{concaténation} > |
                \]

                Par exemple, $\lr{\lr{a\lr{b^*}} | b}$ s'écrit $a b^* | b$.
            \end{indt}

            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Définition (\textit{langage dénoté par une expression régulière})}}
                Soit $\Sigma$ un alphabet.

                Le \emph{langage dénoté par une expression régulière} $e \in \Regexp(\Sigma)$ est le langage $L(e)$ défini inductivement par :
                \[
                    L(\varnothing) = \varnothing
                    \qquad
                    L(\varepsilon) = \set \varepsilon
                    \qquad
                    \forall a \in \Sigma,\ L(a) = \set a
                \]
                \[
                    L(e | f) = L(e) \cup L(f)
                    \qquad
                    L(ef) = L(e) L(f)
                    \qquad
                    L(e^*) = L(e)^*
                \]

                \vspace{6pt}
                
                Exemple :

                $L_1 = \set \varepsilon = L(\varnothing^*)$

                $L_2 = \Sigma = L(a_1 | a_2 | \cdots | a_n)$ en notant $\Sigma = \set{a_k\ |\ k \in \nset 1 n}$

                \[
                    \begin{array}{rcl}
                        L_3 &=& \set{u \in \Sigma^*\ |\ \abs u \equiv 1\ [2]}
                            \vspace{6pt}
                        \\
                            &=& \displaystyle \bigcup_{n \in \N} \set{u \in \Sigma^*\ |\ \abs u = 2n + 1}
                            \vspace{6pt}
                        \\
                            &=& \displaystyle \lr{\bigcup_{n \in \N} \set{u \in \Sigma^*\ |\ \abs u = 2n}}\Sigma
                            \vspace{6pt}
                        \\
                            &=& L\!\lr{(\Sigma\Sigma)^* \Sigma}
                    \end{array}
                \]

                $L_4 = \set{u \in \Sigma^*\ |\ a\ \text{préfixe de $u$ et $b$ suffixe de $u$}} = L(a\Sigma^* b)$

                $L_5 = \set{u \in \Sigma^*\ |\ ab\ \text{est facteur de $u$}} = L(\Sigma^* ab \Sigma^*)$
            \end{indt}

            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Proposition}}
                \begin{emphBox}
                    Soit $\Sigma$ un alphabet, et $L$ un langage sur $\Sigma$.

                    Alors :
                    \[
                        L\ \text{est régulier}\ \ssi \exists e \in \Regexp(\Sigma)\ |\ L = L(e)
                    \]
                \end{emphBox}

                \vspace{12pt}
                
                \begin{proof}
                    \boxed{\Leftarrow} \boxed{\rm Exo}
                    (par induction sur $e$)

                    \vspace{12pt}
                    
                    \boxed{\Rightarrow} par induction sur une dérivation de $L \in \Reg(\Sigma)$, en faisant une disjonction de cas selon la dernière règle utilisée.

                    \vspace{6pt}
                    
                    $\bullet$ $\dfrac{}{\varnothing \in \Reg(\Sigma)}$ : alors $L = \varnothing = L(\varnothing)$

                    \vspace{6pt}
                    
                    $\bullet$ $\dfrac{a \in \Sigma}{\set a \in \Reg(\Sigma)}$ : alors $L = \set a = L(a)$

                    \vspace{6pt}
                    
                    $\bullet$ $\dfrac{L_1 \in \Reg(\Sigma)\ L_2 \in \Reg(\Sigma)}{L_1 \cup L_2 \in \Reg(\Sigma)}$ : alors $L = L_1 \cup L_2$, et par H.I :
                    \[
                        \exists e_1, e_2 \in \Regexp(\Sigma)\
                        \begin{array}{|l}
                            L_1 = L(e_1)
                            \\
                            L_2 = L(e_2)
                        \end{array}
                    \]
                    D'où $L = L_1 \cup L_2 = L(e_1) \cup L(e_2)$

                    \vspace{6pt}
                    
                    $\bullet$ $\dfrac{L_1 \in \Reg(\Sigma)\ L_2 \in \Reg(\Sigma)}{L_1 L_2 \in \Reg(\Sigma)}$ : alors $L = L_1 L_2$, et par H.I :
                    \[
                        \exists e_1, e_2 \in \Regexp(\Sigma)\
                        \begin{array}{|l}
                            L_1 = L(e_1)
                            \\
                            L_2 = L(e_2)
                        \end{array}
                    \]
                    D'où $L = L_1 L_2 = L(e_1) L(e_2)$

                    \vspace{6pt}
                    
                    $\bullet$ $\dfrac{L_0 \in \Reg(\Sigma)}{L_0^* \in \Reg(\Sigma)}$ : alors $L = L_0^*$, et par H.I :
                    \[
                        \exists e \in \Regexp(\Sigma)\
                        \begin{array}{|l}
                            L_0 = L(e)
                        \end{array}
                    \]
                    D'où $L = L_0^* = L(e)$
                \end{proof}

                \vspace{12pt}
                
                Exemple : $L = \set{ab, ac}$

                \[
                    \begin{array}{c}
                        \dfrac{
                            ~\dfrac{
                                ~\dfrac{a \in \Sigma}{\set a \in \Reg(\Sigma)}
                                \ \
                                \dfrac{b \in \Sigma}{\set b \in \Reg(\Sigma)}~
                            }{
                                \set{ab} \in \Reg(\Sigma)
                            }
                            \ \
                            \dfrac{
                                ~\dfrac{a \in \Sigma}{\set a \in \Reg(\Sigma)}
                                \ \
                                \dfrac{c \in \Sigma}{\set c \in \Reg(\Sigma)}~
                            }{
                                \set{ac} \in \Reg(\Sigma)
                            }~
                        }{
                            \set{ab, ac} \in \Reg(\Sigma) %\Reg(\set{a, b c})
                        }
                        \\
                        \\
                        ab | ac
                        \\\\
                        \dfrac{
                            ~\dfrac{
                                a \in \Reg(\Sigma)
                            }{
                                \set a \in \Reg(\Sigma)
                            }
                            \ \
                            \dfrac{
                                ~\dfrac{b \in \Sigma}{\set b \in \Reg(\Sigma)}
                                \ \
                                \dfrac{c \in \Sigma}{\set c \in \Reg(\Sigma)}~
                            }{
                                \set{b, c} \in \Reg(\Sigma)
                            }~
                        }{
                            \set{ab, ac} \in \Reg(\Sigma)
                        }
                        \\
                        \\
                        a(b|c)
                    \end{array}
                \]
            \end{indt}

            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Définition (\textit{équivalence d'expressions régulières})}}
                Soit $\Sigma$ un alphabet, et $e, f \in \Regexp(\Sigma)$.

                Alors $e, f$ sont dits équivalents, noté $e \equiv f$, si et seulement si $L(e) = L(f)$.
            \end{indt}

            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Proposition}}
                \begin{emphBox}
                    Soit $\Sigma$ un alphabet, et $e \in \Regexp(\Sigma)$.

                    (1) Si $e$ ne contient pas $\varnothing$, alors $L(e) \neq \varnothing$

                    (2) La réciproque est fausse

                    (3) Si $L(e) \neq \varnothing$, alors $\exists f \in \Regexp(\Sigma)\ |\ e \equiv f$ et $f$ ne contient pas $\varnothing$.
                \end{emphBox}

                \vspace{12pt}
                
                \begin{proof}
                    (1) \boxed{\rm Exo} par induction sur $e$

                    (2) $a | \varnothing$ avec $a \in \Sigma$

                    (3) Par induction sur $e$ :

                    $\bullet$ $e = \varnothing$ : impossible

                    $\bullet$ $e = \Sigma$ ou $e = a$ avec $a \in \Sigma$, $f = e$ convient

                    \begin{indt}{$\bullet$ $e = e_1 | e_2$ : $L(e_1) = \varnothing = L(e_2)$ est impossible car $L(e) = L(e_1) \cup L(e_2)$}
                        $-$ Si $L(e_1) = \varnothing$ et $L(e_2) \neq \varnothing$ (l'autre cas est symétrique), $L(e) = L(e_2)$, et par H.I, $\exists f_2 \in \Regexp(\Sigma)\ |\ f_2$ ne contient pas $\varnothing$ et $f_2 \equiv e_2$.

                        Alors $e \equiv f_2$.

                        \vspace{12pt}
                        
                        $-$ Si $L(e_1) \neq \varnothing$ et $L(e_2) \neq \varnothing$, par H.I, $\exists f_1, f_2 \in \Regexp(\Sigma)\ |\ f_1, f_2$ ne contiennent pas $\varnothing$, et
                        \[
                            \begin{cases}
                                f_1 \equiv e_1
                                \\
                                f_2 \equiv e_2
                            \end{cases}
                        \]
                        Alors $L(e) = L(e_1) \cup L(e_2) = L(f_1) \cup L(f_2) = L(f_1 | f_2)$
                        et $e \equiv f_1 | f_2$ qui ne contient pas $\varnothing$.
                    \end{indt}

                    \vspace{6pt}
                    
                    $\bullet$ $e = e_1 e_2$ : $L(e_1) = \varnothing$ ou $L(e_2) = \varnothing$ est impossible car $L(e) = L(e_1) L(e_2)$.

                    De même, on applique l'H.I à $e_1$ et $e_2$ pour obtenir deux expressions régulières dont on prend la concaténation.

                    \vspace{6pt}
                    
                    \begin{indt}{$\bullet$ $e = l_0^*$ :}
                        $-$ Si $L(e_0) = \varnothing$, alors $L(e) = \set \varepsilon = L(\varepsilon)$

                        $-$ Sinon, on applique l'H.I à $e_0$ pour obtenir une expression régulière dont on prend l'étoile de \textsc{Kleene}
                    \end{indt}
                \end{proof}
            \end{indt}

            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Proposition}}
                Soit $\Sigma$ un alphabet, et $e \in \Regexp(\Sigma)$.

                On définit le terme constant de $e$ inductivement par
                \[
                    c(\varnothing) = 0
                    \qquad
                    c(\varepsilon) = 1
                    \qquad
                    c(a) = 0
                \]
                \[
                    c(ef) = \min(c(e), c(f))
                    \qquad
                    c(e|f) = \max(c(e), c(f))
                    \qquad
                    c(e^*) = 1
                \]

                \vspace{6pt}
                
                Alors :
                \begin{emphBox}
                    \[
                        \varepsilon \in L(e) \ssi c(e) = 1
                    \]
                \end{emphBox}

                \vspace{12pt}
                
                \begin{proof}
                    \boxed{\rm Exo} par induction sur $e$.
                \end{proof}
            \end{indt}
        \end{indt}

        \vspace{12pt}
        
        \begin{indt}{\subsection{Expressions régulières étendues}}
            \begin{indt}{\subsubsection{Définition (\textit{expressions régulières étendues})}}
                Soit $\Sigma$ un alphabet.

                On étend la définition des expressions régulières en ajoutant deux symboles $\cap$ et $\setminus$ à $S$ et en ajoutant les règles d'inférence suivantes :
                \[
                    \dfrac{e \in \Regexp(\Sigma)\ f \in \Regexp(\Sigma)}{e \cap f \in \Regexp(\Sigma)}
                    \qquad
                    \dfrac{e \in \Regexp(\Sigma)\ f \in \Regexp(\Sigma)}{(e \setminus f) \in \Regexp(\Sigma)}
                \]

                Les langages dénotés sont
                \[
                    \begin{array}{l}
                        L(e \cap f) = L(e) \cap L(f)
                        \\
                        L(e\setminus f) = L(e) \setminus L(f)
                    \end{array}
                \]

                Nous verrons que les expressions régulières étendues dénotent les mêmes langages que les expressions régulières.
            \end{indt}

            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Application}}
                Les expressions régulières (étendues) sont liées aux expressions régulières de la norme POSIX, utilisées par exemple dans la commande \texttt{grep}.

                Exemple :
                \begin{center}
                    \texttt{find | grep -E '.*/d[ms][1/]*\textbackslash .(pdf|tex)\$' | grep 'corrigé'}
                \end{center}
                trouve les fichiers dont le nom contient \texttt{dm} ou \texttt{ds}, d'extension \texttt{.pdf} ou \texttt{.tex}, et dont le nom contient \texttt{corrigé}.
            \end{indt}

            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Définition (\textit{langages des préfixes / suffixes / facteurs})}}
                Soit $L$ un langage sur un alphabet $\Sigma$.

                On défini les langages des préfixes / suffixes de longueur 1 et des facteurs de longueur 2 des mots de $L$ par
                \[
                    \begin{array}{l}
                        P_1(L) = \set{a \in \Sigma\ |\ \exists u \in \Sigma^*\ |\ au \in L}
                        \\
                        S_1(L) = \set{a \in \Sigma\ |\ \exists u \in \Sigma^*\ |\ ua \in L}
                        \\
                        F_2(L) = \set{u \in \Sigma^2\ |\ \exists x, y \in \Sigma^*\ |\ xuy \in L}
                    \end{array}
                \]
            \end{indt}

            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Langages locaux}}
                $\bullet$ \boxed{\rm Exo} pour tout langage $L$ sur un alphabet $\Sigma$,
                \[
                    L \setminus \set \varepsilon
                    \subseteq
                    \lr{P_1(L) \Sigma^* \cap \Sigma^* S_1(L)} \setminus \lr{\Sigma^*\lr{\Sigma^2 \setminus F_2(L)} \Sigma^*}
                \]
                mais cette inclusion peut être stricte.

                \vspace{12pt}
                
                $\bullet$ Définition : Soit $\Sigma$ un alphabet, et $L$ un langage sur $\Sigma$.

                $L$ est \emph{local} si et seulement si
                \[
                    L \setminus \set \varepsilon = \lr{P_1(L) \Sigma^* \cap \Sigma^* S_1(L)} \setminus \lr{\Sigma^*\lr{\Sigma^2 \setminus F_2(L)} \Sigma^*}
                \]

                \vspace{12pt}
                
                \begin{indt}{$\bullet$ Exemples :}
                    $-$ $(ab)^*$ et $(ab)^+$ sont locaux

                    $-$ $P_1 = \set a$, $S_1 = \set b$, et $F_2 = \set{a, b}^2 \setminus \set{ab, ba}$ définissent les langages locaux $\varepsilon$ et $\varnothing$
                \end{indt}

                \vspace{12pt}
                
                $\bullet$ Proposition :
                \begin{emphBox}
                    Tout langage local est dénoté par une expression régulière étendue
                \end{emphBox}

                \vspace{6pt}
                
                \begin{proof}
                    En utilisant la définition et le fait qu'un langage fini est régulier \boxed{\rm Exo}
                \end{proof}

                \vspace{12pt}
                
                $\bullet$ \boxed{\rm Exo} : Donner un algorithme permettant de déterminer $P_1(L)$, $S_1(L)$, $F_2(L)$ pour tout langage régulier.

                Indication : induction sur une expression régulière dénotant $L$.
            \end{indt}

            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Langages linéaires}}
                $\bullet$ Définition (\emph{expression régulière linéaire}) : une expression régulière est dite \emph{linéaire} si et seulement si chaque lettre qui la compose n'y apparaît qu'une seule fois.

                \vspace{12pt}
                
                $\bullet$ Exemple : $(ab)^* | cd^*e$ mais pas $(ab^*)|ca$

                \vspace{12pt}
                
                $\bullet$ Définition (\emph{langage linéaire}) : un langage est \emph{linéaire} si et seulement si il est dénoté par une expression régulière linéaire.

                \vspace{12pt}
                
                $\bullet$ Proposition :
                \begin{emphBox}
                    Tout langage linéaire est local.
                \end{emphBox}

                \vspace{6pt}
                
                \begin{proof}
                    $-$ Lemme 1 :
                    \begin{emphBox}
                        \textit{Lemme 1} :
                        Soient $L_1, L_2$ deux langages locaux sur les alphabets disjoints.

                        Alors $L_1 \cup L_2$ est local
                    \end{emphBox}

                    \boxed{\rm Exo}

                    \vspace{6pt}
                    
                    $-$ Lemme 2 :
                    \begin{emphBox}
                        \textit{Lemme 2} :
                        Soient $L_1, L_2$ deux langages locaux sur des alphabets disjoints.

                        Alors $L_1 L_2$ est local.
                    \end{emphBox}

                    \boxed{\rm Exo}

                    Indication : distinguer quatre cas selon que $\varepsilon \in L_1$ ou $\varepsilon \in L_2$.

                    \vspace{12pt}
                    
                    \begin{indt}{$-$ Par induction sur une expression régulière linéaire dénotant le langage}
                        . $\varnothing$ ou $\varepsilon$ : $P_1 = S_1 = F_2 = \varnothing$ conviennent

                        . $a \in \Sigma$ : $P_1 = S_1 = \set a$ et $F_2 = \varnothing$ convient

                        . $e | f$ : par H.I, $L(e)$ et $L(f)$ sont locaux.

                        De plus, come $e | f$ est linéaire, $e$ et $f$ sont exprimés sur des alphabets disjoints.

                        Donc le lemme 1 conclut.
                    \end{indt}

                    $-$ $ef$ : le même raisonnement avec le lemme 2.

                    $-$ $e^*$ : par H.I, $L(e)$ est local, donc
                    \[
                        L(e) \setminus \set \varepsilon =
                        \lr{P_1 \Sigma^* \cap \Sigma^* S_1} \setminus \lr{\Sigma^* \lr{\Sigma^2 \setminus F_2} \Sigma^*}
                    \]

                    $p_1(e^*) = P_1(e)$

                    $S_1(e^*) = S_1(e)$

                    $F_2(e^*) = F_2(e) \cup S_1(e) P_1(e)$
                \end{proof}

                \vspace{12pt}
                
                \begin{indt}{$\bullet$ Contre-exemples :}
                    $-$ lemmes 1 et 2 : $L_1 = ab$ et $L_2 = a^*$

                    Si $L_1 \cup L_2$ était local, comme $P_1 = \set a,\ S_1 = \set{a, b},\ F_2 = \set{ab, aa}$, on aurait $aab \in L_1 \cup L_2$ : absurde

                    Si $L_1 L_2$ était local, comme $P_1 = \set a,\ S_1 = \set{a, b},\ \set{ab, ba, aa}$, on aurait $aab \in L_1 L_2$ : absurde

                    \vspace{6pt}
                    
                    $-$ $a(ba)^*$ est local mais non linéaire.
                \end{indt}

                \vspace{12pt}
                
                $\bullet$ Linéarisation : on peut transformer une expression régulière $e$ en expression régulière linéaire $\tilde e$ en numérotant ses lettres (l'alphabet devient $\Sigma \times \nset 1 n$)

                \vspace{12pt}
                
                Exemple : $aa(a | ab)^*b$ devient $a_1a_2(a_3 | a_4b_1)^*b_2$

                C'est une étape importante pour faire le lien entre automates et langages réguliers.

                \boxed{\rm Exo} $\forall u,\ u \in L(e) \ssi \exists$ numérotation des lettres de $u$ donnant $\tilde u \in L(\tilde e)$
            \end{indt}
        \end{indt}
    \end{indt}

    \vspace{12pt}
    
    \begin{indt}{\section{Automates finis}}
        \label{2}

        \begin{indt}{\subsection{Automates finis déterministes}}
            \begin{indt}{\subsubsection{Introduction}}
                La représentation visuelle de l'algorithme vu en \ref{1.1.2} (page \pageref{1.1.2}) est la representation graphique d'un automate fini déterministe.
                On peut voir un automate comme une machine à états, qui change d'état en fonction des caractères lus sur son entrée. L'entrée est considérée comme valide si l'état final de la machine est approprié.

                Il existe plusieurs notions d'automates, et nous montrerons que toutes celles au programme sont équivalentes.
            \end{indt}

            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Définition (\textit{automate fini déterministe (AFD)})}}
                \label{2.1.2}

                \begin{indt}{Un \emph{automate fini déterministe} est un quintuplet $(\Sigma, Q, q_0, F, \delta)$, où :}
                    $\bullet$ $\Sigma$ est un alphabet ;

                    $\bullet$ $Q$ est un ensemble fini non vide, appelé \emph{ensemble d'états} ;

                    $\bullet$ $q_0 \in Q$ est l'état initial ;

                    $\bullet$ $F \in \mathcal P(Q)$ est l'ensemble des états acceptants / finaux / final / terminaux ;

                    $\bullet$ $\delta : Q \times \Sigma \longrightarrow Q$ est une fonction partielle (\textit{i.e} définie sur une partie de $Q \times \Sigma$) appelée \emph{fonction de transition}.
                \end{indt}

                \vspace{12pt}
                
                \begin{indt}{Représentation graphique :}
                    $\bullet$ Tout état $q \in Q$ est représenté par un cercle ;

                    $\bullet$ L'état initial prend une flèche ;

                    $\bullet$ Les états acceptants sont cerclés deux fois ;

                    $\bullet$ $\forall q, q' \in Q,\ \forall a \in \Sigma\ |\ \delta(q, a) = q'$, on dessine un arc de $q$ à $q'$ étiqueté par $a$.
                \end{indt}

                \vspace{12pt}
                
                Exemple :
                \begin{center}
                    \begin{tikzpicture}
                        \node (q0) at (0, 0) [state, initial, initial text={}] {$q_0$};
                        \node (q1) at (2, 0) [state] {$q_1$};
                        \node (q2) at (4, 0) [state] {$q_2$};
                        \node (q3) at (2, -2) [state, accepting] {$q_3$};

                        \draw[->] (q0) to node [above] {$1$} (q1);
                        \draw[->] (q1) to [out=20, in=160] node [above] {$0$} (q2);
                        \draw[->] (q2) to [out=-160, in=-20] node [below] {$0$} (q1);
                        \draw[->] (q0) to node [below left] {$0$} (q3);
                        \draw[->] (q1) to [out=-70, in=70] node [right] {$1$} (q3);
                        \draw[->] (q3) to [out=110, in=-110] node [left] {$1$} (q1);

                        \draw[->] (q3) to [out=0, in=-50, looseness=2] node [right] {$0$} (q3);
                        \draw[->] (q2) to [out=0, in=-50, looseness=2] node [right] {$1$} (q2);
                    \end{tikzpicture}
                \end{center}

                représente
                \[
                    (\set{0, 1}, \set{q_0, \ldots, q_3}, q_0, \set{q_3}, \delta)
                \]
                où $\delta$ est défini par la table
                \[
                    \begin{array}{c|c|c}
                        & 0 & 1
                        \\
                        \hline
                        q_0 & q_3 & q_1
                        \\
                        \hline
                        q_1 & q_2 & q_3
                        \\
                        \hline
                        q_2 & q_ 1 & q_2
                        \\
                        \hline
                        q_3 & q_3 & q_1
                    \end{array}
                \]
            \end{indt}

            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Modèle de calcul associé}}
                $\bullet$ Définition (\emph{transition généralisées}) : Soit $M = (\Sigma, Q, q_0, F, \delta)$ un AFD.

                On généralise la fonction de transition aux mots par :
                \[
                    \begin{cases}
                        \forall q \in Q,\ \delta(q, \varepsilon) = q
                        \\
                        \forall q \in Q,\ \forall u \in \Sigma^*,\ \forall a \in \Sigma\ |\ (q, a) \in \mathrm{dom}(\delta),\ \delta(q, au) = \delta(\delta(q, a), u)
                    \end{cases}
                \]

                \boxed{\rm Exo} Mq cette définition est équivalente à
                \[
                    \forall (q, u, a) \in Q \times \Sigma^* \times \Sigma,\
                    \delta(q, ua) = \delta(\delta(q, u), a)
                \]
                ou alors
                \[
                    \forall q, q' \in Q,\ \forall u \in \Sigma ^*,\ \delta(q, u) = q'
                \]
                si et seulement si il existe un chemin dans le graphe de l'automate de $q$ à $q'$ tel que la concaténation des étiquettes sur ce chemin vaut $u$.

                \vspace{12pt}
                
                $\bullet$ Définition (\emph{langage reconnu / reconnaissable}) : Soit $M = (\Sigma, Q, q_0, F, \delta)$ un AFD.

                $-$ $u \in \Sigma ^*$ est \emph{accepté} par $M$ ssi $\delta(q_0, u) \in F$

                $-$ La langage \emph{reconnu} par $M$ est
                \[
                    L(M) = \set{u \in \Sigma^*\ |\ u\ \text{accepté par $M$}}
                \]

                $-$ Un langage $L$ sur un alphabet $\Sigma$ est \emph{reconnaissable} ssi il existe un AFD $M$ d'alphabet $\Sigma$ tel que $L(M) = L$.

                On note alors $\Rec \Sigma$ l'ensemble des langages reconnaissables sur $\Sigma$.

                \vspace{12pt}
                
                $\bullet$ Exemples :

                $-$ $\set{u \in \set{0, 1}^*\ |\ \lrangle u _2 \equiv 0\ [3]} \in \Rec{\set{0, 1}}$ par \ref{1.1.2} (page \pageref{1.1.2}).

                $-$ On reprend l'AFD vu en \ref{2.1.2} (page \pageref{2.1.2}).
                Pour déterminer $L(M)$, on peut utiliser le lemme d'\textsc{Arden}.

                $\forall q \in Q,$ on définit
                \[
                    L_q = \set{u \in \Sigma^*\ |\ \delta(q, u) \in F}
                \]

                On cherche $L(M) = L_{q_0}$ sachant :

                \[
                    \begin{cases}
                        L_{q_0} = 0L_{q_3} \cup 1L_{q_1}
                        \\
                        L_{q_1} = 0L_{q_2} \cup 1L_{q_3}
                        \\
                        L_{q_2} = 0L_{q_1} \cup 1L_{q_2}
                        \\
                        L_{q_3} = 0L_{q_3} \cup 1L_{q_1} \cup \set \varepsilon
                    \end{cases}
                \]

                \boxed{\rm Exo} Mq $L(M) = (1(01^*0)^*1|0)^*$
            \end{indt}

            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Automate complet}}
                $\bullet$ Définition (\emph{Automate complet}) : un AFD est dit \emph{complet} ssi sa fonction de transition est totale.

                \vspace{12pt}
                
                $\bullet$ Exemple : les automates en \ref{1.1.2} (page \pageref{1.1.2}) et \ref{2.1.2} (page \pageref{2.1.2}).

                \vspace{12pt}
                
                $\bullet$ Complétion : étant donné un AFD $M = (\Sigma, Q, q_0, F, \delta)$ incomplet, on peut construire $M'$ complet reconnaissant $L(M)$ en ajoutant un état dit \emph{poubelle / puits}, vers lequel vont toutes les transitions non définies de $\delta$.

                \[
                    M' = (\Sigma, Q \cup \set \Pi, q_0, F, \delta')
                \]
                où $\Pi \notin Q$, et
                \[
                    \forall q \in Q \cup \set \Pi,\ \forall a \in \Sigma,\
                    \delta'(q, a) =
                    \begin{cases}
                        \delta(q, a)
                        & \text{si}\ (q, a) \in \mathrm{dom}(\delta)
                        \\
                        \Pi
                        & \text{sinon}
                    \end{cases}
                \]

                \vspace{12pt}
                
                $\bullet$ Proposition :
                \begin{emphBox}
                    $M'$ est complet, et $L(M') = L(M)$
                \end{emphBox}

                \vspace{6pt}
                
                \begin{proof}
                    $M'$ est complet par définition.

                    Si $u \in L(M)$, on remarque que toutes les transitions suivies dans $M$ lors de la lecture de $u$ sont définies, et ce sont les mêmes dans $M'$, donc $u \in L(M')$ (récurrence finie, en notant $u = u_1 \cdots u_n$, et $\forall i \in \nset 1 n,\ q_i = \delta(q_0, u_1 \cdots, u_i)$ \boxed{\rm Exo}).

                    \vspace{6pt}
                    
                    Si $u \in L(M')$, on remarque qu'il n'existe pas de transition étiquetée par un préfixe de $u$ menant à l'état $\Pi$ (sinon $\delta'(q_0, u) = \Pi \notin F$) donc toutes ces transitions sont aussi définies dans $M$ et $u \in L(M)$.
                \end{proof}

                \vspace{12pt}
                
                $\bullet$ Exemple :

                \begin{center}
                    \begin{tikzpicture}
                        \node (0) at (0, 0) [initial, initial text={}, state] {$q_0$};
                        \node (1) at (2, 0) [state] {$q_1$};
                        \node (2) at (4, 0) [state, accepting] {$q_2$};

                        \draw[->] (0) to node [above] {$a$} (1);

                        \draw[->] (1) to [out=20, in=160] node [above] {$b$} (2);
                        \draw[->] (2) to [out=-160, in=-20] node [below] {$a$} (1);
                    \end{tikzpicture}
                \end{center}

                Devient :
                \begin{center}
                    \begin{tikzpicture}
                        \node (0) at (0, 0) [initial, initial text={}, state] {$q_0$};
                        \node (1) at (2, 0) [state] {$q_1$};
                        \node (2) at (4, 0) [state, accepting] {$q_2$};
                        \node (pi) at (2, -2) [state] {$\Pi$};

                        \draw[->] (0) to node [above] {$a$} (1);
                        \draw[->] (0) to node [below left] {$b$} (pi);
                        \draw[->] (1) to node [right] {$a$} (pi);
                        \draw[->] (2) to node [below right] {$b$} (pi);

                        \draw[->] (1) to [out=20, in=160] node [above] {$b$} (2);
                        \draw[->] (2) to [out=-160, in=-20] node [below] {$a$} (1);

                        \draw[->] (pi) to [out=-45, in=-90, looseness=4] node [below] {$a, b$} (pi);
                    \end{tikzpicture}
                \end{center}
            \end{indt}

            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Automate standard}}
                $\bullet$ Définition : Un AFD est dit \emph{standard} ssi aucune transistion ne mène à l'état initial.

                \vspace{12pt}
                
                $\bullet$ Exemple : l'automate en \ref{2.1.2} (page \pageref{2.1.2}), mais pas celui en \ref{1.1.2} (page \pageref{1.1.2}).

                \vspace{12pt}
                
                $\bullet$ Standardisation : si $M = (\Sigma, Q, q_0, F, \delta)$ est un AFD non standard, on construit un AFD $M'$ standard reconnaissant $L(M)$ en ajoutant un nouvel état initial qui ne sert que pour la première transition.

                On définit $M' = (\Sigma, Q \cup \set \iota, \iota, F', \delta')$, où $\iota \notin Q$,
                \[
                    F' =
                    \begin{cases}
                        F
                        & \text{si}\ q_0 \notin F
                        \\
                        F \cup \set \iota
                        & \text{sinon}
                    \end{cases}
                \]
                \[
                    \forall (q, a) \in (Q \cup \set \iota) \times \Sigma,\
                    \delta'(q, a) =
                    \begin{cases}
                        \delta(q, a)
                        & \text{si}\ (q ,a) \in \mathrm{dom}(\delta)
                        \\
                        \delta(q_0, a)
                        & \text{si}\ \iota = q\ \text{et}\ (q_0, a) \in \mathrm{dom}(\delta)
                        \\
                        \text{non définie}
                        & \text{sinon}
                    \end{cases}
                \]

                \boxed{\rm Exo} $M'$ est standard, et $L(M') = L(M)$.

                \vspace{12pt}
                
                $\bullet$ Exemple :

                \begin{center}
                    \begin{tikzpicture}
                        \node (0) at (0, 0) [initial, initial text={}, state, accepting] {$q_0$};
                        \node (1) at (2, 0) [state] {$q_1$};
                        \node (2) at (4, 0) [state, accepting] {$q_2$};

                        \draw[->] (0) to node [above] {$a$} (1);

                        \draw[->] (1) to [out=20, in=160] node [above] {$b$} (2);
                        \draw[->] (2) to [out=-160, in=-20] node [below] {$a$} (1);

                        \draw[->] (1) to [out=45, in=90, looseness=3] node [above] {$a$} (1);
                    \end{tikzpicture}
                \end{center}

                Devient :
                \begin{center}
                    \begin{tikzpicture}
                        \node (0) at (0, 0) [initial, initial text={}, state, accepting] {$q_0$};
                        \node (1) at (2, 0) [state] {$q_1$};
                        \node (2) at (4, 0) [state, accepting] {$q_2$};
                        \node (i) at (2, -2) [state, initial, initial text={}, accepting] {$\iota$};

                        \draw[->] (0) to node [above] {$a$} (1);
                        \draw[->] (i) to node [below left] {$b$} (0);
                        \draw[->] (i) to node [right] {$a$} (1);
                        %\draw[->] (i) to node [below right] {$b$} (2);

                        \draw[->] (1) to [out=20, in=160] node [above] {$b$} (2);
                        \draw[->] (2) to [out=-160, in=-20] node [below] {$a$} (1);

                        \draw[->] (0) to [out=45, in=90, looseness=3] node [above] {$b$} (0);
                    \end{tikzpicture}
                \end{center}
            \end{indt}

            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Automate émondé}}
                $\bullet$ Idée : certains états peuvent être inutiles du point de vue du modèle de calcul.

                Par exemple, l'état puits d'un complété n'apporte rien au langage reconnu.
                De même un état qui ne serait pas accessible depuis l'état initial est inutile.

                \vspace{12pt}
                
                \begin{indt}{$\bullet$ Définition (\emph{états accessibles / co-accessibles, utiles}) : Soit $M = (\Sigma, Q, q_0, F, \delta)$ un AFD, et $q \in Q$.}
                    $-$ $q$ est dit \emph{accessible} ssi $\exists u \in \Sigma^*\ |\ \delta(q_0, u) = q$

                    $-$ $q$ est dit \emph{co-accessible} ssi $\exists u \in \Sigma^*\ |\ \delta(q, u) \in F$

                    $-$ $q$ est dit \emph{utile} ssi $q$ est accessible et co-accessible.
                \end{indt}

                \vspace{12pt}
                
                $\bullet$ Remarque : il est possible de déterminer les états accessibles grâce à un parcours depuis l'état initial, les états co-accessibles grâce à un parcours du graphe transposé du graphe de l'automate à partir des états acceptants, et les états utiles grâce à deux parcours.

                \vspace{12pt}
                
                $\bullet$ Définition (\emph{automate émondé}) : Un automate est dit \emph{émondé} ssi tous ses états sont utiles.

                \vspace{12pt}
                
                $\bullet$ \boxed{\rm Exo} Supprimer les états inutiles donne un AFD émondé reconnaissant le même langage.

                \vspace{12pt}
                
                $\bullet$ Remarque : Disposer d'un automate émondé reconnaissant un langage donné n'assure pas d'avoir l'information minimale permettant de caractériser ce langage.

                Exemple :

                \begin{center}
                    \begin{tikzpicture}
                        \node (0) at (0, 0) [state, accepting, initial, initial text={}] {$q_0$};
                        \node (1) at (2, 0) [state, accepting] {$q_1$};

                        \draw[->] (0) to node [above] {$a, b$} (1);
                        \draw[->] (1) to [out=45, in=90, looseness=3] node [above right] {$a, b$} (1);

                        \node at (3.75, 0) {et};

                        \node (0') at (6, 0) [state, accepting, initial, initial text={}] {$q_0$};
                        \draw[->] (0') to [out=45, in=90, looseness=3] node [above right] {$a, b$} (0');
                    \end{tikzpicture}
                \end{center}

                sont deux automates émondés reconnaissant le même langage ($\Sigma^*$, avec $\Sigma = \set{a, b}$)

                \vspace{12pt}
                
                $\bullet$ (H.P) Un automate reconnaissant un langage donné et ayant un nombre minimal d'états est appelé \emph{automate minimal} du langage et on peut montrer que l'automate minimal d'un langage donné est émondé et unique (à isomorphisme près).
            \end{indt}

            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Automate local}}
                $\bullet$ Remarque :
                Un langage local est caractérisé par la connaissance des lettres qui peuvent débuter / terminer un mot du langage et des lettres qui peuvent succéder à une lettre donnée dans un mot de langage. En particulier, la connaissance de la dernière lettre lue permet de connaître les lettres qui peuvent suivre, ce qui fait des langages locaux de bon candidats pour l'appartenance à $\Rec \Sigma$.

                \vspace{12pt}
                
                $\bullet$ Exemple : $a(b^* | c)$, $P_1 = \set a$, $S_1 = \set{a, b, c}$, $F_2 = \set{ab, ac, bb}$

                Idée : on associe un état à chaque lettre lue.

                \begin{center}
                    \begin{tikzpicture}
                        \node (ep) at (-2, 0) [state, initial, initial text={}] {$q_\varepsilon$};
                        \node (a) at (0, 0) [state, accepting] {$q_a$};
                        \node (b) at (2, 0) [state, accepting] {$q_b$};
                        \node (c) at (-45 : 2) [state, accepting] {$q_c$};

                        \draw[->] (ep) to node [above] {$a$} (a);
                        \draw[->] (a) to node [above] {$b$} (b);
                        \draw[->] (a) to node [below left] {$c$} (c);

                        \draw[->] (b) to [out=45, in=90, looseness=3] node [above right] {$b$} (b);
                    \end{tikzpicture}
                \end{center}

                \vspace{12pt}
                
                $\bullet$ Définition (\emph{automate local}) : Soit $M = (\Sigma, Q, q_0, F, \delta)$ un AFD.

                $M'$ est dit \emph{local} ssi
                \[
                    \forall a \in \Sigma,\ \exists q \in Q\ |\ \forall q' \in Q,\
                    (q', a) \in \mathrm{dom}(\delta) \Rightarrow \delta(q', a) = q
                \]

                \vspace{12pt}
                
                $\bullet$ Proposition :
                \begin{emphBox}
                    Soit $\Sigma$ un alphabet, et $L$ un langage sur $\Sigma$.

                    \[
                        L\ \text{est local}
                        \ssi
                        \exists M = (\Sigma, Q, q_0, F, \delta)\ \text{un AFD local}\ |\
                        L(M) = L
                    \]
                \end{emphBox}

                \vspace{6pt}
                
                \begin{proof}
                    \boxed{\Rightarrow} On sait que
                    \[
                        L \setminus \varepsilon = (P_1(L) \Sigma^* \cap \Sigma^*S_1(L)) \setminus (\Sigma^*(\Sigma^2 (F_2(L)) \Sigma^*))
                        \qquad (*)
                \]

                On définit $M = (\Sigma, Q, q_\varepsilon, F, \delta)$, où
                \[
                    Q = \set{q_\varepsilon} \cup \set{q_a\ |\ a \in \Sigma}
                \]
                \[
                    F =
                    \begin{cases}
                        \set{q_a\ |\ a \in S_1(L)}
                        & \text{si}\ \varepsilon \notin L
                        \\
                        \set{q_a\ |\ a \in S_1(L)} \cup \set{q_\varepsilon}
                        & \text{sinon}
                    \end{cases}
                \]
                \[
                    \forall (q ,a) \in Q \times \Sigma,\
                    \delta(q, a) =
                    \begin{cases}
                        q_a
                        & \text{si}\ q = q_\varepsilon\ \text{et}\ a \in P_1(L)
                        \\
                        q_b
                        & \text{si}\ q = q_b\ \text{et}\ ba \in F_2(L)
                        \\
                        \text{non définie}
                        & \text{sinon}
                    \end{cases}
                \]

                \textcolor{red}{\sl (pas sûr pour la ligne 2 ($q_b = \cdots$))}

                Alors $M$ est local (même standard) et $L(M) = L$

                On le montre par double inclusion en utilisant l'égalité $(*)$ \boxed{\rm Exo}.

                \vspace{12pt}
                
                \boxed{\Leftarrow} On sait que $L = L(M)$ où $M = (\Sigma, Q, q_0, F, \delta)$ est un AFD local.

                \[
                    \forall a \in \Sigma,\ \exists q_a \in Q\ |\ \forall q' \in Q,\
                    (q', a) \in \mathrm{dom}(\delta) \Rightarrow \delta(q', a) = q_a
                \]

                On définit
                \[
                    \begin{array}{l}
                        P_1 = \set{a \in \Sigma\ |\ (q_0, a) \in \mathrm{dom}(\delta)}
                        = \set{a \in \Sigma\ |\ \delta(q_0, a) = q_a}
                        \\
                        S_1 = \set{a \in \Sigma\ |\ qa \in F}
                        \\
                        F_2 = \set{ab \in \Sigma^2\ |\ (qa, b) \in \mathrm{dom}(\delta)}
                    \end{array}
                \]

                On vérifie alors que
                \[
                    L \setminus \set \varepsilon
                    = (P_1 \Sigma^* \cap \Sigma^* S_1) \setminus \lr{\Sigma^* \lr{\Sigma^2 \setminus F_2} \Sigma^*}
                \]

                \boxed{\subseteq} Soit $u = u_1 \cdots u_n \in L \setminus \set \varepsilon$.

                $u \in L(M)$, donc $\forall i \in \nset 1 n,\ \delta(q_0, u_1 \cdots u_i)$ est bien défini, notons le $q_i$.

                $(q_0, q_i) \in \mathrm{dom}(\delta)$, donc $u_1 \in P_1$.

                $q_{u_n} = \delta(q_0, u_1 \cdots u_n) \in F$, donc $u_n \in S_1$.

                $\forall i \in \nset 1 {n - 1}$,
                \[
                    \begin{array}{rcl}
                        \delta(q_0, u_1 \cdots u_{i + 1})
                        &=& \delta(\delta(q_0, u_1 \cdots u_i), u_{i + 1})
                        \\
                        &=& \delta(q_i, u_{i + 1})
                        \\
                        &=& q_i
                    \end{array}
                \]

                Donc $u_i u{i + 1} \in F_2$, donc
                \[
                    u \in (P_1 \Sigma^* \cap \Sigma^* S_1) \setminus \lr{\Sigma^* \lr{\Sigma^2 \setminus F_2} \Sigma^*}
                \]

                \vspace{6pt}
                
                \boxed{\supseteq} par récurrence sur la taille du mot \boxed{\rm Exo}.
                \end{proof}
            \end{indt}
        \end{indt}

        \vspace{12pt}
        
        \begin{indt}{\subsection{Automates finis non déterministes (AFND)}}
            \begin{indt}{\subsubsection{Introduction}}
                Il peut être complexe, ou simplement fastidieux, de concevoir un AFD reconnaissant un langage donné.

                \vspace{12pt}
                
                Exemple : digicode : on entre une série de chiffres, et si elle se termine par le code enregistré, la porte se débloque.
                Cela correspond au fonctionnement d'un automate, mais la difficulté vient fu fait que même si le début du code est entré, il faut pouvoir revenir en arrière si la suite est invalide.

                Idée : on compte le nombre de chiffres valides lus consécutivement et on met à jour ce nombre en fonction des chiffres lus.

                Par exemple, pour le code 4242, on peut écrire le programme suivant :

                \begin{lstlisting}[language=Caml, xleftmargin=80pt]
let nb_valides = ref 0 in
while !nb_valides < 4 do
    let n = read_int () in
    match !nb_valides, n with
    | 0, 4 | 1, 2 | 2, 4 | 3, 2 -> incr nb_valides
    | _, 4 -> nb_valides := 1
    | _ -> := nb_valides := 0
done;
unlock_door()\end{lstlisting}
                
                En associant un état à chaque valeur possible de \texttt{nb\_valides}, ce code correspond à l'automate

                \begin{center}
                    \begin{tikzpicture}[scale=1.5]
                        \node (0) at (0, 0) [state, initial, initial text={}] {$0$};
                        \node (1) at (2, 0) [state] {$1$};
                        \node (2) at (4, 0) [state] {$2$};
                        \node (3) at (6, 0) [state] {$3$};
                        \node (4) at (8, 0) [state, accepting] {$4$};

                        \draw[->] (0) to node [above] {$4$} (1);
                        \draw[->] (1) to node [above] {$2$} (2);
                        \draw[->] (2) to node [above] {$4$} (3);
                        \draw[->] (3) to node [above] {$2$} (4);

                        \draw[->] (1) to [out=45, in=90, looseness=3] node [above right] {$4$} (1);
                        \draw[->] (0) to [out=-90, in=-135, looseness=3] node [below left] {${0 - 3, 5 - 9}$} (0);
                        \draw[->] (2) to [out=100, in=40, looseness=1] node [above right] {${0 - 3, 5 - 9}$} (0);
                        \draw[->] (1) to [out=-120, in=-40] node [below right] {${0, 1, 3, 5 - 9}$} (0);
                        \draw[->] (3) to [out=-100, in=-50, looseness=.8] node [below right] {${0, 1, 3, 5-9}$} (0);
                        \draw[->] (3) to [out=-135, in=-15] node [below right] {$4$} (1);
                    \end{tikzpicture}
                \end{center}

                Cet automate contient de nombreuses informations ``parasites'', liées uniquement à la gestion des erreurs de l'entrée. On peut simplifier sa présentation en changeant le modèle de calcul et en exploitant le principe de retour sur trace.

                Idée : depuis l'état 0, si on lit un 4, cela peut être le début d'une séquence valide donc on passe dans l'état 1, mais si une erreur survient dans la suite de la séquence, on revient sur ce choix et on décide que la lecture de ce 4 conserve l'état 0.

                Graphiquement, cela simplifie l'automate en :

                \begin{center}
                    \begin{tikzpicture}
                        \node (0) at (0, 0) [state, initial, initial text={}] {$0$};
                        \node (1) at (2, 0) [state] {$1$};
                        \node (2) at (4, 0) [state] {$2$};
                        \node (3) at (6, 0) [state] {$3$};
                        \node (4) at (8, 0) [state, accepting] {$4$};

                        \draw[->] (0) to node [above] {$4$} (1);
                        \draw[->] (1) to node [above] {$2$} (2);
                        \draw[->] (2) to node [above] {$4$} (3);
                        \draw[->] (3) to node [above] {$2$} (4);

                        \draw[->] (0) to [out=-90, in=-135, looseness=4] node [below] {$0 - 9$} (0);
                    \end{tikzpicture}
                \end{center}

                L'algorithme de retour sur trace revient à parcourir ce graphe selon les lettres lues en essayant de passer dans l'état 1 dès que possible et en revenant sur ce choix en cas d'impossibilité.
                Ce type d'automate est appelé \emph{non déterministe} car on peut le voir comme une machine pouvant être dans plusieurs états à la fois ( par exemple 0 et 1 après la lecture d'un 4 depuis l'état 0).
                Lorsqu'une transition est impossible, la machine n'est plus dans l'état associé (idée du retour sur trace), et l'objectif est que l'un des états de la machine sont acceptant en fin de lecture.
            \end{indt}

            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Définition (\textit{Automate fini non déterministe})}}
                \begin{indt}{Un \emph{automate fini non déterministe} (AFND) est un quintuplet $M = (\Sigma, Q, I, F, \delta)$}
                    $-$ $\Sigma$ est un alphabet ;

                    $-$ $Q$ est un ensemble fini non vide d'états ;

                    $-$ $I \subseteq Q$ est l'ensemble des états initiaux ;

                    $-$ $F \subseteq Q$ est l'ensemble des états acceptants ;

                    $-$ $\delta : Q \times \Sigma \longrightarrow \mathcal P(Q)$
                \end{indt}

                \vspace{12pt}
                
                Remarque : $\delta$ est totale, mais son image peut être vide pour certains couples.

                \vspace{12pt}
                
                Représentation graphique : comme les AFD, avec un arc $q \overset a \longrightarrow q'$ $\forall (q, q', a) \in Q^2 \times \Sigma\ |\ q' \in \delta(q, a)$.
            \end{indt}

            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Modèle de calcul associé}}
                $\bullet$ Définition (\emph{transition généralisées}) : Soit $M = (\Sigma, Q, I, F, \delta)$ un AFND.

                On généralise $\delta$ aux mots en définissant $\forall q \in Q,\ \delta(q, \varepsilon) = \set q$, et
                \[
                    \forall (q, u, a) \in Q \times \Sigma^* \times \Sigma,\
                    \delta(q, au) = \bigcup_{q' \in \delta(q, a)} \delta(q', u)
                \]

                \boxed{\rm Exo} Montrer que c'est équivalent à :
                \[
                    \forall (q, u, a) \in Q \times \Sigma^* \times \Sigma,\
                    \delta(q, ua) = \bigcup_{q' \in \delta(q, u)} \delta(q', a)
                \]

                \vspace{12pt}
                
                \begin{indt}{$\bullet$ Définition (\emph{langage reconnu}) : Soit $M = (\Sigma, Q, I, F, \delta)$ un AFND.}
                    $-$ $\forall u \in \Sigma^*$, $u$ est accepté par $M$ si et seulement si
                    \[
                        \lr{\bigcup_{q_0 \in I} \delta(q_0, u)} \cap F \neq \varnothing
                    \]

                    $-$ Le langage reconnu par $M$ est
                    \[
                        L(M) = \set{u \in \Sigma^*\ |\ M\ \text{acceptable}\ u}
                    \]
                \end{indt}

                \vspace{12pt}
                
                $\bullet$ Proposition :
                \begin{emphBox}
                    Soit $M = (\Sigma, Q, I, F, \delta)$ un AFND, et $u \in \Sigma^*$

                    Alors $u \in L(M) \ssi$ il existe un chemin $q_0 \cdots q_n$ dans le graphe de $M$ avec $q_0 \in I\ |\ qu \in F$, et la concaténation des étiquettes sur ce chemin est $u$.
                \end{emphBox}

                \vspace{6pt}
                
                \begin{proof}
                    \boxed{\Leftarrow} On montre que $\forall i \in \nset 0 n,\ q_i \in \delta(q_0, u_1 \cdots u_i)$ (on note $u = u_1 \cdots u_i$)

                    $-$ $i = 0$ : $\delta(q_0, u_1 \cdots u_0) = \delta(q_0, \varepsilon) = \set{q_0} \ni q_0$

                    $-$ Hérédité : si $i \in \nset 1 {n - 1}\ |\ q_i \in \delta(q_0, u_1 \cdots u_i)$, alors
                    \[
                        \bigcup_{q \in \delta(q_0, u_1 \cdots u_i)} \delta(q, u_{i + 1}) \supseteq \delta(q_i, u_{i + 1}) \ni q_{i + 1}
                    \]
                    (car $q_i \overset{u_{i + 1}}\longrightarrow q_{i + 1}$)

                    Finalement, $q_n \in F \cap \delta(\underbrace{q_0}_{\in I}, \underbrace{u_1 \cdots u_n}_u)$, donc $u \in L(M)$.

                    \vspace{12pt}
                    
                    \boxed{\Rightarrow} $\exists q_0 \in I,\ \exists q_n \in F\ |\ q_n \in \delta(q_0, u)$.

                    On montre qu'il existe, $\forall i \in \nset 0 n$ un chemin $q_i \cdots q_n$ étiqueté par $u_{i + 1} \cdots u_n$ avec $q_i \in \delta(q_0, u_1 \cdots u_i)$.

                    \vspace{6pt}
                    
                    $-$ $i = n$, $q_n \in \delta(q_0, u_1 \cdots u_n)$, et le chemin vide étiqueté par $\Sigma = u_{n + 1}u_n$.

                    \vspace{6pt}
                    
                    $-$ Hérédité : si $i \in \nset 1 n\ |\ \exists q_i \cdots q_n$ un chemin étiqueté par $u_{i + 1} \cdots u_n$ avec $q_i \in \delta(q_0, u_1 \cdots u_i)$, alors

                    \[
                        q_i \in \delta(q_0, u_1 \cdots u_i) = \bigcup_{q \in \delta(q_0, u_1 \cdots u_{i - 1})} \delta(q, u_i)
                    \]

                    Donc $\exists q_{i - 1} \in \delta(q_0, u_1 \cdots u_{i - 1})\ |\ q_i \in \delta(q_{i - 1}, u_i)$.

                    Le chemin $q_{i - 1}, q_n$ est étiqueté par $u_{i} \cdots u_n$.

                    Finalement, on a construit un chemin $q_0 \cdots q_n$ convenable.
                \end{proof}
            \end{indt}

            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Détermination}}
                $\bullet$ Théorème :
                \begin{emphBox}
                    Soit $\Sigma$ un alphabet, et $L$ un langage sur $\Sigma$.

                    \[
                        L \in \Rec \Sigma \ssi
                        \exists M = (\Sigma, Q, I, F, \delta)\ \text{un AFND}\ |\ L(M) = L
                    \]
                \end{emphBox}

                \vspace{12pt}
                
                \begin{proof}
                    \boxed{\Rightarrow} Si $M = (\Sigma, Q, q_0, F, \delta)$ est un AFD tel que $L = L(M)$, on construit $M' = (\Sigma, Q, \set{q_0}, F, \delta')$, où $\forall q \in Q, \forall a \in \Sigma$,
                    \[
                        \delta'(q, a) =
                        \begin{cases}
                            \set{\delta(q, a)}
                            & \text{si}\ (q, a) \in \mathrm{dom}(\delta)
                            \\
                            \varnothing
                            & \text{sinon}
                        \end{cases}
                    \]

                    Les graphes de $M$ est $M'$ sont identiques, donc $L = L(M) = L(M')$.

                    \vspace{12pt}
                    
                    \boxed{\Leftarrow} On construit l'automate des parties
                    \[
                        M' = (\Sigma, \mathcal P(Q), I, F', \delta')
                    \]
                    où
                    \[
                        \begin{array}{l}
                            F' = \set{E \in \mathcal P(Q) \ |\ E \cap F \neq \varnothing}
                            \\
                            \forall E \in \mathcal P(Q), \forall a \in \Sigma,\
                            \delta'(E, a) = \displaystyle \bigcup_{q \in E} \delta(q, a)
                        \end{array}
                    \]

                    $M'$ est un AFD.

                    On montre par récurrence que
                    \[
                        \forall (n, u) \in \N \times \Sigma^*\ |\ \abs u = n,\
                        \delta'(I, u) = \bigcup_{q_0 \in I} \delta(q_0, u)
                    \]

                    $-$ $n = 0$ : $u = \varepsilon$ est le seul mot possible, et
                    \[
                        \delta'(I, \varepsilon) = I = \bigcup_{q_0 \in I} \set{q_0} = \bigcup_{q_0 \in I} \delta(q_0, \varepsilon)
                    \]

                    $-$ Hérédité : Soit $n \in \N\ |\ \forall u \in \Sigma^*\ |\ n = \abs u,\ \delta'(I, u) = \displaystyle \bigcup_{q_0 \in I} \delta (q_0, u)$.

                    Soit $u \in \Sigma^*\ |\ \abs u = n + 1$. Alors $u$ s'écrit $u = va$ avec $v \in \Sigma^*, a \in \Sigma\ |\ \abs v = n$.

                    \[
                        \begin{array}{rcl}
                            \delta'(I, u)
                            &=& \delta'(I, va)
                            \vspace{3pt}
                            \\
                            &=& \displaystyle \bigcup_{q \in \delta'(I, v)} \delta'(q, a)
                            \vspace{3pt}
                            \\
                            &=& \displaystyle \bigcup_{q_0 \in I} \bigcup_{q \in \delta(q_0, u)} \delta(q, a)
                            \vspace{3pt}
                            \\
                            &=& \displaystyle \bigcup_{q_0 \in I} \delta(q_0, \varepsilon)
                        \end{array}
                    \]

                    Soit $u \in \Sigma^*$.

                    \[
                        \begin{array}{rcl}
                            u \in L
                            &\ssi& u \in L(M)
                            \\
                            &\ssi& \displaystyle \bigcup_{q_0 \in I} \delta(q_0, u) \cap F \neq \varnothing
                            \\
                            &\ssi& \delta'(I, u) \cap F \neq \varnothing
                            \\
                            &\ssi& \delta'(I, u) \in F'
                            \\
                            &\ssi& u \in L(M')
                        \end{array}
                    \]
                \end{proof}

                \vspace{12pt}
                
                $\bullet$ Remarque : l'automate des parties est complet et possède un nombre d'états exponentiel en le nombre d'états de l'AFND associé. On peut réduire ce nombre d'états en ne considérant que les ensembles d'états de l'AFND qui sont accessibles depuis $I$.
                L'algorithme de détermination accessible s'exprime ainsi :

                \vspace{6pt}
                
                \begin{indalgo}{}
                    $E \gets \set I$\;

                    \While{$\exists P \in E$ pas encore traité}{
                        $\forall a \in \Sigma$, construire $\delta'(P, a)$ et l'ajouter à $E$\;
                    }
                \end{indalgo}

                \vspace{12pt}
                
                Exemple : $L = (a | b)^*baa$ est reconnu par l'AFND

                \begin{center}
                    \begin{tikzpicture}
                        \node (0) at (0, 0) [state, initial, initial text={}] {$q_0$};
                        \node (1) at (2, 0) [state] {$q_1$};
                        \node (2) at (4, 0) [state] {$q_2$};
                        \node (3) at (6, 0) [state, accepting] {$q_3$};

                        \draw[->] (0) to node [above] {$b$} (1);
                        \draw[->] (1) to node [above] {$a$} (2);
                        \draw[->] (2) to node [above] {$a$} (3);

                        \draw[->] (0) to [out=45, in=90, looseness=3] node [above right] {$a, b$} (0);
                    \end{tikzpicture}
                \end{center}

                \[
                    \begin{array}{lllll}
                        & \set{q_0} & \set{q_0, q_1} & \set{q_0, q_2} & \set{q_0, q_3}
                        \\
                        a & \set{q_0} & \set{q_0, q_2} & \set{q_0, q_3} & \set{q_0}
                        \\
                        b & \set{q_0, q_1} & \set{q_0, q_1} & \set{q_0, q_1} & \set{q_0, q_1}
                    \end{array}
                \]

                L'AFD obtenu est :

                \begin{center}
                    \begin{tikzpicture}[scale=1.5]
                        \node (0) at (0, 0) [state, initial, initial text={}] {$\set{q_0}$};
                        \node (1) at (2, 0) [state] {$\set{q_0, q_1}$};
                        \node (2) at (0, -2) [state] {$\set{q_1, q_3}$};
                        \node (3) at (2, -2) [state] {$\set{q_1, q_2}$};

                        \draw[->] (0) to node [above] {$b$} (1);
                        \draw[->] (2) to node [left] {$a$} (0);
                        \draw[->] (2) to node [above left] {$b$} (1);
                        \draw[->] (3) to node [below] {$a$} (2);

                        \draw[->] (1) to [out=-110, in=110] node [left] {$a$} (3);
                        \draw[->] (3) to [out=70, in=-70] node [right] {$b$} (1);

                        \draw[->] (1) to [out=45, in=90, looseness=3] node [above right] {$b$} (1);
                        \draw[->] (0) to [out=45, in=90, looseness=3] node [above right] {$a$} (0);
                    \end{tikzpicture}
                \end{center}

                \boxed{\rm Exo} le langage $(a|b)^*a(a|b)^n$ est reconnu par un AFND à $n + 2$ états mais un AFD reconnaissant ce langage a au moins $2^{n + 1}$ états.
            \end{indt}

            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Propriétés de clôture sur $\Rec \Sigma$}}
                $\bullet$ Clôture par complémentation : Soit $L \in \Rec \Sigma$.
                Alors
                \[
                    \Sigma^* \setminus L \in \Rec \Sigma
                \]

                \begin{proof}
                    $\exists M = (\Sigma, Q, q_0, F, \delta)$ un AFD complet tel que $L = L(M)$.

                    On considère $M' = (\Sigma, Q, q_0, Q \setminus F, \delta)$.

                    \(
                        \begin{array}{rcll}
                            u \in L(M')
                            &\ssi& \delta(q_0, u) \in Q \setminus F
                            \\
                            &\ssi& \delta(q_0, u) \notin F
                            & \text{car}\ (q_0, u)\  \text{existe car $M$ est complet}
                            \\
                            &\ssi& u \notin L(M)
                            \\
                            &\ssi& u \in \Sigma^* \setminus L
                        \end{array}
                    \)

                \end{proof}

                \vspace{12pt}
                
                $\bullet$ Clôture par union : Soient $L_1, L_2 \in \Rec \Sigma$.

                Alors :
                \[
                    L_1 \cup L_2 \in \Rec \Sigma
                \]

                \begin{proof}
                    Idée : on lit le mot dans les deux automates en parallèle et on accepte si l'un des deux accepte.

                    \[
                        \forall i \in \set{1, 2},\ \exists M_i = (\Sigma, Q_i, I_i, F_i, \delta_i)\ |\ L(M_i) = L_i
                    \]

                    On construit
                    \[
                        M = \lr{\Sigma,\ Q_1 \uplus Q_2,\ I_1 \uplus I_2,\ F_1 \uplus F_2,\ \delta}
                    \]

                    où $\forall q \in Q_1 \uplus Q_2,\ \forall a \in \Sigma,$
                    \[
                        \delta(q, a) =
                        \begin{cases}
                            \delta_1(q, a)
                            & \text{si}\ q \in Q_1
                            \\
                            \delta_2(q, a)
                            & \text{si}\ q \in Q_2
                        \end{cases}
                    \]

                    \boxed{\rm Exo} $L(M) = L_1 \cup L_2$
                \end{proof}

                \vspace{12pt}
                
                $\bullet$ Clôture par intersection :
                Soient $L_1, L_2 \in \Rec \Sigma$.

                Alors
                \[
                    L_1 \cap L_2 \in \Rec \Sigma
                \]

                \begin{proof}
                    On a :
                    \[
                        \forall i \in \set{1, 2},\ \exists M_i = (\Sigma, Q_i, I_i, F_i, \delta_i)\ |\ L(M_i) = L_i
                    \]

                    On construit l'automate produit $M = (\Sigma, Q_1 \times Q_2, I_1 \times I_2, F_1 \times F_2, \delta)$

                    où $\forall q_1 \in Q_1,\ \forall q_2 \in Q_2,\ \forall a \in \Sigma,\ \delta((q_1, q_2), a) = \delta_1(q_1, a) \times \delta_2(q_2, a)$

                    \boxed{\rm Exo} $L(M) = L(M_1) \cap L(M_2)$
                \end{proof}

                \vspace{12pt}
                
                $\bullet$ Clôture par concaténation : Soient $L_1, L_2 \in \Rec \Sigma$.

                Alors :
                \[
                    L_1 L_2 \in \Rec \Sigma
                \]

                \begin{proof}
                    Idée : on met bout à bout les automates en passant du premier au second de manière déterministe.

                    \[
                        \forall i \in \set{1, 2},\ \exists M_i = (\Sigma, Q_i, q_i, F_i, \delta_i)\ |\ L(M_i) = L_i
                    \]

                    On suppose $M_1$ et $M_2$ complets et $M_2$ standard.

                    On construit $M = \lr{\Sigma, Q_1 \cup Q_2 \setminus \set{q_2}, \set{q_1}, F, \delta}$, où :
                    \[
                        F =
                        \begin{cases}
                            F_2
                            & \text{si}\ q_2 \notin F_2
                            \\
                            F_1 \cup F_2 \setminus \set{q_2}
                            & \text{sinon}
                        \end{cases}
                    \]

                    et
                    \[
                        \forall (q, a) \in \lr{Q_1 \cup Q_2 \setminus \set{q_2}} \times \Sigma,\
                        \delta(q, a) =
                        \begin{cases}
                            \set{\delta_1(q, a)}
                            & \text{si}\ q \in Q_1 \setminus F_1
                            \\
                            \set{\delta_2(q, a)}
                            & \text{si}\ q \in Q_2 \setminus \set{q_2}
                            \\
                            \set{\delta_1(q, a), \delta_2(q_2, a)}
                            & \text{sinon}
                        \end{cases}
                    \]

                    \boxed{\rm Exo} $L(M) = L_1 L_2$
                \end{proof}
            \end{indt}
        \end{indt}
    \end{indt}
    
\end{document}
%--------------------------------------------End
