\documentclass[a4paper, 12pt, twoside]{article}


%------------------------------------------------------------------------
%
% Author                :   Lasercata
% Last modification     :   2022.05.09
%
%------------------------------------------------------------------------


%------ini
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[french]{babel}
%\usepackage[english]{babel}


%------geometry
\usepackage[textheight=700pt, textwidth=500pt]{geometry}


%------color
\usepackage{xcolor}
\definecolor{ff4500}{HTML}{ff4500}
\definecolor{00f}{HTML}{0000ff}
\definecolor{0ff}{HTML}{00ffff}
\definecolor{656565}{HTML}{656565}

\renewcommand{\emph}{\textcolor{ff4500}}
\renewcommand{\em}{\color{ff4500}}

\newcommand{\strong}[1]{\textcolor{ff4500}{\bf #1}}
\newcommand{\st}{\color{ff4500}\bf}


%------Code highlighting
%---listings
\usepackage{listings}

\definecolor{cbg}{HTML}{272822}
\definecolor{cfg}{HTML}{ececec}
\definecolor{ccomment}{HTML}{686c58}
\definecolor{ckw}{HTML}{f92672}
\definecolor{cstring}{HTML}{e6db72}
\definecolor{cstringlight}{HTML}{98980f}
\definecolor{lightwhite}{HTML}{fafafa}

\lstdefinestyle{DarkCodeStyle}{
    backgroundcolor=\color{cbg},
    commentstyle=\itshape\color{ccomment},
    keywordstyle=\color{ckw},
    numberstyle=\tiny\color{cbg},
    stringstyle=\color{cstring},
    basicstyle=\ttfamily\footnotesize\color{cfg},
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    keepspaces=true,
    numbers=left,
    numbersep=5pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=4,
    xleftmargin=\leftskip
}

\lstdefinestyle{LightCodeStyle}{
    backgroundcolor=\color{lightwhite},
    commentstyle=\itshape\color{ccomment},
    keywordstyle=\color{ckw},
    numberstyle=\tiny\color{cbg},
    stringstyle=\color{cstringlight},
    basicstyle=\ttfamily\footnotesize\color{cbg},
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    keepspaces=true,
    numbers=left,
    numbersep=10pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=4,
    frame=L,
    xleftmargin=\leftskip
}

%\lstset{style=DarkCodeStyle}
\lstset{style=LightCodeStyle}
%Usage : \begin{lstlisting}[language=Caml] ... \end{lstlisting}

%---tcolorbox
\usepackage[many]{tcolorbox}
\DeclareTColorBox{pseudocode}{O{black}O{lightwhite}}{
    breakable,
    outer arc=0pt,
    arc=0pt,
    top=0pt,
    toprule=-.5pt,
    right=0pt,
    rightrule=-.5pt,
    bottom=0pt,
    bottomrule=-.5pt,
    colframe=#1,
    colback=#2,
    enlarge left by=10pt,
    width=\linewidth-\leftskip-10pt,
}


%-------make the table of content clickable
\usepackage{hyperref}
\hypersetup{
    colorlinks,
    citecolor=black,
    filecolor=black,
    linkcolor=black,
    urlcolor=black
}
%Uncomment this and comment above for dark mode
% \hypersetup{
%     colorlinks,
%     citecolor=white,
%     filecolor=white,
%     linkcolor=white,
%     urlcolor=white
% }


%------pictures
\usepackage{graphicx}
%\usepackage{wrapfig}

\usepackage{tikz}
\usetikzlibrary{shapes.geometric}


%------tabular
%\usepackage{color}
%\usepackage{colortbl}
%\usepackage{multirow}


%------Physics
%---Packages
%\usepackage[version=4]{mhchem} %$\ce{NO4^2-}$

%---Commands
\newcommand{\link}[2]{\mathrm{#1} \! - \! \mathrm{#2}}
\newcommand{\pt}[1]{\cdot 10^{#1}} % Power of ten
\newcommand{\dt}[2][t]{\dfrac{\mathrm d #2}{\mathrm d #1}} % Derivative


%------math
%---Packages
%\usepackage{textcomp}
%\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{mathtools} % For abs
\usepackage{stmaryrd} %for \llbracket and \rrbracket
\usepackage{mathrsfs} %for \mathscr{x} (different from \mathcal{x})

%---Commands
%-Sets
\newcommand{\N}{\mathbb{N}} %set N
\newcommand{\Z}{\mathbb{Z}} %set Z
\newcommand{\Q}{\mathbb{Q}} %set Q
\newcommand{\R}{\mathbb{R}} %set R
\newcommand{\C}{\mathbb{C}} %set C
\newcommand{\U}{\mathbb{U}} %set U
\newcommand{\seg}[2]{\left[ #1\ ;\ #2 \right]}
\newcommand{\nset}[2]{\left\llbracket #1\ ;\ #2 \right\rrbracket}

%-Exponantial / complexs
\newcommand{\e}{\mathrm{e}}
\newcommand{\cj}[1]{\overline{#1}} %overline for the conjugate.

%-Vectors
\newcommand{\vect}{\overrightarrow}
\newcommand{\veco}[3]{\displaystyle \vect{#1}\binom{#2}{#3}} %vector + coord

%-Limits
\newcommand{\lm}[2][{}]{\lim\limits_{\substack{#2 \\ #1}}} %$\lm{x \to a} f$ or $\lm[x < a]{x \to a} f$
\newcommand{\Lm}[3][{}]{\lm[#1]{#2} \left( #3 \right)} %$\Lm{x \to a}{f}$ or $\Lm[x < a]{x \to a}{f}$
\newcommand{\tendsto}[1]{\xrightarrow[#1]{}}

%-Integral
\newcommand{\dint}[4][x]{\displaystyle \int_{#2}^{#3} #4 \mathrm{d} #1} %$\dint{a}{b}{f(x)}$ or $\dint[t]{a}{b}{f(t)}$

%-left right
\newcommand{\lr}[1]{\left( #1 \right)}
\newcommand{\lrb}[1]{\left[ #1 \right]}
\newcommand{\set}[1]{\left\{ #1 \right\}}
\newcommand{\abs}[1]{\left\lvert #1 \right\rvert}
\newcommand{\ceil}[1]{\left\lceil #1 \right\rceil}
\newcommand{\floor}[1]{\left\lfloor #1 \right\rfloor}
\newcommand{\lrangle}[1]{\left\langle #1 \right\rangle}

%-Others
\newcommand{\para}{\ /\!/\ } %//
\newcommand{\ssi}{\ \Leftrightarrow \ }
\newcommand{\eqsys}[2]{\begin{cases} #1 \\ #2 \end{cases}}

\newcommand{\med}[2]{\mathrm{med} \left[ #1\ ;\ #2 \right]}  %$\med{A}{B} -> med[A ; B]$
\newcommand{\Circ}[2]{\mathscr{C}_{#1, #2}}

\renewcommand{\le}{\leqslant}
\renewcommand{\ge}{\geqslant}


%------commands
%---to quote french text
\newcommand{\simplecit}[1]{\guillemotleft$\;$#1$\;$\guillemotright}
\newcommand{\cit}[1]{\simplecit{\textcolor{656565}{#1}}}
\newcommand{\quo}[1]{\cit{\it #1}}

%---to indent
\newcommand{\ind}[1][20pt]{\advance\leftskip + #1}
\newcommand{\deind}[1][20pt]{\advance\leftskip - #1}

%---to indent a text
\newcommand{\indented}[2][20pt]{\par \ind[#1] #2 \par \deind[#1]}
\newenvironment{indt}[2][20pt]{#2 \par \ind[#1]}{\par \deind} %Titled indented env

%---title
\newcommand{\thetitle}[2]{\begin{center}\textbf{{\LARGE \underline{\emph{#1} :}} {\Large #2}}\end{center}}


%------Sections
% To change section numbering :
% \renewcommand\thesection{\Roman{section}}
% \renewcommand\thesubsection{\arabic{subsection}}
% \renewcommand\thesubsubsection{\aleph{subsection}}

% To start numbering from 0
% \setcounter{section}{-1}


%------page style
\usepackage{fancyhdr}
\usepackage{lastpage}

\setlength{\headheight}{18pt}
\setlength{\footskip}{50pt}

\pagestyle{fancy}
\fancyhf{}
\fancyhead[LE, RO]{\textit{\textcolor{black}{\today}}}
\fancyhead[RE, LO]{\large{\textsl{\emph{\texttt{\jobname}}}}}

\fancyfoot[RO, LE]{\textit{\texttt{\textcolor{black}{Page \thepage /}\pageref{LastPage}}}} %Change 'black' to 'white' for dark mode
\fancyfoot[LO, RE]{\includegraphics[scale=0.12]{/home/lasercata/Pictures/1.images_profil/logo/mieux/lasercata_logo_fly_fond_blanc.png}}

% For dark mode :
%/home/lasercata/Pictures/1.images_profil/logo/mieux/lasercata_logo_fly.png

\author{Lasercata}
\date{\today}

%------init lengths
\setlength{\parindent}{0pt} %To avoid using \noindent everywhere.
\setlength{\parskip}{3pt}


%---------------------------------Begin Document
\begin{document}
    
    %For dark mode :
    % \pagecolor{black}
    % \color{white}
    
    \thetitle{Chapitre 9}{Bases de données}
    
    \tableofcontents
    \newpage
    
    
    \begin{indt}{\section{Concepts élémentaires}}
        
        \begin{indt}{\subsection{Introduction aux bases de données}}
            \begin{indt}{\subsubsection{Introduction}}
                De nombreuses applications informatiques manipulent de grandes quantités de données qui doivent être organisées et stockées de sorte qu'il est possible de les traiter efficacement pour en ajouter, en retirer, ou en extraire de l'information. Ce traitement doit pouvoir se faire de manière concurrente tout en préservant l'intégrité des données.
            \end{indt}
            
            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Systèmes de gestion de bases de données (SGBD) et paradigme logique}}
                Préserver l'intégrité des données est une tâche complexe dans un contexte d'accès concurrents, donc le traitement des données sera confié à un outil appelé SGBD dont le rôle est de recevoir les requêtes des utilisateurs (modification des données ou extraction d'information à partir de ces données) et de les traduire en des opérations effectuées sur la base de données. C'est au SGBD de garantir la cohérence des données au fur et à mesure des opérations réalisées. Les requêtes prennent en général la forme d'une description du résultat attendu sans indication sur la manière de calculer. C'est le SGBD qui implémente la recherche du résultat.
                
                C'est le principe du \emph{paradigme logique} : un programme est une description des propriétés que doit satisfaire le résultat. Un résultat est un jeu de paramètres qui satisfait les propriétés. Il n'y a aucune indication sur la manière de calculer les résultats.
                
                Pour que cela fonctionne, la plupart des SGBD s'appuient sur un modèle introduit dans les années 1970, appelé modèle relationnel.
            \end{indt}
            
            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Le modèle relationnel}}
                $\bullet$ Le modèle relationnel est une modèle mathématique basé sur la théorie des ensembles et la logique des prédicats, et qui présente les bases de données comme des objets qui définissent des relations entre les blocs d'information. C'est un modèle abstrait qui s'exprime indépendamment des implémentations possibles et qui couvre donc de nombreux SGBD.
                
                \vspace{12pt}
                
                $\bullet$ Dans ce modèle, une base de données est vue comme un ensemble de relations. Ces relations sont aussi appelées \textit{tables} car on peut les représenter par des tableaux à double entrée dont les colonnes correspondent à un type d'information particulier. Ces colonnes sont appelées les \textit{attributs} de la relation.
                
                \vspace{6pt}
                
                Exemple : dans le système d'information d'une bibliothèque, on peut avoir une table Document dont les attributs sont le titre, l'auteur, le genre, la date de parution, le nombre de pages, ...
                
                \vspace{12pt}
                
                $\bullet$ Chaque attribut est associé à un domaine qui correspond à l'ensemble des valeurs possibles par l'attribut. Le domaine permet de choisir un type pour implémenter concrètement la base de données.
                
                \vspace{6pt}
                
                \'Etant donné une relation $R$ dont les attributs sont $A_1, \ldots, A_n$ associés aux domaines $D_1, \ldots, D_n$, on appelle \textit{schéma relationnel} de $R$ l'association des attributs et des domaines notée
                    \[ R(A_1 : D_1, \ldots, A_n : D_n) \]
                
                \begin{indt}{Exemple : pour la table Document :}
                    $-$ Le titre et l'auteur sont des données textuelles ;
                    
                    $-$ Le genre est tirée d'une énumération finie (roman, poésie, théâtre, ...) ;
                    
                    $-$ La date de parution est une date ;
                    
                    $-$ Le nombre de pages est un entier.
                \end{indt}
                
                \vspace{6pt}
                
                D'où le schéma relationnel :
                
                Document(titre : texte, auteur : texte, genre : enum(roman, ...), date de parution : date, nombre de pages : entier)
                
                \vspace{6pt}
                
                Le domaine ``texte'' peut être par exemple associé au type \texttt{string} des chaînes de caractères et le domaine entier au type \texttt{int}.
                
                \vspace{12pt}
                
                $\bullet$ Les lignes d'une relation de schéma $R(A_1 : D_1, \ldots, A_n : D_n)$ correspondent aux éléments de la relation $R$, qui est un sous ensemble de $\displaystyle \prod_{k = 1}^n D_k$. On appelle donc ces éléments des tuples ou des enregistrements.
                
                \vspace{6pt}
                
                Exemple pour la table Document :
                \begin{center}
                    \begin{tabular}{|c|c|c|c|c|}
                        \hline
                        Titre
                        & Auteur
                        & Genre
                        & Date de parution
                        & Nombre de pages
                        \\
                        \hline
                        \textit{La cousine Bette}
                        & Honoré de Balzac
                        & Roman
                        & 1846
                        & 240
                        \\
                        \textit{De la guerre}
                        & Carl von Clausewitz
                        & Traité
                        & 1832
                        & 240
                        \\
                        \textit{Cyrano de Bergerac}
                        & Edmond Rostand
                        & Théâtre
                        & 1857
                        & 280
                        \\
                        \hline
                    \end{tabular}
                \end{center}
                
                \vspace{12pt}
                
                Remarque : certains enregistrements peuvent coïncider pour certains attributs et on veut une manière efficace de les distinguer.
                
                \vspace{12pt}
                
                $\bullet$ On appelle \textit{clé candidate} un ensemble minimal (pour l'inclusion) d'attributs permettant de caractériser de manière unique chaque enregistrement, \textit{i.e} tel qu'il n'existe pas deux enregistrements qui coïncident sur tous les attributs de la clé.
                
                \vspace{6pt}
                
                Exemple : pour la table Document, \{titre, auteur\} devrait convenir.
                
                \vspace{6pt}
                
                Il peut y avoir plusieurs clés candidates et on doit en choisir une, appelée \textit{clé primaire}. On souligne dans le schéma relationnel les attributs de la clé primaire pour les repérer efficacement.
                
                Remarque : on choisit souvent d'ajouter un attribut entier pour numéroter les enregistrements, que l'on choisit comme clé primaire.
                
                \vspace{12pt}
                
                $\bullet$ Dans une relation $R$, on appelle \textit{clé étrangère} un ensemble d'attributs qui constitue une clé candidate (souvent primaire) d'une autre relation.
                
                \vspace{6pt}
                
                Exemple : dans une table Emprunts décrivant les emprunts de la bibliothèque, on intègre la clé de la table Document pour identifier les documents empruntés.
            \end{indt}
            
            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Algèbre relationnelle}}
                L'algèbre relationnelle est une théorie mathématique qui décrit des opérations que l'on peut réaliser sur une base de données du point de vue du modèle relationnel. Les propriétés qui découlent de cette théorie définissent un fondement rigoureux aux implémentations de SGBD en justifiant les optimisations des requêtes des utilisateurs. Cette théorie des H.P, mais nous l'étudierons \textit{via} le langage de requêtes SQL (Structured Query Language).
            \end{indt}
        \end{indt}
        
        \begin{indt}{\subsection{Le langage SQL : requêtes élémentaires}}
            \begin{indt}{\subsubsection{Gestion du contexte}}
                $-$ Choix de la base de données : \texttt{USE <nom\_base>;}
                
                $-$ Obtention du schéma relationnel d'une table : \texttt{DESCRIBE <nom\_table>;}
                
                Exemple :
                
                \begin{lstlisting}[language=SQL, xleftmargin=80pt]
USE bibliotheque;
DESCRIBE Document;\end{lstlisting}
                
                Les opérations de création / suppression / modification de bases de données / de tables sont H.P.
            \end{indt}
            
            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Opération de projection}}
                Pour visualiser le contenu d'une table, on utilise la requête \texttt{SELECT * FROM <nom\_table>;}
                
                C'est une cas particulier de l'opération de projection qui permet de construire une table ne contenant que les valeurs des tuples que pour certains attributs.
                
                Attention, la table construite par une requête est éphémère.
                
                Syntaxe :
                \texttt{SELECT <attribut$_1$>, ..., <attribut$_n$> FROM <nom\_table>;}
                
                Exemple :
                \begin{lstlisting}[language=SQL, xleftmargin=80pt]
SELECT titre, date_de_parution FROM Document;\end{lstlisting}
                
                Remarque : cette requête peut créer une table contenant des doublons qui sont conservés par défaut. On utilise le mot-clé \texttt{DISTINCT} pour éliminer les doublons.
                
                Exemple :
                \begin{lstlisting}[language=SQL, xleftmargin=80pt]
SELECT DISTINCT titre, date_de_parution FROM Document;\end{lstlisting}
               
               Les enregistrements du résultat d'une projection sont a \textit{priori} rangés dans le même ordre que dans la table initiale. On peut choisir de les réordonner en utilisant le mot-clé \texttt{ORDER BY} suivi d'une liste d'attributs.
               
               L'ordre associé à cette liste est l'ordre croissant lexicographique.
               
               Exemple :
               
                \begin{lstlisting}[language=SQL, xleftmargin=80pt]
SELECT * FROM Document
ORDER BY auteur, date_de_parution;\end{lstlisting}
                
                Pour utiliser l'ordre décroissant selon l'un des attributs, on utilise le mot-clé \texttt{DESC} après le nom de l'attribut.
                
                Exemple :
                
                \begin{lstlisting}[language=SQL, xleftmargin=80pt]
SELECT * FROM Document
ORDER BY date_de_parution DESC;\end{lstlisting}
                
                Attention, \texttt{DESC} ne porte que sur un seul attribut (le répéter si besoin).
                
                \vspace{12pt}
                
                Il est aussi possible de renommer les attributs du résultat d'une projection, ce qui peut être nécessaire dans des opérations plus complexes faisant intervenir des sous-requêtes ou plusieurs tables. On utilise pour cela le mot-clé \texttt{AS}.
                
                Exemple :
                
                \begin{lstlisting}[language=SQL, xleftmargin=80pt]
SELECT titre, auteur, date_de_parution AS date
FROM Document;\end{lstlisting}
                
                On peut combiner tout cela :
                
                \begin{lstlisting}[language=SQL, xleftmargin=80pt]
SELECT titre, date_de_parution AS date
FROM Document
ORDER BY date DESC, titre;\end{lstlisting}
            \end{indt}

            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Opération de sélection}}
                On peut ne conserver que les enregistrements qui satisfont une condition donnée \textit{via} l'opération de sélection, introduite par le mot-clé \texttt{WHERE}.

                Exemple :
                \begin{lstlisting}[language=SQL, xleftmargin=80pt]
SELECT * FROM Document
WHERE auteur = 'Edmond Rostand';\end{lstlisting}
                
                Les opérateurs de comparaison au programme sont : \texttt{=, <>, <, >, <=, >=}

                Attention, les enregistrements ne fournissent pas forcément une valeur pour chaque attribut. Les attributs sans valeurs prennent la valeur spéciale \texttt{NULL}. On ne peut pas vérifier si un attribut a la valeur \texttt{NULL} avec les opérateurs ci-dessus : on utilise les opérateurs \texttt{IS NULL} et \texttt{IS NOT NULL}

                Exemple :

                \begin{lstlisting}[language=SQL, xleftmargin=80pt]
SELECT * FROM Document
WHERE date_de_parution IS NULL;\end{lstlisting}

                On peut combiner plusieurs conditions grâce aux connecteurs logiques : \texttt{AND, OR, NOT}.

                Exemple :

                \begin{lstlisting}[language=SQL, xleftmargin=80pt]
SELECT * FROM Document
WHERE NOT (date_de_parution >= 2000 AND nombre_de_page < 200);\end{lstlisting}

                Remarque : On peut combiner sélection et projection

                On peut aussi fixer un nombre maximal d'enregistrements pour le résultat : le SGBD choisira les premiers qu'il traite jusqu'à éventuellement atteindre la borne. On utilise le mot clé \texttt{LIMIT}

                Exemple : 10 ouvrages les + récents

                \begin{lstlisting}[language=SQL, xleftmargin=80pt]
SELECT * FROM Document
ORDER BY date_de_parution DESC
LIMIT 10;\end{lstlisting}

                On peut ajouter un décalage lors de l'usage de \texttt{LIMIT} grâce au mot-clé \texttt{OFFSET}.

                Exemple : dernier tiers du top 15 des auteurs ayant écrit les plus gros livres.

                \begin{lstlisting}[language=SQL, xleftmargin=80pt]
SELECT DISTINCT auteur FROM Document
ORDER BY nombre_de_pages DESC
LIMIT 5 OFFSET 10;\end{lstlisting}
            \end{indt}
        \end{indt}
        
    \end{indt}

    \vspace{12pt}
    
    \begin{indt}{\section{Conception de bases de données}}
        \begin{indt}{\subsection{Modèle entité-association}}
            \begin{indt}{\subsubsection{Introduction}}
                Le modèle \textit{entité-association}  est un modèle de la fin des années 1970 qui propose un formalisme pour décrire la structure des données en fonction des liens qu'elles entretiennent.

                On lui associe une représentation graphique permettant d'identifier facilement les deux concepts de base du modèle : les \textit{entités} et les \textit{associations}.
            \end{indt}

            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Entités}}
                Une entité est un objet donné pour lequel on dispose de données que l'on souhaite traiter.

                Exemple : moi, le livre d'Edmond Rostand intitulé \textit{Cyrano de Bergerac}, $\ldots$ 

                Les informations associées à une entité sont ses attributs. On réunit un ensemble d'entités ayant des caractéristiques communes dans un type d'entité que l'on appelle aussi par abus entités.

                Dans ce cadre, une entité concrète est appelée instance ou occurrence de l'entité.
            \end{indt}

            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Associations}}
                Une association exprime un lien entre plusieurs entités.

                Exemple : Edmond Rostand \emph{\it a écrit} le livre intitulé \textit{Cyrano de Bergerac}.

                Une association peut aussi avoir des attributs (ex : date d'écriture) et on fait également l'abus de langage qui consiste à appeler association un type d'association.

                \vspace{12pt}
                
                Représentation graphique : on dessine deux types de bloc (les entités et les associations) et on lie les blocs d'entité \textit{via} les blocs d'association qui expriment ces liens
                \begin{center}
                    \begin{tikzpicture}
                        \node (D) at (0, 0) [rectangle, draw] {
                            \begin{tabular}{c}
                                Document
                                \\
                                \hline
                                $-$ titre
                                \\
                                $-$ genre
                                \\
                                $-$ nb pages
                            \end{tabular}
                        };
                        \node (A) at (4, 0) [ellipse, draw] {
                            \begin{tabular}{c}
                                \'Ecriture
                                \\
                                \hline
                                $-$ Date
                            \end{tabular}
                        };
                        \node (P) at (8, 0) [rectangle, draw] {
                            \begin{tabular}{c}
                                Personne
                                \\
                                \hline
                                $-$ Num
                                \\
                                $-$ Prénom
                                \\
                                $-$ Date naissance
                                \\
                                $-$ ...
                            \end{tabular}
                        };

                        \draw (D) -- (A);
                        \draw (A) -- (P);
                    \end{tikzpicture}
                \end{center}

                On distingue les associations binaires (\textit{i.e} qui lient 2 entités) des associations $n$-aires. On peut toujours se limiter aux associations binaires en remplaçant une association $n$-aire par une nouvelle entité représentant l'association, liée aux $n$ entités par $n$ associations binaires.

                Exemple :

                \begin{center}
                    \begin{tikzpicture}
                        \node (P) at (0, 0) [rectangle, draw] {Personne};
                        \node (E) at (3, 0) [ellipse, draw] {Emprunt};
                        \node (D) at (3, -2) [rectangle, draw] {Document};
                        \node (B) at (6, 0) [rectangle, draw] {Bibliothèque};

                        \draw (P) -- (E);
                        \draw (B) -- (E);
                        \draw (D) -- (E);
                    \end{tikzpicture}
                \end{center}

                donne :

                \begin{center}
                    \begin{tikzpicture}
                        \node (P) at (0, 0) [rectangle, draw] {Personne};
                        \node (R) at (3, 0) [ellipse, draw] {Réalise};
                        \node (E) at (6, 0) [rectangle, draw] {Emprunt};
                        \node (C) at (6, -2) [ellipse, draw] {Concerne};
                        \node (L) at (9.4, 0) [ellipse, draw] {A lieux dans};
                        \node (D) at (6, -4) [rectangle, draw] {Document};
                        \node (B) at (13, 0) [rectangle, draw] {Bibliothèque};

                        \draw (P) -- (R) -- (E) -- (L) -- (B);
                        \draw (E) -- (C) -- (D);
                    \end{tikzpicture}
                \end{center}
            \end{indt}

            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Cardinalité d'une association}}
                Le lien entre une entité et une association peut être étiqueté par un couple $(p, q)$ représentant les nombres minimums et maximum de fois que l'entité peut apparaître dans une association de ce type : $q = *$  s'il n'y a pas de borne supérieure.

                Exemple :

                \begin{center}
                    \begin{tikzpicture}
                        \node (P) at (0, 0) [rectangle, draw] {Personne};
                        \node (E) at (3, 0) [ellipse, draw] {\'Ecriture};
                        \node (D) at (6, 0) [rectangle, draw] {Document};

                        \draw (P) to node [above] {$0, *$} (E); %up tag : 0, *
                        \draw (E) to node [above] {$1, *$} (D); %up tag : 1, *
                    \end{tikzpicture}
                \end{center}

                On appelle cette association une association $*-*$ car elle peut lier plusieurs entités à plusieurs autres.

                D'autres types d'association sont :

                $-$ Les associations $1-*$ : elles lient une entité à plusieurs autres.

                Exemple : une \oe uvre peut être tirée à plusieurs exemplaires mais un exemplaire n'est un tirage que d'une seule \oe uvre

                \begin{center}
                    \begin{tikzpicture}
                        \node (O) at (0, 0) [rectangle, draw] {\oe uvre};
                        \node (T) at (3, 0) [ellipse, draw] {Tirage};
                        \node (E) at (6, 0) [rectangle, draw] {Exemplaire};

                        \draw (O) -- node [above] {$1, *$} (T); % label up : 1, *
                        \draw (T) -- node [above] {$1, 1$} (E); %label : 1, 1
                    \end{tikzpicture}
                \end{center}

                $-$ Les associations $1-1$ : elles lient une entité à une seule autre.

                Exemple : chaque exemplaire d'une bibliothèque a une référence unique

                \begin{center}
                    \begin{tikzpicture}
                        \node (E) at (0, 0) [rectangle, draw] {Exemplaire};
                        \node (T) at (4, 0) [ellipse, draw] {Est référencé par};
                        \node (R) at (8, 0) [rectangle, draw] {Référence};

                        \draw (E) -- (T);
                        \draw (T) -- (R);
                    \end{tikzpicture}
                \end{center}

                Remarque : on peut souvent fusionner les entités impliquées dans une association $1-1$ sans introduire trop de redondance dans les données.

                Une association $*-*$ peut être scindée en deux associations $1-*$ \textit{via} l'introduction d'une nouvelle entité représentant l'association.

                Exemple :

                \begin{center}
                    \begin{tikzpicture}
                        \node (P) at (0, 0) [rectangle, draw] {Personne};
                        \node (E) at (4, 0) [ellipse, draw] {
                            \begin{tabular}{c}
                                \'Ecriture
                                \\
                                \hline
                                $-$ Date
                            \end{tabular}
                        };
                        \node (D) at (8, 0) [rectangle, draw] {Document};

                        \draw (P) -- node [above] {$0, *$} (E); % label up : 0, *
                        \draw (E) -- node [above] {$1, *$} (D); %label : 1, *
                    \end{tikzpicture}
                \end{center}

                donne :

                \begin{center}
                    \begin{tikzpicture}
                        \node (P) at (0, 0) [rectangle, draw] {Personne};
                        \node (p) at (3.5, 0) [ellipse, draw] {Participe à};
                        \node (E) at (7.5, 0) [rectangle, draw] {
                            \begin{tabular}{c}
                                Ecriture
                                \\
                                \hline
                                $-$ Date
                                \\
                                $-$ Auteur
                                \\
                                $-$ Ouvrage
                            \end{tabular}
                        };
                        \node (C) at (11.5, 0) [ellipse, draw] {Concerne};
                        \node (D) at (15, 0) [rectangle, draw] {Document};

                        \draw (P) -- node [above] {$0, *$} (p); % 0, *
                        \draw (p) -- node [above] {$1, 1$} (E); % 1, 1
                        \draw (E) -- node [above] {$1, 1$} (C); % 1, 1
                        \draw (C) -- node [above] {$1, *$} (D); % 1, *
                    \end{tikzpicture}
                \end{center}

                Remarque : les attributs de la nouvelle entité doivent permettre d'identifier les entités impliquées dans l'association : on utilise des clés étrangères dans le modèle relationnel associé à ce modèle.
            \end{indt}
        \end{indt}

        \vspace{12pt}
        
        \begin{indt}{\subsection{Passage du modèle entité-association au modèle relationnel}}
            \begin{indt}{\subsubsection{Idée}}
                On associe une relation à chaque  entité, avec les mêmes attributs, les associations expriment des liens entre les tables et introduisent donc des contraintes d'intégrité des données.

                $\bullet$ La décomposition d'une association $n$-aire ou en associations binaires se traduit en la création d'une nouvelle entité donc d'une nouvelle association.

                $\bullet$ La décomposition des associations binaires $*-*$ en deux associations $1-*$ se traduit aussi en la création d'une nouvelle table, dite de \textit{jonction}.

                $\bullet$ Après cela, il ne reste qu'à traiter les associations $1-1$  et $1-*$ .
            \end{indt}

            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Cas des associations $1-1$ et $1-*$}}
                \label{2.2.2}

                Ces types d'association impliquent que pour l'une des deux entités, chaque instance de l'entité ne peut être associée qu'à une unique instance de l'autre entité. Pour exprimer ce lien entre les tables correspondantes on ajoute une clé étrangère à la première table, faisant référence à l'unique enregistrement de la seconde table impliquée dans l'association. Les attributs de l'association seront aussi intégrés à la première table.


                Exemple :

                \begin{center}
                    \begin{tikzpicture}
                        \node (P) at (0, 0) [rectangle, draw] {
                            \begin{tabular}{c}
                                Personne
                                \\
                                \hline
                                $-$ Nom
                                \\
                                $-$ Prénom
                                \\
                                $-$ Date de naissance
                            \end{tabular}
                        };
                        \node (E) at (0, -3) [ellipse, draw] {
                            \begin{tabular}{c}
                                Écriture
                                \\
                                $-$ Date
                            \end{tabular}
                        };
                        \node (D) at (0, -6) [rectangle, draw] {
                            \begin{tabular}{c}
                                Document
                                \\
                                \hline
                                $-$ Titre
                                \\
                                $-$ Genre
                            \end{tabular}
                        };
                        \node (T) at (0, -9) [ellipse, draw] {
                            \begin{tabular}{c}
                                $-$ Date d'impression
                            \end{tabular}
                        };
                        \node (e) at (0, -12) [rectangle, draw] {
                            \begin{tabular}{c}
                                Exemplaire
                                \\
                                \hline
                                $-$ Numéro
                                \\
                                $-$ Imprimerie
                            \end{tabular}
                        };
                        
                        \draw (P) -- node [right] {$0, *$} (E); % 0, *
                        \draw (E) -- node [right] {$1, *$} (D); % 1, *
                        \draw (D) -- node [right] {$1, *$} (T); % 1, *
                        \draw (T) -- node [right] {$1, 1$} (e); % 1, 1
                    \end{tikzpicture}
                \end{center}

                \begin{indt}{Modèle relationnel associé : on utilise des identifiants numériques pour les clés primaires :}
                    Personne(\underline{id: entier}, nom: texte, prénom: texte, date de naissance: date)
                    
                    Document(\underline{id Doc: entier}, titre: texte, genre: enuml(...))
                    
                    Exemplaire(numéro: entier, imprimerie: texte, id Doc: entier, date d'impression: date)
                    
                    \'Ecriture(date: date, \underline{id Doc: entier, id: entier})
                \end{indt}
            \end{indt}
        \end{indt}
    \end{indt}

    \vspace{12pt}
    
    \begin{indt}{\section{Requêtes avancées}}
        \begin{indt}{\subsection{Opérations ensemblistes}}
            \begin{indt}{\subsubsection{Remarque}}
                On s'intéresse à des opérations qui prennent plusieurs tables en argument et qui produisent une nouvelle table.
            \end{indt}

            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Produit cartésien}}
                On construit le produit cartésien de deux relations vues comme des ensembles de tuples.

                Schéma relationnel : si on a deux relations $R(A_1: D_1, \ldots, A_n: D_n)$  et $R'(A_1': D_1', \ldots, A_n': D_n')$, alors
                \[
                    (R \times R')(A_1: D_1, \ldots, A_n: D_n, A_1': D_1', \ldots, A_n': D_n')
                \]
                de clé primaire l'union des clés primaires de $R$ et $R'$.

                Réalisation SQL : on sépare les tables par des virgules dans la clause \texttt{FROM}.

                Ex :
                \begin{lstlisting}[language=SQL, xleftmargin=80pt]
SELECT * FROM R, R';\end{lstlisting}

                Remarque : on peut faire des produits $n$-aires :

                \begin{lstlisting}[language=SQL, xleftmargin=80pt]
SELECT * FROM R1, R2, ..., Rn;\end{lstlisting}

                Exemple : auteur, titre et date d'écriture dans la BDD vue en \ref{2.2.2} (page \pageref{2.2.2}).

                \begin{lstlisting}[language=SQL, xleftmargin=80pt]
SELECT nom, prenom, titre, date
FROM Personne, Document, Ecriture
WHERE Personne.id = Ecriture.id AND Document.idDoc = Ecriture.idDoc;\end{lstlisting}

                Remarque : il existe une construction appelée jointure qui est plus adaptée à ce type de requête (\textit{cf} \ref{3.2}, page \pageref{3.2}).
            \end{indt}

            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Définition (relations \textit{union-compatibles})}}
                Deux relations sont \textit{union-compatibles} si elles ont le même nombre d'attributs et si les attributs de même position dans les deux relations ont même domaine.

                Intuition : même schéma au renommage des attributs et au choix de la clé primaire près.
            \end{indt}

            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Union}}
                L'union de deux relations union-compatibles est une relation de \textit{même schéma que la première} et dont les enregistrements sont ceux qui apparaissent dans au moins l'une des deux relations.

                Remarque : cela signifie que si les noms d'attributs sont différents pour deux relations, alors on conserve ceux de la première. De plus, les doublons sont supprimés.

                Réalisation SQL : on utilise le mot clé \texttt{UNION} entre deux requêtes qui produisent les tables dont on veut faire l'union.

                Attention : pas de \texttt{UNION} dans une clause \texttt{FROM}

                Exemple : 
                
                \begin{lstlisting}[language=SQL, xleftmargin=80pt]
SELECT ... UNION SELECT ... ;\end{lstlisting}

                Exemple : dates qui sont des dates d'écriture ou d'impression de documents.

                \begin{lstlisting}[language=SQL, xleftmargin=80pt]
SELECT date FROM Ecriture
UNION
SELECT date d impression FROM Exemplaire;\end{lstlisting}
            \end{indt}

            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Intersection}}
                L'intersection de deux relations union-compatibles est une relation de même schéma que la première dont les enregistrements sont les tuples qui apparaissent dans les deux relations.

                Réalisation SQL : on utilise le mot-clé \texttt{INTERSECT} de la même manière que \texttt{UNION}.

                Remarque : certains SGBD (comme MySQL) n'implémentent pas cette opération. Dans ce cas, il faut encoder cette opération avec des requêtes. On peut par exemple utiliser un produit cartésien.

                Exemple : Prénom qui sont aussi des titres d'\oe uvres.
                \begin{lstlisting}[language=SQL, xleftmargin=80pt]
SELECT prenom FROM Personne
INTERSECT
SELECT titre FROM Document;\end{lstlisting}

                \begin{lstlisting}[language=SQL, xleftmargin=80pt]
SELECT DISTINCT prenom FROM Personne, Document
WHERE prenom = titre;\end{lstlisting}

                Remarque : la clause \texttt{WHERE} contient autant de tests d'égalité qu'il y a d'attributs dans le résultat.
            \end{indt}

            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Différence}}
                La différence de deux relations union-compatibles est une relation de même schéma que la première relation dont les enregistrements sont les tuples qui apparaissent dans la première relation mais pas dans la seconde.

                Réalisation SQL : on utilise le mot-clé \texttt{EXCEPT} de la même manière que \texttt{UNION}.

                Remarque : certains SGBD n'implémentent pas cette opération, d'autres utilisent le mot-clé \texttt{MINUS} (qui est H.P).

                On peut encoder l'opération à l'aide de requêtes imbriquées (\textit{cf} \ref{3.3}, page \pageref{3.3}).

                \vspace{6pt}
                
                Exemple : noms qui ne sont pas des prénoms :

                \begin{lstlisting}[language=SQL, xleftmargin=80pt]
SELECT nom FROM Personne
EXCEPT
SELECT prenom FROM Personne;\end{lstlisting}

                \begin{lstlisting}[language=SQL, xleftmargin=80pt]
SELECT nom FROM Personne AS P1
WHERE NOT EXISTS
    (SELECT prenom FROM Personne AS P2
    WHERE P1.nom = P1.prenom);\end{lstlisting}
            \end{indt}
        \end{indt}

        \vspace{12pt}
        
        \begin{indt}{\subsection{Jointures}}
            \label{3.2}

            \begin{indt}{\subsubsection{Principe}}
                Il s'agit d'établir un lien entre plusieurs tables sous certaines contraintes.

                L'idée est la même que la création d'une table de jonction pour décomposer une association $*-*$ : un opérateur de jointure crée une nouvelle relation recollant les enregistrements de deux relations qui se correspondent. La correspondance entre deux enregistrements est exprimée par le satisfaction des contraintes passées en argument de l'opérateur.

                Les contraintes sont dans la plupart des cas l'égalité de deux attributs, le plus souvent entre la clé primaire de l'une des tables et une clé étrangère y faisant référence dans la seconde table.
            \end{indt}

            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Jointure interne}}
                La jointure interne est une opération prenant deux relations et une condition en argument et qui produit une relation dont le schéma est la concaténation des schémas des deux relations (comme pour le produit cartésien) et dont les enregistrements sont les concaténations des tuples des deux relations qui satisfont la condition.

                Réalisation SQL :

                \begin{lstlisting}[language=SQL, xleftmargin=80pt]
SELECT ... FROM R JOIN R2 ON C ...\end{lstlisting}

                \vspace{12pt}
                
                La condition C s'écrit de la même manière que les conditions de la clause \texttt{WHERE}.

                \vspace{6pt}
                
                \begin{indt}{Exemple : on dispose des tables suivantes :
}
                    Document(\underline{idDoc: entier}, titre: texte, auteur: texte, genre: enum(...))

                    Personne(\underline{id: entier}, nom: texte, prénom: texte)

                    Emprunt(\underline{id: entier, idDoc: entier}, dateEmprunt: date, dateRetour: date)
                \end{indt}

                \vspace{12pt}
                
                On souhaite récupérer les noms et prénoms des emprunteurs avec les dates de retour associées :

                \begin{lstlisting}[language=SQL, xleftmargin=80pt]
SELECT nom, prenom, dateRetour
FROM Personne JOIN Emprunt ON Personne.id = Emprunt.id;\end{lstlisting}
                
                On peut enchaîner les jointures (en pratique la jointure de deux tables sert d'argument à la jointure suivante). Il faut donc une condition par jointure.

                Exemple : on veut les mêmes informations qu'avant et en plus le titre du document, et seulement pour les retour en retard.

                \begin{lstlisting}[language=SQL, xleftmargin=80pt]
SELECT nom, prenom, dateRetour, titre
FROM Personne
    JOIN Emprunt ON Personne.id = Emprunt.id
    JOIN Document ON Document.idDoc = Emprunt.idDoc
WHERE dateRetour < [date du jour];\end{lstlisting}

                \vspace{6pt}
                
                Pourquoi un opérateur de jointure alors qu'on peut l'implémenter avec un produit cartésien ?

                \vspace{6pt}
                
                $-$ A \textit{priori}, les SGBD peuvent optimiser les jointures alors qu'il faut construire tous les tuples du produit cartésien avant de faire la sélection.

                $-$ Une condition de jointure est une contrainte structurelle exprimant les associations entre plusieurs tables alors qu'une condition de sélection sert plutôt à filtrer les enregistrements pertinents pour la requête : la logique est différente.

                $-$ On gagne en lisibilité en séparant les deux types de condition et en séparant les conditions associées à chaque jointure.

                \vspace{12pt}
                
                Remarque : la \textit{jointure interne} est aussi simplement appelée \textit{jointure} : c'est le type de jointure par défaut.
            \end{indt}

            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Jointure externe à gauche}}
                Une \textit{jointure externe à gauche} fonctionne comme une jointure interne, mais les enregistrements de la première relation pour lesquels il n'existe aucun enregistrement dans la seconde relation tel que leur concaténation satisfait la condition de jointure sont conservés. Pour respecter le schéma du résultat (qui est la concaténation des schémas des deux tables), on associe à ces enregistrements la valeur \texttt{NULL} pour chaque attribut qui provient de la seconde table.

                Réalisation SQL : comme pour la jointure interne en remplaçant \texttt{JOIN} par \texttt{LEFT JOIN}.

                \vspace{12pt}
                
                Exemple : noms, prénoms des emprunteurs associés aux dates de retour, s'il y en a :

                \begin{lstlisting}[language=SQL, xleftmargin=80pt]
SELECT nom, prenom, dateRetour
FROM Personne LEFT JOIN Emprunt ON Personne.id = Emprunt.id;\end{lstlisting}

                \vspace{6pt}
                
                \begin{tabular}{lcl}
                    Personne & : &
                    \begin{tabular}{|c|c|c|}
                        \hline
                        idAlice & Alice & Dupond
                        \\
                        \hline
                        idBob & Bob & Dupont
                        \\
                        \hline
                    \end{tabular}
                    \vspace{6pt}
                    \\
                    Emprunt & : &
                    \begin{tabular}{|c|c|c|}
                        \hline
                        idAlice & 2022-05-04 & idDoc1
                        \\
                        \hline
                        idAlice & 2022-05-05 & idDoc2
                        \\
                        \hline
                    \end{tabular}
                    \vspace{6pt}
                    \\
                    Résultat & : &
                    \begin{tabular}{|c|c|c|}
                        \hline
                        Alice & Dupond & 2022-05-04
                        \\
                        \hline
                        Alice & Dupond & 2022-05-05
                        \\
                        \hline
                        Bob & Dupont & NULL
                        \\
                        \hline
                    \end{tabular}
                \end{tabular}

                \begin{indt}{Remarque : il existe d'autres types de jointure (H.P) :}
                    $-$ Externe à droite (\texttt{RIGHT JOIN})

                    $-$ naturelle (\texttt{NATURAL JOIN})

                    $-$ totale (\texttt{TOTAL JOIN})
                \end{indt}
            \end{indt}
        \end{indt}

        \vspace{12pt}
        
        \begin{indt}{\subsection{Agrégation et imbrication}}
            \label{3.3}

            \begin{indt}{\subsubsection{Application de fonctions aux attributs}}
                Il est possible d'appliquer des fonctions aux attributs des tuples sélectionnés par une requête pour calculer de nouvelles valeurs.

                Sont au programme : \texttt{+, -, *, /}.

                Exemple : la durée restante avant le retour pour les documents empruntés :

                \begin{lstlisting}[language=SQL, xleftmargin=80pt]
SELECT idDoc, dateRetour - '2022-05-09' AS delai FROM Emprunt;\end{lstlisting}

                Remarque : ces fonctions permettent d'obtenir un résultat pour chaque tuple sélectionné en fonction des valeurs de ses attributs. On peut vouloir au contraire travailler sur une colonne, \textit{i.e} sur l'ensemble des valeurs prises par un attribut pour tous les enregistrements sélectionnés : c'est le rôle des fonctions agrégatives.
            \end{indt}

            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Fonctions d'agrégation}}
                Une \textit{fonction d'agrégation} ou \textit{fonction agrégative} est une fonction qui s'applique à l'ensemble des valeurs d'un attribut donné pour tous les enregistrements sélectionnés. Une telle fonction renvoie en général un unique résultat donc la table créée par la requête ne contient qu'une seule ligne.

                Sont au programme : \texttt{MIN, MAX, SUM, AVG, COUNT} (cardinal du multi-ensemble des valeurs privé de \texttt{NULL})

                Exemple : nombre de documents empruntés :

                \begin{lstlisting}[language=SQL, xleftmargin=80pt]
SELECT COUNT(idDoc) FROM Emprunt;\end{lstlisting}

                Remarque : ici, le choix de l'attribut n'est pas important tant que c'est  une clé car on veut calculer le nombre d'enregistrements. On dispose de la syntaxe \texttt{COUNT(*)} pour cela.

                \vspace{6pt}
                
                Pour connaître le nombre d'auteurs dont une \oe uvre est dans la bibliothèque, on peut avoir des doublons que l'on veut éliminer avant comptage : on place le mot clé \texttt{DISTINCT} dans l'argument de la fonction \texttt{COUNT} :

                \begin{lstlisting}[language=SQL, xleftmargin=80pt]
SELECT COUNT(DISTINCT auteur) FROM Document;\end{lstlisting}
            \end{indt}

            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Regroupement d'enregistrements}}
                On peut réunir dans un groupe les enregistrements d'une table qui coïncident sur un ensemble d'attributs. On obtient dans le résultat de la requête un tuple par groupe.

                Réalisation SQL :

                \begin{lstlisting}[language=SQL, xleftmargin=80pt]
SELECT ... GROUP BY attribut_1, ... attribut_n;\end{lstlisting}

                Exemple :

                \begin{lstlisting}[language=SQL, xleftmargin=80pt]
SELECT auteur FROM Document
GROUP BY auteur;\end{lstlisting}

                équivalent à :

                \begin{lstlisting}[language=SQL, xleftmargin=80pt]
SELECT DISTINCT auteur FROM Document;\end{lstlisting}

                On peut bien sûr projeter sur plusieurs attributs, mais cela n'a pas de sens si ces attributs n'ont pas la même valeur pour tous les tuples d'un groupe.

                Exemple :

                \begin{lstlisting}[language=SQL, xleftmargin=80pt]
SELECT auteur, titre FROM Document
GROUP BY auteur;\end{lstlisting}

                Ici, MySQL conserve le titre du premier enregistrement traité de chaque groupe.

                \vspace{12pt}
                
                En pratique, le regroupement perd tout son intérêt s'il est combiné avec les fonctions agrégatives car elles permettent d'obtenir une valeur unique pour tous les enregistrements d'un groupe.

                Exemple : nombre d'ouvrages dans la bibliothèque pour chaque auteur :

                \begin{lstlisting}[language=SQL, xleftmargin=80pt]
SELECT auteur, COUNT(*) FROM Document
GROUP BY auteur;\end{lstlisting}

                Nombre d'ouvrages empruntés pour chaque usager :

                \begin{lstlisting}[language=SQL, xleftmargin=80pt]
SELECT Personne.id, COUNT(idDoc)
FROM Personne LEFT JOIN Emprunt ON Personne.id = Emprunt.id
GROUP BY Personne.id;\end{lstlisting}

                Nombre d'homonymes parmi les usagers :

                \begin{lstlisting}[language=SQL, xleftmargin=80pt]
SELECT nom, prenom COUNT(*) FROM Personne
GROUP BY nom, prenom;\end{lstlisting}
            \end{indt}

            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Filtrage des agrégats}}
                On peut vouloir sélectionner certains enregistrements après regroupement et / ou après application d'une fonction d'agrégation. Par exemple, on veut garder les usagers qui ont empruntés au moins 10 documents. 

                Réalisation SQL : on utilise le mot clé \texttt{HAVING}, qui s'utilise comme \texttt{WHERE}, mais qui sélectionne les tuples après regroupement contrairement à \texttt{WHERE} qui les sélectionne avant.

                \begin{lstlisting}[language=SQL, xleftmargin=80pt]
SELECT ... HAVING condition;\end{lstlisting}

                La condition de la clause \texttt{HAVING} ne peut porter que sur des caractéristiques du groupe, \textit{i.e} sur des attributs sur lesquelles tous les tuples du groupe coïncident ou sur le résultat de l'application d'une fonction agrégative sur les tuples du groupe.
                
                Exemple :

                \begin{lstlisting}[language=SQL, xleftmargin=80pt]
SELECT id, COUNT(*) FROM Emprunt
GROUP BY id
HAVING COUNT(*) >= 10;\end{lstlisting}

                \vspace{6pt}
                
                Usagers ayant au moins deux documents en retard :

                \begin{lstlisting}[language=SQL, xleftmargin=80pt]
SELECT id FROM Emprunt
WHERE dateRetour < '2022-05-09'
GROUP BY id
HAVING COUNT(*) >= 2;\end{lstlisting}

                Si on veut connaître les usagers ayant le plus de documents en retard ?
                Ici, on veut pouvoir réutiliser le résultat d'une requête pour faire une autre requête.
            \end{indt}

            \vspace{12pt}
            
            \begin{indt}{\subsubsection{Requêtes imbriquées}}
                Une \textit{sous-requête} est une requête imbriquée dans une autre. On parle aussi de \textit{requête interne}, par opposition à la \textit{requête externe}, ou \textit{englobante} qui la contient. Une sous-requête doit être écrite entre parenthèses et peut être placée à divers endroits.

                \vspace{12pt}
                
                $\bullet$ Sous-requête dans une clause \texttt{FROM} :

                Exemple : nombre moyen de documents en retard par usager :

                \begin{lstlisting}[language=SQL, xleftmargin=80pt]
SELECT AVG(nbreRetard)
FROM (
    SELECT COUNT(*) AS nbreRetard FROM Emprunt
    WHERE dateRetour < '2022-05-09'
    GROUP BY id
);\end{lstlisting}

                \vspace{12pt}
                
                \begin{indt}{$\bullet$ Sous-requête dans une clause \texttt{WHERE} ou \texttt{HAVING} : l'usage du résultat de la sous-requête dépend de son nombre de lignes :}
                    $-$ Cas des sous-requêtes dont le résultat ne contient qu'une seule ligne : on utilise directement ce résultat comme on aurait utilisé les attributs d'un enregistrement donné.

                    Exemple : usagers ayant le plus de documents en retard :

                    \begin{lstlisting}[language=SQL, xleftmargin=100pt]
SELECT id FROM (
    SELECT id, COUNT(*) AS nbRetard FROM Emprunt
    WHERE dateRetour < '2022-05-09'
    GROUP BY id
) AS Tretard
WHERE nbRetard = (SELECT MAX(nbRetard) FROM Tretard);\end{lstlisting}

                    \vspace{12pt}
                    
                    $-$ Cas des sous-requêtes à plusieurs résultats : on ne peut pas utiliser les opérateurs habituels car la sous-requête renvoie une table et pas une unique valeur.
                    On dispose d'opérateurs pour vérifier si cette table est vide ou pas (\texttt{EXISTS}, \texttt{NOT EXISTS}) et pour vérifier si une valeur apparaît dans la table (\texttt{IN}, \texttt{NOT IN}).

                    Exemple : usagers sans emprunts en cours :

                    \begin{lstlisting}[language=SQL, xleftmargin=100pt]
SELECT id FROM Personne
WHERE id NOT IN (
    SELECT id FROM Emprunt
);\end{lstlisting}

                    ou

                    \begin{lstlisting}[language=SQL, xleftmargin=100pt]
SELECT id FROM Personne
WHERE NOT EXISTS (
    SELECT id FROM Emprunt
    WHERE Personne.id = Emprunt.id
);\end{lstlisting}

                    \vspace{12pt}
                    
                    Usagers ne partageant pas leur nom de famille avec d'autres :

                    \begin{lstlisting}[language=SQL, xleftmargin=100pt]
SELECT id FROM Personne
WHERE NOT EXISTS (
    SELECT id FROM Personne AS P
    WHERE P.id <> Personne =.id AND P.nom = Personne.nom
);\end{lstlisting}
                \end{indt}
            \end{indt}
        \end{indt}
    \end{indt}
    
    
    
\end{document}
%--------------------------------------------End
